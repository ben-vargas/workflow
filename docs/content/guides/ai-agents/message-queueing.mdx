---
title: Queueing User Messages
---

import { AgentTraces } from '@/components/guides/agent-traces';

In some scenarios, you want to queue new messages into an ongoing AI agent conversation. For example, when a user sends follow-up messages while the agent is still processing, or when external events need to influence the conversation mid-stream.

Workflow DevKit's [`defineHook()`](/docs/api-reference/workflow/define-hook) enables this pattern: defining a typed hook that can be resumed programmatically via an API endpoint, allowing both users and backend systems to enqueue messages for an existing workflow run.

Messages get queued until the next tool call gets executed, and then get flushed to the AI call with the tool call results.

<AgentTraces variant="message-queue" />

## How It Works

<Steps>

<Step>
A hook is defined with a schema for incoming messages, and the workflow creates instances of this hook in a loop.
</Step>

<Step>
The agent processes messages and returns the updated conversation history.
</Step>

<Step>
The workflow waits for the hook to be resumed, then processes the new message.
</Step>

<Step>
An API endpoint accepts a `runId` and `message`, resuming the hook programmatically.
</Step>

<Step>
A special command (like `/done`) signals the end of the conversation.
</Step>

</Steps>

## Implementation

<Tabs items={['Workflow', 'API Routes', 'Hook Definition']}>

<Tab value="Workflow">

The workflow creates hook instances in a loop, waiting for each message:

```typescript title="app/api/chat/workflow.ts" lineNumbers
import { DurableAgent } from '@workflow/ai/agent';
import type { ModelMessage, UIMessageChunk } from 'ai';
import { getWritable } from 'workflow';
import { chatMessageHook } from '@/ai/hooks/chat-message';

export async function chatWorkflow(initialMessage: string) {
  'use workflow';

  const writable = getWritable<UIMessageChunk>();

  const agent = new DurableAgent({ /* ... agent setup */ })

  const hook = chatMessageHook.create(); // [!code highlight]

  while (true) { // [!code highlight]

    // Do a stream step
    const { messages: latest } = await agent.stream({
      writable,
      messages,
      preventClose: true, // [!code highlight] keep agent open for follow-ups
    });

    // Then check if any messages have been queued, or wait for a new one to arrive
    const { message, username } = await hook; // [!code highlight]
    if (message === '/done') {
      break;
    }
    const content = username ? `[${username}]: ${message}` : message;
    messages.push({ role: 'user', content }); // [!code highlight] add to conversation
  }

  // [... close stream]

  return { messages };
}
```

<Callout type="info">
Each `chatMessageHook.create()` generates a new hook instance. The workflow suspends at `await hook` until the hook is resumed via the API.
</Callout>

</Tab>

<Tab value="API Routes">

Two endpoints: one to start the workflow, one to enqueue messages:

```typescript title="app/api/chat/route.ts" lineNumbers
import { createUIMessageStreamResponse, convertToModelMessages } from 'ai';
import { start } from 'workflow/api';
import { chatWorkflow } from './workflow';

export async function POST(req: Request) {
  const { message } = await req.json();

  const run = await start(chatWorkflow, [message]); // [!code highlight]

  return createUIMessageStreamResponse({
    stream: run.readable,
    headers: {
      'X-Run-Id': run.id, // Return runId to client // [!code highlight]
    },
  });
}
```

```typescript title="app/api/chat/message/route.ts" lineNumbers
import { chatMessageHook } from '@/ai/hooks/chat-message';

export async function POST(req: Request) {
  const { runId, message, username } = await req.json();

  try {
    await chatMessageHook.resume(runId, { message, username }); // [!code highlight]
    return Response.json({ success: true });
  } catch (error) {
    return Response.json(
      { error: 'Failed to enqueue message' },
      { status: 400 }
    );
  }
}
```

This API can be called by:

- **UI clients** sending follow-up messages
- **Backend services** injecting system events
- **External systems** via API integration

</Tab>

<Tab value="Hook Definition">

Define a typed hook for incoming messages:

```typescript title="ai/hooks/chat-message.ts" lineNumbers
import { defineHook } from 'workflow';
import { z } from 'zod';

export const chatMessageHook = defineHook({
  schema: z.object({
    message: z.string(),
    username: z.string().optional(),
  }),
});
```

</Tab>

</Tabs>

## Client Integration

The client stores the `runId` from the initial response and uses it for follow-ups:

```typescript title="hooks/use-chat-with-queue.ts" lineNumbers
'use client';

import { useState, useCallback } from 'react';

export function useChatWithQueue() {
  const [runId, setRunId] = useState<string | null>(null);

  const startChat = useCallback(async (message: string) => {
    const response = await fetch('/api/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message }),
    });

    // Store runId for follow-up messages // [!code highlight]
    const id = response.headers.get('X-Run-Id'); // [!code highlight]
    setRunId(id); // [!code highlight]

    return response.body; // Stream for UI rendering
  }, []);

  const sendMessage = useCallback(async (message: string) => {
    if (!runId) return;

    await fetch('/api/chat/message', { // [!code highlight]
      method: 'POST', // [!code highlight]
      headers: { 'Content-Type': 'application/json' }, // [!code highlight]
      body: JSON.stringify({ runId, message }), // [!code highlight]
    }); // [!code highlight]
  }, [runId]);

  const endChat = useCallback(async () => {
    if (!runId) return;
    await fetch('/api/chat/message', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ runId, message: '/done' }),
    });
    setRunId(null);
  }, [runId]);

  return { runId, startChat, sendMessage, endChat };
}
```

## Use Cases

### System Event Injection

Backend services can inject messages based on external events:

```typescript title="app/api/webhooks/payment/route.ts" lineNumbers
import { chatMessageHook } from '@/ai/hooks/chat-message';

export async function POST(req: Request) {
  const { runId, paymentStatus, amount } = await req.json();

  // Inject payment notification into the conversation // [!code highlight]
  await chatMessageHook.resume(runId, { // [!code highlight]
    message: `Payment ${paymentStatus}: $${amount}`, // [!code highlight]
    username: 'system', // [!code highlight]
  }); // [!code highlight]

  return Response.json({ success: true });
}
```

### Collaborative Sessions

Multiple users can send messages to the same conversation by sharing the `runId`:

```typescript lineNumbers
// Any participant can enqueue messages using the shared runId
await fetch('/api/chat/message', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    runId: sharedRunId,
    message: 'I have a question about that',
    username: 'Alice',
  }),
});
```

### Scheduled Follow-ups

Use `sleep()` in combination with hooks for time-delayed messages:

```typescript lineNumbers
import { sleep } from 'workflow';

export async function chatWithRemindersWorkflow(initialMessage: string) {
  'use workflow';

  // ... agent setup (see "Building Durable AI Agents" guide)

  while (true) {
    const hook = chatMessageHook.create();

    // Race between user message and reminder timeout // [!code highlight]
    const result = await Promise.race([ // [!code highlight]
      hook.then((data) => ({ type: 'message' as const, data })), // [!code highlight]
      sleep('5m').then(() => ({ type: 'timeout' as const })), // [!code highlight]
    ]); // [!code highlight]

    if (result.type === 'timeout') {
      messages.push({
        role: 'user',
        content: '[System: User has been idle for 5 minutes]',
      });
    } else if (result.data.message === '/done') {
      break;
    } else {
      messages.push({ role: 'user', content: result.data.message });
    }

    // Continue conversation...
  }
}
```

## Related Documentation

- [Building Durable AI Agents](/guides/ai-agents) - Complete guide to creating durable agents
- [Human-in-the-Loop](/guides/ai-agents/human-in-the-loop) - Using hooks for approval workflows
- [Sleep and Delays](/guides/ai-agents/sleep-and-delays) - Time-based workflow patterns
- [`defineHook()` API Reference](/docs/api-reference/workflow/define-hook) - Hook configuration options
