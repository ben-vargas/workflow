import { jsx, jsxs, Fragment } from "react/jsx-runtime";
import require$$0$4, { PassThrough } from "node:stream";
import { createReadableStreamFromReadable } from "@react-router/node";
import { ServerRouter, UNSAFE_withComponentProps, Outlet, UNSAFE_withErrorBoundaryProps, isRouteErrorResponse, Meta, Links, ScrollRestoration, Scripts } from "react-router";
import { isbot } from "isbot";
import { renderToPipeableStream } from "react-dom/server";
import { readdir, readlink, readFile } from "node:fs/promises";
import require$$0$5, { promisify, types as types$1 } from "node:util";
import { execFile } from "node:child_process";
import * as z from "zod";
import z__default, { z as z$1, ZodError } from "zod";
import { z as z$2 } from "zod/v4";
import require$$1 from "tty";
import require$$1$1 from "util";
import require$$0 from "os";
import { createRequire } from "node:module";
import path, { join as join$1 } from "node:path";
import { setTimeout as setTimeout$1 } from "node:timers/promises";
import require$$0$1 from "events";
import crypto$1 from "node:crypto";
import require$$0$3 from "node:assert";
import require$$4 from "node:net";
import require$$2 from "node:http";
import require$$0$2 from "node:buffer";
import require$$7 from "node:querystring";
import require$$8, { EventEmitter } from "node:events";
import require$$0$6 from "node:diagnostics_channel";
import require$$4$1 from "node:tls";
import require$$1$2 from "node:zlib";
import require$$5 from "node:perf_hooks";
import require$$8$1 from "node:util/types";
import require$$1$3 from "node:url";
import require$$5$1, { AsyncLocalStorage } from "node:async_hooks";
import require$$1$4 from "node:console";
import require$$5$2 from "string_decoder";
import require$$3 from "node:worker_threads";
import { promises } from "node:fs";
import os from "node:os";
import { createContext as createContext$1, runInContext } from "node:vm";
import { useRef, useEffect } from "react";
const streamTimeout = 5e3;
function handleRequest(request2, responseStatusCode, responseHeaders, routerContext, loadContext) {
  if (request2.method.toUpperCase() === "HEAD") {
    return new Response(null, {
      status: responseStatusCode,
      headers: responseHeaders
    });
  }
  return new Promise((resolve2, reject) => {
    let shellRendered = false;
    let userAgent = request2.headers.get("user-agent");
    let readyOption = userAgent && isbot(userAgent) || routerContext.isSpaMode ? "onAllReady" : "onShellReady";
    let timeoutId = setTimeout(
      () => abort(),
      streamTimeout + 1e3
    );
    const { pipe, abort } = renderToPipeableStream(
      /* @__PURE__ */ jsx(ServerRouter, { context: routerContext, url: request2.url }),
      {
        [readyOption]() {
          shellRendered = true;
          const body2 = new PassThrough({
            final(callback) {
              clearTimeout(timeoutId);
              timeoutId = void 0;
              callback();
            }
          });
          const stream = createReadableStreamFromReadable(body2);
          responseHeaders.set("Content-Type", "text/html");
          pipe(body2);
          resolve2(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          );
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500;
          if (shellRendered) {
            console.error(error);
          }
        }
      }
    );
  });
}
const entryServer = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: handleRequest,
  streamTimeout
}, Symbol.toStringTag, { value: "Module" }));
const links = () => [{
  rel: "preconnect",
  href: "https://fonts.googleapis.com"
}, {
  rel: "preconnect",
  href: "https://fonts.gstatic.com",
  crossOrigin: "anonymous"
}, {
  rel: "stylesheet",
  href: "https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap"
}];
function Layout({
  children
}) {
  return /* @__PURE__ */ jsxs("html", {
    lang: "en",
    children: [/* @__PURE__ */ jsxs("head", {
      children: [/* @__PURE__ */ jsx("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */ jsx("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1"
      }), /* @__PURE__ */ jsx(Meta, {}), /* @__PURE__ */ jsx(Links, {})]
    }), /* @__PURE__ */ jsxs("body", {
      children: [children, /* @__PURE__ */ jsx(ScrollRestoration, {}), /* @__PURE__ */ jsx(Scripts, {})]
    })]
  });
}
const root = UNSAFE_withComponentProps(function App() {
  return /* @__PURE__ */ jsx(Outlet, {});
});
const ErrorBoundary = UNSAFE_withErrorBoundaryProps(function ErrorBoundary2({
  error
}) {
  let message = "Oops!";
  let details = "An unexpected error occurred.";
  let stack;
  if (isRouteErrorResponse(error)) {
    message = error.status === 404 ? "404" : "Error";
    details = error.status === 404 ? "The requested page could not be found." : error.statusText || details;
  }
  return /* @__PURE__ */ jsxs("main", {
    className: "pt-16 p-4 container mx-auto",
    children: [/* @__PURE__ */ jsx("h1", {
      children: message
    }), /* @__PURE__ */ jsx("p", {
      children: details
    }), stack]
  });
});
const route0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ErrorBoundary,
  Layout,
  default: root,
  links
}, Symbol.toStringTag, { value: "Module" }));
async function normalizeRequestConverter$2(request2) {
  const options = {
    method: request2.method,
    headers: new Headers(request2.headers)
  };
  if (!["GET", "HEAD", "OPTIONS", "TRACE", "CONNECT"].includes(request2.method)) {
    options.body = await request2.arrayBuffer();
  }
  return new Request(request2.url, options);
}
async function action$6({
  request: request2
}) {
  const impl = await import("./flow-impl-C8ALDz7c.js");
  const normalRequest = await normalizeRequestConverter$2(request2);
  return impl.handleRequest(normalRequest);
}
const route1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  action: action$6
}, Symbol.toStringTag, { value: "Module" }));
async function normalizeRequestConverter$1(request2) {
  const options = {
    method: request2.method,
    headers: new Headers(request2.headers)
  };
  if (!["GET", "HEAD", "OPTIONS", "TRACE", "CONNECT"].includes(request2.method)) {
    options.body = await request2.arrayBuffer();
  }
  return new Request(request2.url, options);
}
async function action$5({
  request: request2
}) {
  const impl = await import("./step-impl-BRE5MoxU.js");
  const normalRequest = await normalizeRequestConverter$1(request2);
  return impl.handleRequest(normalRequest);
}
const route2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  action: action$5
}, Symbol.toStringTag, { value: "Module" }));
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var headers$1;
var hasRequiredHeaders$1;
function requireHeaders$1() {
  if (hasRequiredHeaders$1) return headers$1;
  hasRequiredHeaders$1 = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var headers_exports = {};
  __export(headers_exports, {
    CITY_HEADER_NAME: () => CITY_HEADER_NAME,
    COUNTRY_HEADER_NAME: () => COUNTRY_HEADER_NAME,
    EMOJI_FLAG_UNICODE_STARTING_POSITION: () => EMOJI_FLAG_UNICODE_STARTING_POSITION,
    IP_HEADER_NAME: () => IP_HEADER_NAME,
    LATITUDE_HEADER_NAME: () => LATITUDE_HEADER_NAME,
    LONGITUDE_HEADER_NAME: () => LONGITUDE_HEADER_NAME,
    POSTAL_CODE_HEADER_NAME: () => POSTAL_CODE_HEADER_NAME,
    REGION_HEADER_NAME: () => REGION_HEADER_NAME,
    REQUEST_ID_HEADER_NAME: () => REQUEST_ID_HEADER_NAME,
    geolocation: () => geolocation,
    ipAddress: () => ipAddress
  });
  headers$1 = __toCommonJS(headers_exports);
  const CITY_HEADER_NAME = "x-vercel-ip-city";
  const COUNTRY_HEADER_NAME = "x-vercel-ip-country";
  const IP_HEADER_NAME = "x-real-ip";
  const LATITUDE_HEADER_NAME = "x-vercel-ip-latitude";
  const LONGITUDE_HEADER_NAME = "x-vercel-ip-longitude";
  const REGION_HEADER_NAME = "x-vercel-ip-country-region";
  const POSTAL_CODE_HEADER_NAME = "x-vercel-ip-postal-code";
  const REQUEST_ID_HEADER_NAME = "x-vercel-id";
  const EMOJI_FLAG_UNICODE_STARTING_POSITION = 127397;
  function getHeader(headers2, key) {
    return headers2.get(key) ?? void 0;
  }
  function getHeaderWithDecode(request2, key) {
    const header = getHeader(request2.headers, key);
    return header ? decodeURIComponent(header) : void 0;
  }
  function getFlag(countryCode) {
    const regex = new RegExp("^[A-Z]{2}$").test(countryCode);
    if (!countryCode || !regex)
      return void 0;
    return String.fromCodePoint(
      ...countryCode.split("").map((char) => EMOJI_FLAG_UNICODE_STARTING_POSITION + char.charCodeAt(0))
    );
  }
  function ipAddress(input) {
    const headers2 = "headers" in input ? input.headers : input;
    return getHeader(headers2, IP_HEADER_NAME);
  }
  function getRegionFromRequestId(requestId) {
    if (!requestId) {
      return "dev1";
    }
    return requestId.split(":")[0];
  }
  function geolocation(request2) {
    return {
      // city name may be encoded to support multi-byte characters
      city: getHeaderWithDecode(request2, CITY_HEADER_NAME),
      country: getHeader(request2.headers, COUNTRY_HEADER_NAME),
      flag: getFlag(getHeader(request2.headers, COUNTRY_HEADER_NAME)),
      countryRegion: getHeader(request2.headers, REGION_HEADER_NAME),
      region: getRegionFromRequestId(
        getHeader(request2.headers, REQUEST_ID_HEADER_NAME)
      ),
      latitude: getHeader(request2.headers, LATITUDE_HEADER_NAME),
      longitude: getHeader(request2.headers, LONGITUDE_HEADER_NAME),
      postalCode: getHeader(request2.headers, POSTAL_CODE_HEADER_NAME)
    };
  }
  return headers$1;
}
var getEnv_1;
var hasRequiredGetEnv;
function requireGetEnv() {
  if (hasRequiredGetEnv) return getEnv_1;
  hasRequiredGetEnv = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var get_env_exports = {};
  __export(get_env_exports, {
    getEnv: () => getEnv
  });
  getEnv_1 = __toCommonJS(get_env_exports);
  const getEnv = (env = process.env) => ({
    /**
     * An indicator to show that System Environment Variables have been exposed to your project's Deployments.
     * @example "1"
     */
    VERCEL: get(env, "VERCEL"),
    /**
     * An indicator that the code is running in a Continuous Integration environment.
     * @example "1"
     */
    CI: get(env, "CI"),
    /**
     * The Environment that the app is deployed and running on.
     * @example "production"
     */
    VERCEL_ENV: get(env, "VERCEL_ENV"),
    /**
     * The domain name of the generated deployment URL. The value does not include the protocol scheme https://.
     * NOTE: This Variable cannot be used in conjunction with Standard Deployment Protection.
     * @example "*.vercel.app"
     */
    VERCEL_URL: get(env, "VERCEL_URL"),
    /**
     * The domain name of the generated Git branch URL. The value does not include the protocol scheme https://.
     * @example "*-git-*.vercel.app"
     */
    VERCEL_BRANCH_URL: get(env, "VERCEL_BRANCH_URL"),
    /**
     * A production domain name of the project. This is useful to reliably generate links that point to production such as OG-image URLs.
     * The value does not include the protocol scheme https://.
     * @example "myproject.vercel.app"
     */
    VERCEL_PROJECT_PRODUCTION_URL: get(env, "VERCEL_PROJECT_PRODUCTION_URL"),
    /**
     * The ID of the Region where the app is running.
     *
     * Possible values:
     * - arn1 (Stockholm, Sweden)
     * - bom1 (Mumbai, India)
     * - cdg1 (Paris, France)
     * - cle1 (Cleveland, USA)
     * - cpt1 (Cape Town, South Africa)
     * - dub1 (Dublin, Ireland)
     * - fra1 (Frankfurt, Germany)
     * - gru1 (SÃ£o Paulo, Brazil)
     * - hkg1 (Hong Kong)
     * - hnd1 (Tokyo, Japan)
     * - iad1 (Washington, D.C., USA)
     * - icn1 (Seoul, South Korea)
     * - kix1 (Osaka, Japan)
     * - lhr1 (London, United Kingdom)
     * - pdx1 (Portland, USA)
     * - sfo1 (San Francisco, USA)
     * - sin1 (Singapore)
     * - syd1 (Sydney, Australia)
     * - dev1 (Development Region)
     *
     * @example "iad1"
     */
    VERCEL_REGION: get(env, "VERCEL_REGION"),
    /**
     * The unique identifier for the deployment, which can be used to implement Skew Protection.
     * @example "dpl_7Gw5ZMBpQA8h9GF832KGp7nwbuh3"
     */
    VERCEL_DEPLOYMENT_ID: get(env, "VERCEL_DEPLOYMENT_ID"),
    /**
     * When Skew Protection is enabled in Project Settings, this value is set to 1.
     * @example "1"
     */
    VERCEL_SKEW_PROTECTION_ENABLED: get(env, "VERCEL_SKEW_PROTECTION_ENABLED"),
    /**
     * The Protection Bypass for Automation value, if the secret has been generated in the project's Deployment Protection settings.
     */
    VERCEL_AUTOMATION_BYPASS_SECRET: get(env, "VERCEL_AUTOMATION_BYPASS_SECRET"),
    /**
     * The Git Provider the deployment is triggered from.
     * @example "github"
     */
    VERCEL_GIT_PROVIDER: get(env, "VERCEL_GIT_PROVIDER"),
    /**
     * The origin repository the deployment is triggered from.
     * @example "my-site"
     */
    VERCEL_GIT_REPO_SLUG: get(env, "VERCEL_GIT_REPO_SLUG"),
    /**
     * The account that owns the repository the deployment is triggered from.
     * @example "acme"
     */
    VERCEL_GIT_REPO_OWNER: get(env, "VERCEL_GIT_REPO_OWNER"),
    /**
     * The ID of the repository the deployment is triggered from.
     * @example "117716146"
     */
    VERCEL_GIT_REPO_ID: get(env, "VERCEL_GIT_REPO_ID"),
    /**
     * The git branch of the commit the deployment was triggered by.
     * @example "improve-about-page"
     */
    VERCEL_GIT_COMMIT_REF: get(env, "VERCEL_GIT_COMMIT_REF"),
    /**
     * The git SHA of the commit the deployment was triggered by.
     * @example "fa1eade47b73733d6312d5abfad33ce9e4068081"
     */
    VERCEL_GIT_COMMIT_SHA: get(env, "VERCEL_GIT_COMMIT_SHA"),
    /**
     * The message attached to the commit the deployment was triggered by.
     * @example "Update about page"
     */
    VERCEL_GIT_COMMIT_MESSAGE: get(env, "VERCEL_GIT_COMMIT_MESSAGE"),
    /**
     * The username attached to the author of the commit that the project was deployed by.
     * @example "johndoe"
     */
    VERCEL_GIT_COMMIT_AUTHOR_LOGIN: get(env, "VERCEL_GIT_COMMIT_AUTHOR_LOGIN"),
    /**
     * The name attached to the author of the commit that the project was deployed by.
     * @example "John Doe"
     */
    VERCEL_GIT_COMMIT_AUTHOR_NAME: get(env, "VERCEL_GIT_COMMIT_AUTHOR_NAME"),
    /**
     * The git SHA of the last successful deployment for the project and branch.
     * NOTE: This Variable is only exposed when an Ignored Build Step is provided.
     * @example "fa1eade47b73733d6312d5abfad33ce9e4068080"
     */
    VERCEL_GIT_PREVIOUS_SHA: get(env, "VERCEL_GIT_PREVIOUS_SHA"),
    /**
     * The pull request id the deployment was triggered by. If a deployment is created on a branch before a pull request is made, this value will be an empty string.
     * @example "23"
     */
    VERCEL_GIT_PULL_REQUEST_ID: get(env, "VERCEL_GIT_PULL_REQUEST_ID")
  });
  const get = (env, key) => {
    const value = env[key];
    return value === "" ? void 0 : value;
  };
  return getEnv_1;
}
var getContext_1$1;
var hasRequiredGetContext$1;
function requireGetContext$1() {
  if (hasRequiredGetContext$1) return getContext_1$1;
  hasRequiredGetContext$1 = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var get_context_exports = {};
  __export(get_context_exports, {
    SYMBOL_FOR_REQ_CONTEXT: () => SYMBOL_FOR_REQ_CONTEXT,
    getContext: () => getContext
  });
  getContext_1$1 = __toCommonJS(get_context_exports);
  const SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
  function getContext() {
    const fromSymbol = globalThis;
    return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
  }
  return getContext_1$1;
}
var waitUntil_1;
var hasRequiredWaitUntil;
function requireWaitUntil() {
  if (hasRequiredWaitUntil) return waitUntil_1;
  hasRequiredWaitUntil = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var wait_until_exports = {};
  __export(wait_until_exports, {
    waitUntil: () => waitUntil
  });
  waitUntil_1 = __toCommonJS(wait_until_exports);
  var import_get_context = requireGetContext$1();
  const waitUntil = (promise) => {
    if (promise === null || typeof promise !== "object" || typeof promise.then !== "function") {
      throw new TypeError(
        `waitUntil can only be called with a Promise, got ${typeof promise}`
      );
    }
    return (0, import_get_context.getContext)().waitUntil?.(promise);
  };
  return waitUntil_1;
}
var middleware;
var hasRequiredMiddleware;
function requireMiddleware() {
  if (hasRequiredMiddleware) return middleware;
  hasRequiredMiddleware = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var middleware_exports = {};
  __export(middleware_exports, {
    next: () => next,
    rewrite: () => rewrite
  });
  middleware = __toCommonJS(middleware_exports);
  function handleMiddlewareField(init, headers2) {
    if (init?.request?.headers) {
      if (!(init.request.headers instanceof Headers)) {
        throw new Error("request.headers must be an instance of Headers");
      }
      const keys = [];
      for (const [key, value] of init.request.headers) {
        headers2.set("x-middleware-request-" + key, value);
        keys.push(key);
      }
      headers2.set("x-middleware-override-headers", keys.join(","));
    }
  }
  function rewrite(destination, init) {
    const headers2 = new Headers(init?.headers ?? {});
    headers2.set("x-middleware-rewrite", String(destination));
    handleMiddlewareField(init, headers2);
    return new Response(null, {
      ...init,
      headers: headers2
    });
  }
  function next(init) {
    const headers2 = new Headers(init?.headers ?? {});
    headers2.set("x-middleware-next", "1");
    handleMiddlewareField(init, headers2);
    return new Response(null, {
      ...init,
      headers: headers2
    });
  }
  return middleware;
}
var inMemoryCache;
var hasRequiredInMemoryCache;
function requireInMemoryCache() {
  if (hasRequiredInMemoryCache) return inMemoryCache;
  hasRequiredInMemoryCache = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var in_memory_cache_exports = {};
  __export(in_memory_cache_exports, {
    InMemoryCache: () => InMemoryCache
  });
  inMemoryCache = __toCommonJS(in_memory_cache_exports);
  class InMemoryCache {
    constructor() {
      this.cache = {};
    }
    async get(key) {
      const entry2 = this.cache[key];
      if (entry2) {
        if (entry2.ttl && entry2.lastModified + entry2.ttl * 1e3 < Date.now()) {
          await this.delete(key);
          return null;
        }
        return entry2.value;
      }
      return null;
    }
    async set(key, value, options) {
      this.cache[key] = {
        value,
        lastModified: Date.now(),
        ttl: options?.ttl,
        tags: new Set(options?.tags || [])
      };
    }
    async delete(key) {
      delete this.cache[key];
    }
    async expireTag(tag) {
      const tags = Array.isArray(tag) ? tag : [tag];
      for (const key in this.cache) {
        if (Object.prototype.hasOwnProperty.call(this.cache, key)) {
          const entry2 = this.cache[key];
          if (tags.some((t) => entry2.tags.has(t))) {
            delete this.cache[key];
          }
        }
      }
    }
  }
  return inMemoryCache;
}
var buildClient;
var hasRequiredBuildClient;
function requireBuildClient() {
  if (hasRequiredBuildClient) return buildClient;
  hasRequiredBuildClient = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var build_client_exports = {};
  __export(build_client_exports, {
    BuildCache: () => BuildCache
  });
  buildClient = __toCommonJS(build_client_exports);
  var import_index = requireCache$1();
  class BuildCache {
    constructor({
      endpoint,
      headers: headers2,
      onError,
      timeout = 500
    }) {
      this.get = async (key) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);
        try {
          const res = await fetch(`${this.endpoint}${key}`, {
            headers: this.headers,
            method: "GET",
            signal: controller.signal
          });
          if (res.status === 404) {
            clearTimeout(timeoutId);
            return null;
          }
          if (res.status === 200) {
            const cacheState = res.headers.get(
              import_index.HEADERS_VERCEL_CACHE_STATE
            );
            if (cacheState !== import_index.PkgCacheState.Fresh) {
              res.body?.cancel?.();
              clearTimeout(timeoutId);
              return null;
            }
            const result = await res.json();
            clearTimeout(timeoutId);
            return result;
          } else {
            clearTimeout(timeoutId);
            throw new Error(`Failed to get cache: ${res.statusText}`);
          }
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === "AbortError") {
            const timeoutError = new Error(
              `Cache request timed out after ${this.timeout}ms`
            );
            timeoutError.stack = error.stack;
            this.onError?.(timeoutError);
          } else {
            this.onError?.(error);
          }
          return null;
        }
      };
      this.set = async (key, value, options) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);
        try {
          const optionalHeaders = {};
          if (options?.ttl) {
            optionalHeaders[import_index.HEADERS_VERCEL_REVALIDATE] = options.ttl.toString();
          }
          if (options?.tags && options.tags.length > 0) {
            optionalHeaders[import_index.HEADERS_VERCEL_CACHE_TAGS] = options.tags.join(",");
          }
          if (options?.name) {
            optionalHeaders[import_index.HEADERS_VERCEL_CACHE_ITEM_NAME] = options.name;
          }
          const res = await fetch(`${this.endpoint}${key}`, {
            method: "POST",
            headers: {
              ...this.headers,
              ...optionalHeaders
            },
            body: JSON.stringify(value),
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (res.status !== 200) {
            throw new Error(`Failed to set cache: ${res.status} ${res.statusText}`);
          }
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === "AbortError") {
            const timeoutError = new Error(
              `Cache request timed out after ${this.timeout}ms`
            );
            timeoutError.stack = error.stack;
            this.onError?.(timeoutError);
          } else {
            this.onError?.(error);
          }
        }
      };
      this.delete = async (key) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);
        try {
          const res = await fetch(`${this.endpoint}${key}`, {
            method: "DELETE",
            headers: this.headers,
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (res.status !== 200) {
            throw new Error(`Failed to delete cache: ${res.statusText}`);
          }
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === "AbortError") {
            const timeoutError = new Error(
              `Cache request timed out after ${this.timeout}ms`
            );
            timeoutError.stack = error.stack;
            this.onError?.(timeoutError);
          } else {
            this.onError?.(error);
          }
        }
      };
      this.expireTag = async (tag) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);
        try {
          if (Array.isArray(tag)) {
            tag = tag.join(",");
          }
          const res = await fetch(`${this.endpoint}revalidate?tags=${tag}`, {
            method: "POST",
            headers: this.headers,
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (res.status !== 200) {
            throw new Error(`Failed to revalidate tag: ${res.statusText}`);
          }
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === "AbortError") {
            const timeoutError = new Error(
              `Cache request timed out after ${this.timeout}ms`
            );
            timeoutError.stack = error.stack;
            this.onError?.(timeoutError);
          } else {
            this.onError?.(error);
          }
        }
      };
      this.endpoint = endpoint;
      this.headers = headers2;
      this.onError = onError;
      this.timeout = timeout;
    }
  }
  return buildClient;
}
var cache$1;
var hasRequiredCache$1;
function requireCache$1() {
  if (hasRequiredCache$1) return cache$1;
  hasRequiredCache$1 = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var cache_exports = {};
  __export(cache_exports, {
    HEADERS_VERCEL_CACHE_ITEM_NAME: () => HEADERS_VERCEL_CACHE_ITEM_NAME,
    HEADERS_VERCEL_CACHE_STATE: () => HEADERS_VERCEL_CACHE_STATE,
    HEADERS_VERCEL_CACHE_TAGS: () => HEADERS_VERCEL_CACHE_TAGS,
    HEADERS_VERCEL_REVALIDATE: () => HEADERS_VERCEL_REVALIDATE,
    PkgCacheState: () => PkgCacheState,
    getCache: () => getCache
  });
  cache$1 = __toCommonJS(cache_exports);
  var import_get_context = requireGetContext$1();
  var import_in_memory_cache = requireInMemoryCache();
  var import_build_client = requireBuildClient();
  const defaultKeyHashFunction = (key) => {
    let hash = 5381;
    for (let i = 0; i < key.length; i++) {
      hash = hash * 33 ^ key.charCodeAt(i);
    }
    return (hash >>> 0).toString(16);
  };
  const defaultNamespaceSeparator = "$";
  let inMemoryCacheInstance = null;
  let buildCacheInstance = null;
  const getCache = (cacheOptions) => {
    const resolveCache = () => {
      let cache2;
      if ((0, import_get_context.getContext)().cache) {
        cache2 = (0, import_get_context.getContext)().cache;
      } else {
        cache2 = getCacheImplementation(
          process.env.SUSPENSE_CACHE_DEBUG === "true"
        );
      }
      return cache2;
    };
    return wrapWithKeyTransformation(
      resolveCache,
      createKeyTransformer(cacheOptions)
    );
  };
  function createKeyTransformer(cacheOptions) {
    const hashFunction = cacheOptions?.keyHashFunction || defaultKeyHashFunction;
    return (key) => {
      if (!cacheOptions?.namespace)
        return hashFunction(key);
      const separator = cacheOptions.namespaceSeparator || defaultNamespaceSeparator;
      return `${cacheOptions.namespace}${separator}${hashFunction(key)}`;
    };
  }
  function wrapWithKeyTransformation(resolveCache, makeKey) {
    return {
      get: (key) => {
        return resolveCache().get(makeKey(key));
      },
      set: (key, value, options) => {
        return resolveCache().set(makeKey(key), value, options);
      },
      delete: (key) => {
        return resolveCache().delete(makeKey(key));
      },
      expireTag: (tag) => {
        return resolveCache().expireTag(tag);
      }
    };
  }
  let warnedCacheUnavailable = false;
  function getCacheImplementation(debug2) {
    if (!inMemoryCacheInstance) {
      inMemoryCacheInstance = new import_in_memory_cache.InMemoryCache();
    }
    if (process.env.RUNTIME_CACHE_DISABLE_BUILD_CACHE === "true") {
      debug2 && console.log("Using InMemoryCache as build cache is disabled");
      return inMemoryCacheInstance;
    }
    const { RUNTIME_CACHE_ENDPOINT, RUNTIME_CACHE_HEADERS } = process.env;
    if (debug2) {
      console.log("Runtime cache environment variables:", {
        RUNTIME_CACHE_ENDPOINT,
        RUNTIME_CACHE_HEADERS
      });
    }
    if (!RUNTIME_CACHE_ENDPOINT || !RUNTIME_CACHE_HEADERS) {
      if (!warnedCacheUnavailable) {
        console.warn(
          "Runtime Cache unavailable in this environment. Falling back to in-memory cache."
        );
        warnedCacheUnavailable = true;
      }
      return inMemoryCacheInstance;
    }
    if (!buildCacheInstance) {
      let parsedHeaders = {};
      try {
        parsedHeaders = JSON.parse(RUNTIME_CACHE_HEADERS);
      } catch (e) {
        console.error("Failed to parse RUNTIME_CACHE_HEADERS:", e);
        return inMemoryCacheInstance;
      }
      let timeout = 500;
      if (process.env.RUNTIME_CACHE_TIMEOUT) {
        const parsed = parseInt(process.env.RUNTIME_CACHE_TIMEOUT, 10);
        if (!isNaN(parsed) && parsed > 0) {
          timeout = parsed;
        } else {
          console.warn(
            `Invalid RUNTIME_CACHE_TIMEOUT value: "${process.env.RUNTIME_CACHE_TIMEOUT}". Using default: ${timeout}ms`
          );
        }
      }
      buildCacheInstance = new import_build_client.BuildCache({
        endpoint: RUNTIME_CACHE_ENDPOINT,
        headers: parsedHeaders,
        onError: (error) => console.error(error),
        timeout
      });
    }
    return buildCacheInstance;
  }
  var PkgCacheState = /* @__PURE__ */ ((PkgCacheState2) => {
    PkgCacheState2["Fresh"] = "fresh";
    PkgCacheState2["Stale"] = "stale";
    PkgCacheState2["Expired"] = "expired";
    PkgCacheState2["NotFound"] = "notFound";
    PkgCacheState2["Error"] = "error";
    return PkgCacheState2;
  })(PkgCacheState || {});
  const HEADERS_VERCEL_CACHE_STATE = "x-vercel-cache-state";
  const HEADERS_VERCEL_REVALIDATE = "x-vercel-revalidate";
  const HEADERS_VERCEL_CACHE_TAGS = "x-vercel-cache-tags";
  const HEADERS_VERCEL_CACHE_ITEM_NAME = "x-vercel-cache-item-name";
  return cache$1;
}
var dbConnections;
var hasRequiredDbConnections;
function requireDbConnections() {
  if (hasRequiredDbConnections) return dbConnections;
  hasRequiredDbConnections = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var db_connections_exports = {};
  __export(db_connections_exports, {
    attachDatabasePool: () => attachDatabasePool,
    experimental_attachDatabasePool: () => experimental_attachDatabasePool
  });
  dbConnections = __toCommonJS(db_connections_exports);
  var import_get_context = requireGetContext$1();
  const DEBUG = !!process.env.DEBUG;
  function getIdleTimeout(dbPool) {
    if ("options" in dbPool && dbPool.options) {
      if ("idleTimeoutMillis" in dbPool.options) {
        return typeof dbPool.options.idleTimeoutMillis === "number" ? dbPool.options.idleTimeoutMillis : 1e4;
      }
      if ("maxIdleTimeMS" in dbPool.options) {
        return typeof dbPool.options.maxIdleTimeMS === "number" ? dbPool.options.maxIdleTimeMS : 0;
      }
      if ("status" in dbPool) {
        return 5e3;
      }
      if ("connect" in dbPool && "execute" in dbPool) {
        return 3e4;
      }
    }
    if ("config" in dbPool && dbPool.config) {
      if ("connectionConfig" in dbPool.config && dbPool.config.connectionConfig) {
        return dbPool.config.connectionConfig.idleTimeout || 6e4;
      }
      if ("idleTimeout" in dbPool.config) {
        return typeof dbPool.config.idleTimeout === "number" ? dbPool.config.idleTimeout : 6e4;
      }
    }
    if ("poolTimeout" in dbPool) {
      return typeof dbPool.poolTimeout === "number" ? dbPool.poolTimeout : 6e4;
    }
    if ("idleTimeout" in dbPool) {
      return typeof dbPool.idleTimeout === "number" ? dbPool.idleTimeout : 0;
    }
    return 1e4;
  }
  let idleTimeout = null;
  let idleTimeoutResolve = () => {
  };
  const bootTime = Date.now();
  const maximumDuration = 15 * 60 * 1e3 - 1e3;
  function waitUntilIdleTimeout(dbPool) {
    if (!process.env.VERCEL_URL || // This is not set during builds where we don't need to wait for idle connections using the mechanism
    !process.env.VERCEL_REGION) {
      return;
    }
    if (idleTimeout) {
      clearTimeout(idleTimeout);
      idleTimeoutResolve();
    }
    const promise = new Promise((resolve2) => {
      idleTimeoutResolve = resolve2;
    });
    const waitTime = Math.min(
      getIdleTimeout(dbPool) + 100,
      maximumDuration - (Date.now() - bootTime)
    );
    idleTimeout = setTimeout(() => {
      idleTimeoutResolve?.();
      if (DEBUG) {
        console.log("Database pool idle timeout reached. Releasing connections.");
      }
    }, waitTime);
    const requestContext = (0, import_get_context.getContext)();
    if (requestContext?.waitUntil) {
      requestContext.waitUntil(promise);
    } else {
      console.warn("Pool release event triggered outside of request scope.");
    }
  }
  function attachDatabasePool(dbPool) {
    if (idleTimeout) {
      idleTimeoutResolve?.();
      clearTimeout(idleTimeout);
    }
    if ("on" in dbPool && dbPool.on && "options" in dbPool && "idleTimeoutMillis" in dbPool.options) {
      const pgPool = dbPool;
      pgPool.on("release", () => {
        if (DEBUG) {
          console.log("Client released from pool");
        }
        waitUntilIdleTimeout(dbPool);
      });
      return;
    } else if ("on" in dbPool && dbPool.on && "config" in dbPool && dbPool.config && "connectionConfig" in dbPool.config) {
      const mysqlPool = dbPool;
      mysqlPool.on("release", () => {
        if (DEBUG) {
          console.log("MySQL client released from pool");
        }
        waitUntilIdleTimeout(dbPool);
      });
      return;
    } else if ("on" in dbPool && dbPool.on && "config" in dbPool && dbPool.config && "idleTimeout" in dbPool.config) {
      const mysql2Pool = dbPool;
      mysql2Pool.on("release", () => {
        if (DEBUG) {
          console.log("MySQL2/MariaDB client released from pool");
        }
        waitUntilIdleTimeout(dbPool);
      });
      return;
    }
    if ("on" in dbPool && dbPool.on && "options" in dbPool && dbPool.options && "maxIdleTimeMS" in dbPool.options) {
      const mongoPool = dbPool;
      mongoPool.on("connectionCheckedOut", () => {
        if (DEBUG) {
          console.log("MongoDB connection checked out");
        }
        waitUntilIdleTimeout(dbPool);
      });
      return;
    }
    if ("on" in dbPool && dbPool.on && "options" in dbPool && dbPool.options && "socket" in dbPool.options) {
      const redisPool = dbPool;
      redisPool.on("end", () => {
        if (DEBUG) {
          console.log("Redis connection ended");
        }
        waitUntilIdleTimeout(dbPool);
      });
      return;
    }
    throw new Error("Unsupported database pool type");
  }
  const experimental_attachDatabasePool = attachDatabasePool;
  return dbConnections;
}
var purge = { exports: {} };
var types;
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var types_exports = {};
  types = __toCommonJS(types_exports);
  return types;
}
var hasRequiredPurge;
function requirePurge() {
  if (hasRequiredPurge) return purge.exports;
  hasRequiredPurge = 1;
  (function(module) {
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var purge_exports = {};
    __export(purge_exports, {
      dangerouslyDeleteByTag: () => dangerouslyDeleteByTag,
      invalidateByTag: () => invalidateByTag
    });
    module.exports = __toCommonJS(purge_exports);
    var import_get_context = requireGetContext$1();
    __reExport(purge_exports, requireTypes(), module.exports);
    const invalidateByTag = (tag) => {
      const api2 = (0, import_get_context.getContext)().purge;
      if (api2) {
        return api2.invalidateByTag(tag);
      }
      return Promise.resolve();
    };
    const dangerouslyDeleteByTag = (tag, options) => {
      const api2 = (0, import_get_context.getContext)().purge;
      if (api2) {
        return api2.dangerouslyDeleteByTag(tag, options);
      }
      return Promise.resolve();
    };
  })(purge);
  return purge.exports;
}
var functions;
var hasRequiredFunctions;
function requireFunctions() {
  if (hasRequiredFunctions) return functions;
  hasRequiredFunctions = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    attachDatabasePool: () => import_db_connections.attachDatabasePool,
    dangerouslyDeleteByTag: () => import_purge.dangerouslyDeleteByTag,
    experimental_attachDatabasePool: () => import_db_connections.experimental_attachDatabasePool,
    geolocation: () => import_headers.geolocation,
    getCache: () => import_cache.getCache,
    getEnv: () => import_get_env.getEnv,
    invalidateByTag: () => import_purge.invalidateByTag,
    ipAddress: () => import_headers.ipAddress,
    next: () => import_middleware.next,
    rewrite: () => import_middleware.rewrite,
    waitUntil: () => import_wait_until.waitUntil
  });
  functions = __toCommonJS(src_exports);
  var import_headers = requireHeaders$1();
  var import_get_env = requireGetEnv();
  var import_wait_until = requireWaitUntil();
  var import_middleware = requireMiddleware();
  var import_cache = requireCache$1();
  var import_db_connections = requireDbConnections();
  var import_purge = requirePurge();
  return functions;
}
var functionsExports = requireFunctions();
var ms$1;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms$1;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms$1 = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms$1;
}
var msExports = requireMs();
const ms = /* @__PURE__ */ getDefaultExportFromCjs(msExports);
function withResolvers() {
  let resolve2;
  let reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve2 = _resolve;
    reject = _reject;
  });
  return { promise, resolve: resolve2, reject };
}
function once$1(fn) {
  const result = {
    get value() {
      const value = fn();
      Object.defineProperty(result, "value", { value });
      return value;
    }
  };
  return result;
}
function parseDurationToDate(param) {
  if (typeof param === "string") {
    const durationMs = ms(param);
    if (typeof durationMs !== "number" || durationMs < 0) {
      throw new Error(`Invalid duration: "${param}". Expected a valid duration string like "1s", "1m", "1h", etc.`);
    }
    return new Date(Date.now() + durationMs);
  } else if (typeof param === "number") {
    if (param < 0 || !Number.isFinite(param)) {
      throw new Error(`Invalid duration: ${param}. Expected a non-negative finite number of milliseconds.`);
    }
    return new Date(Date.now() + param);
  } else if (param instanceof Date || param && typeof param === "object" && typeof param.getTime === "function") {
    return param instanceof Date ? param : new Date(param.getTime());
  } else {
    throw new Error(`Invalid duration parameter. Expected a duration string, number (milliseconds), or Date object.`);
  }
}
const BASE_URL = "https://useworkflow.dev/err";
function isError(value) {
  return typeof value === "object" && value !== null && "name" in value && "message" in value;
}
const ERROR_SLUGS = {
  WEBHOOK_INVALID_RESPOND_WITH_VALUE: "webhook-invalid-respond-with-value",
  WEBHOOK_RESPONSE_NOT_SENT: "webhook-response-not-sent",
  FETCH_IN_WORKFLOW_FUNCTION: "fetch-in-workflow"
};
class WorkflowError extends Error {
  cause;
  constructor(message, options) {
    const msgDocs = options?.slug ? `${message}

Learn more: ${BASE_URL}/${options.slug}` : message;
    super(msgDocs, { cause: options?.cause });
    this.cause = options?.cause;
    if (options?.cause instanceof Error) {
      this.stack = `${this.stack}
Caused by: ${options.cause.stack}`;
    }
  }
  static is(value) {
    return isError(value) && value.name === "WorkflowError";
  }
}
class WorkflowAPIError extends WorkflowError {
  status;
  code;
  url;
  constructor(message, options) {
    super(message, {
      cause: options?.cause
    });
    this.name = "WorkflowAPIError";
    this.status = options?.status;
    this.code = options?.code;
    this.url = options?.url;
  }
  static is(value) {
    return isError(value) && value.name === "WorkflowAPIError";
  }
}
class WorkflowRunFailedError extends WorkflowError {
  runId;
  constructor(runId, error) {
    const causeError = new Error(error.message);
    if (error.stack) {
      causeError.stack = error.stack;
    }
    if (error.code) {
      causeError.code = error.code;
    }
    super(`Workflow run "${runId}" failed: ${error.message}`, {
      cause: causeError
    });
    this.name = "WorkflowRunFailedError";
    this.runId = runId;
  }
  static is(value) {
    return isError(value) && value.name === "WorkflowRunFailedError";
  }
}
class WorkflowRunNotCompletedError extends WorkflowError {
  runId;
  status;
  constructor(runId, status) {
    super(`Workflow run "${runId}" has not completed`, {});
    this.name = "WorkflowRunNotCompletedError";
    this.runId = runId;
    this.status = status;
  }
  static is(value) {
    return isError(value) && value.name === "WorkflowRunNotCompletedError";
  }
}
class WorkflowRuntimeError extends WorkflowError {
  constructor(message, options) {
    super(message, {
      ...options
    });
    this.name = "WorkflowRuntimeError";
  }
  static is(value) {
    return isError(value) && value.name === "WorkflowRuntimeError";
  }
}
class WorkflowRunNotFoundError extends WorkflowError {
  runId;
  constructor(runId) {
    super(`Workflow run "${runId}" not found`, {});
    this.name = "WorkflowRunNotFoundError";
    this.runId = runId;
  }
  static is(value) {
    return isError(value) && value.name === "WorkflowRunNotFoundError";
  }
}
class WorkflowRunCancelledError extends WorkflowError {
  runId;
  constructor(runId) {
    super(`Workflow run "${runId}" cancelled`, {});
    this.name = "WorkflowRunCancelledError";
    this.runId = runId;
  }
  static is(value) {
    return isError(value) && value.name === "WorkflowRunCancelledError";
  }
}
class FatalError extends Error {
  fatal = true;
  constructor(message) {
    super(message);
    this.name = "FatalError";
  }
  static is(value) {
    return isError(value) && value.name === "FatalError";
  }
}
class RetryableError extends Error {
  /**
   * The Date when the step should be retried.
   */
  retryAfter;
  constructor(message, options = {}) {
    super(message);
    this.name = "RetryableError";
    if (options.retryAfter !== void 0) {
      this.retryAfter = parseDurationToDate(options.retryAfter);
    } else {
      this.retryAfter = new Date(Date.now() + 1e3);
    }
  }
  static is(value) {
    return isError(value) && value.name === "RetryableError";
  }
}
const execFileAsync = promisify(execFile);
function parsePort(value, radix = 10) {
  const port = parseInt(value, radix);
  if (!Number.isNaN(port) && port >= 0 && port <= 65535) {
    return port;
  }
  return void 0;
}
const join = (arr, sep) => arr.join(sep);
const PROC_ROOT = join(["", "proc"], "/");
async function getLinuxPort(pid) {
  const listenState = "0A";
  const tcpFiles = [`${PROC_ROOT}/net/tcp`, `${PROC_ROOT}/net/tcp6`];
  const socketInodes = [];
  const socketInodesSet = /* @__PURE__ */ new Set();
  const fdPath = `${PROC_ROOT}/${pid}/fd`;
  try {
    const fds = await readdir(fdPath);
    const sortedFds = fds.sort((a, b) => {
      const numA = Number.parseInt(a, 10);
      const numB = Number.parseInt(b, 10);
      return numA - numB;
    });
    const results = await Promise.allSettled(sortedFds.map(async (fd) => {
      const link = await readlink(`${fdPath}/${fd}`);
      const match = link.match(/^socket:\[(\d+)\]$/);
      return match?.[1] ?? null;
    }));
    for (const result of results) {
      if (result.status === "fulfilled" && result.value) {
        socketInodes.push(result.value);
        socketInodesSet.add(result.value);
      }
    }
  } catch {
    return void 0;
  }
  if (socketInodes.length === 0) {
    return void 0;
  }
  for (const tcpFile of tcpFiles) {
    try {
      const content = await readFile(tcpFile, "utf8");
      const lines = content.split("\n").slice(1);
      const inodeToPort = /* @__PURE__ */ new Map();
      for (const line of lines) {
        if (!line.trim())
          continue;
        const parts = line.trim().split(/\s+/);
        if (parts.length < 10)
          continue;
        const localAddr = parts[1];
        const state = parts[3];
        const inode = parts[9];
        if (!localAddr || state !== listenState || !inode)
          continue;
        if (!socketInodesSet.has(inode))
          continue;
        const colonIndex = localAddr.indexOf(":");
        if (colonIndex === -1)
          continue;
        const portHex = localAddr.slice(colonIndex + 1);
        if (!portHex)
          continue;
        const port = parsePort(portHex, 16);
        if (port !== void 0) {
          inodeToPort.set(inode, port);
        }
      }
      for (const inode of socketInodes) {
        const port = inodeToPort.get(inode);
        if (port !== void 0) {
          return port;
        }
      }
    } catch {
      continue;
    }
  }
  return void 0;
}
async function getPort() {
  const { pid, platform } = process;
  let port;
  try {
    switch (platform) {
      case "linux": {
        port = await getLinuxPort(pid);
        break;
      }
      case "darwin": {
        const { stdout } = await execFileAsync("lsof", [
          "-a",
          "-i",
          "-P",
          "-n",
          "-p",
          pid.toString()
        ]);
        const lines = stdout.split("\n");
        for (const line of lines) {
          if (line.includes("LISTEN")) {
            const parts = line.trim().split(/\s+/);
            const addr = parts[8];
            if (addr) {
              const colonIndex = addr.lastIndexOf(":");
              if (colonIndex !== -1) {
                port = parsePort(addr.slice(colonIndex + 1));
                if (port !== void 0) {
                  break;
                }
              }
            }
          }
        }
        break;
      }
      case "win32": {
        const { stdout } = await execFileAsync("cmd", [
          "/c",
          `netstat -ano | findstr ${pid} | findstr LISTENING`
        ]);
        const trimmedOutput = stdout.trim();
        if (trimmedOutput) {
          const lines = trimmedOutput.split("\n");
          for (const line of lines) {
            const match = line.trim().match(/^\s*TCP\s+(?:\[[\da-f:]+\]|[\d.]+):(\d+)\s+/i);
            if (match) {
              port = parsePort(match[1]);
              if (port !== void 0) {
                break;
              }
            }
          }
        }
        break;
      }
    }
  } catch (error) {
    if (process.env.NODE_ENV === "development") {
      console.debug("[getPort] Detection failed:", error);
    }
    return void 0;
  }
  return Number.isNaN(port) ? void 0 : port;
}
const EventTypeSchema = z$1.enum([
  "step_completed",
  "step_failed",
  "step_retrying",
  "step_started",
  "hook_created",
  "hook_received",
  "hook_disposed",
  "wait_created",
  "wait_completed",
  "workflow_completed",
  "workflow_failed",
  "workflow_started"
]);
const BaseEventSchema = z$1.object({
  eventType: EventTypeSchema,
  correlationId: z$1.string().optional()
});
const StepCompletedEventSchema = BaseEventSchema.extend({
  eventType: z$1.literal("step_completed"),
  correlationId: z$1.string(),
  eventData: z$1.object({
    result: z$1.any()
  })
});
const StepFailedEventSchema = BaseEventSchema.extend({
  eventType: z$1.literal("step_failed"),
  correlationId: z$1.string(),
  eventData: z$1.object({
    error: z$1.any(),
    stack: z$1.string().optional(),
    fatal: z$1.boolean().optional()
  })
});
const StepRetryingEventSchema = BaseEventSchema.extend({
  eventType: z$1.literal("step_retrying"),
  correlationId: z$1.string(),
  eventData: z$1.object({
    attempt: z$1.number().min(1)
  })
});
const StepStartedEventSchema = BaseEventSchema.extend({
  eventType: z$1.literal("step_started"),
  correlationId: z$1.string()
});
const HookCreatedEventSchema = BaseEventSchema.extend({
  eventType: z$1.literal("hook_created"),
  correlationId: z$1.string()
});
const HookReceivedEventSchema = BaseEventSchema.extend({
  eventType: z$1.literal("hook_received"),
  correlationId: z$1.string(),
  eventData: z$1.object({
    payload: z$1.any()
    // Serialized payload
  })
});
const HookDisposedEventSchema = BaseEventSchema.extend({
  eventType: z$1.literal("hook_disposed"),
  correlationId: z$1.string()
});
const WaitCreatedEventSchema = BaseEventSchema.extend({
  eventType: z$1.literal("wait_created"),
  correlationId: z$1.string(),
  eventData: z$1.object({
    resumeAt: z$1.coerce.date()
  })
});
const WaitCompletedEventSchema = BaseEventSchema.extend({
  eventType: z$1.literal("wait_completed"),
  correlationId: z$1.string()
});
const WorkflowCompletedEventSchema = BaseEventSchema.extend({
  eventType: z$1.literal("workflow_completed")
});
const WorkflowFailedEventSchema = BaseEventSchema.extend({
  eventType: z$1.literal("workflow_failed"),
  eventData: z$1.object({
    error: z$1.any()
  })
});
const WorkflowStartedEventSchema = BaseEventSchema.extend({
  eventType: z$1.literal("workflow_started")
});
const CreateEventSchema = z$1.discriminatedUnion("eventType", [
  StepCompletedEventSchema,
  StepFailedEventSchema,
  StepRetryingEventSchema,
  StepStartedEventSchema,
  HookCreatedEventSchema,
  HookReceivedEventSchema,
  HookDisposedEventSchema,
  WaitCreatedEventSchema,
  WaitCompletedEventSchema,
  WorkflowCompletedEventSchema,
  WorkflowFailedEventSchema,
  WorkflowStartedEventSchema
]);
const EventSchema = CreateEventSchema.and(z$1.object({
  runId: z$1.string(),
  eventId: z$1.string(),
  createdAt: z$1.coerce.date()
}));
const zodJsonSchema = z$1.lazy(() => {
  return z$1.union([
    z$1.string(),
    z$1.number(),
    z$1.boolean(),
    z$1.null(),
    z$1.array(zodJsonSchema),
    z$1.record(z$1.string(), zodJsonSchema)
  ]);
});
const PaginatedResponseSchema = (dataSchema) => z$1.object({
  data: z$1.array(dataSchema),
  cursor: z$1.string().nullable(),
  hasMore: z$1.boolean()
});
const StructuredErrorSchema = z$1.object({
  message: z$1.string(),
  stack: z$1.string().optional(),
  code: z$1.string().optional()
  // TODO: currently unused. make this an enum maybe
});
const HookSchema = z$1.object({
  runId: z$1.string(),
  hookId: z$1.string(),
  token: z$1.string(),
  ownerId: z$1.string(),
  projectId: z$1.string(),
  environment: z$1.string(),
  metadata: zodJsonSchema.optional(),
  createdAt: z$1.coerce.date()
});
const QueuePrefix = z$2.union([
  z$2.literal("__wkf_step_"),
  z$2.literal("__wkf_workflow_")
]);
const ValidQueueName = z$2.templateLiteral([QueuePrefix, z$2.string()]);
const MessageId = z$2.string().brand().describe("A stored queue message ID");
const TraceCarrierSchema = z$2.record(z$2.string(), z$2.string());
const WorkflowInvokePayloadSchema = z$2.object({
  runId: z$2.string(),
  traceCarrier: TraceCarrierSchema.optional(),
  requestedAt: z$2.coerce.date().optional()
});
const StepInvokePayloadSchema = z$2.object({
  workflowName: z$2.string(),
  workflowRunId: z$2.string(),
  workflowStartedAt: z$2.number(),
  stepId: z$2.string(),
  traceCarrier: TraceCarrierSchema.optional(),
  requestedAt: z$2.coerce.date().optional()
});
const QueuePayloadSchema = z$2.union([
  WorkflowInvokePayloadSchema,
  StepInvokePayloadSchema
]);
const WorkflowRunStatusSchema = z$1.enum([
  "pending",
  "running",
  "completed",
  "failed",
  "paused",
  "cancelled"
]);
const WorkflowRunBaseSchema = z$1.object({
  runId: z$1.string(),
  status: WorkflowRunStatusSchema,
  deploymentId: z$1.string(),
  workflowName: z$1.string(),
  executionContext: z$1.record(z$1.string(), z$1.any()).optional(),
  input: z$1.array(z$1.any()),
  output: z$1.any().optional(),
  error: StructuredErrorSchema.optional(),
  expiredAt: z$1.coerce.date().optional(),
  startedAt: z$1.coerce.date().optional(),
  completedAt: z$1.coerce.date().optional(),
  createdAt: z$1.coerce.date(),
  updatedAt: z$1.coerce.date()
});
const WorkflowRunSchema = z$1.discriminatedUnion("status", [
  // Non-final states
  WorkflowRunBaseSchema.extend({
    status: z$1.enum(["pending", "running", "paused"]),
    output: z$1.undefined(),
    error: z$1.undefined(),
    completedAt: z$1.undefined()
  }),
  // Cancelled state
  WorkflowRunBaseSchema.extend({
    status: z$1.literal("cancelled"),
    output: z$1.undefined(),
    error: z$1.undefined(),
    completedAt: z$1.coerce.date()
  }),
  // Completed state
  WorkflowRunBaseSchema.extend({
    status: z$1.literal("completed"),
    output: z$1.any(),
    error: z$1.undefined(),
    completedAt: z$1.coerce.date()
  }),
  // Failed state
  WorkflowRunBaseSchema.extend({
    status: z$1.literal("failed"),
    output: z$1.undefined(),
    error: StructuredErrorSchema,
    completedAt: z$1.coerce.date()
  })
]);
const StepStatusSchema = z$1.enum([
  "pending",
  "running",
  "completed",
  "failed",
  "cancelled"
]);
const StepSchema = z$1.object({
  runId: z$1.string(),
  stepId: z$1.string(),
  stepName: z$1.string(),
  status: StepStatusSchema,
  input: z$1.array(z$1.any()),
  output: z$1.any().optional(),
  error: StructuredErrorSchema.optional(),
  attempt: z$1.number(),
  startedAt: z$1.coerce.date().optional(),
  completedAt: z$1.coerce.date().optional(),
  createdAt: z$1.coerce.date(),
  updatedAt: z$1.coerce.date(),
  retryAfter: z$1.coerce.date().optional()
});
class WorkflowSuspension extends Error {
  steps;
  globalThis;
  stepCount;
  hookCount;
  waitCount;
  constructor(steps, global2) {
    const stepCount = steps.filter((s) => s.type === "step").length;
    const hookCount = steps.filter((s) => s.type === "hook").length;
    const waitCount = steps.filter((s) => s.type === "wait").length;
    const parts = [];
    if (stepCount > 0) {
      parts.push(`${stepCount} ${stepCount === 1 ? "step" : "steps"}`);
    }
    if (hookCount > 0) {
      parts.push(`${hookCount} ${hookCount === 1 ? "hook" : "hooks"}`);
    }
    if (waitCount > 0) {
      parts.push(`${waitCount} ${waitCount === 1 ? "wait" : "waits"}`);
    }
    const totalCount = stepCount + hookCount + waitCount;
    const hasOrHave = totalCount === 1 ? "has" : "have";
    let action2;
    if (stepCount > 0) {
      action2 = "run";
    } else if (hookCount > 0) {
      action2 = "created";
    } else if (waitCount > 0) {
      action2 = "created";
    } else {
      action2 = "received";
    }
    const description = parts.length > 0 ? `${parts.join(" and ")} ${hasOrHave} not been ${action2} yet` : "0 steps have not been run yet";
    super(description);
    this.name = "WorkflowSuspension";
    this.steps = steps;
    this.globalThis = global2;
    this.stepCount = stepCount;
    this.hookCount = hookCount;
    this.waitCount = waitCount;
  }
  static is(value) {
    return value instanceof WorkflowSuspension;
  }
}
function ENOTSUP() {
  throw new Error("Not supported in workflow functions");
}
var src = { exports: {} };
var browser = { exports: {} };
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports$1) {
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load;
    exports$1.useColors = useColors;
    exports$1.storage = localstorage();
    exports$1.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports$1.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports$1.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports$1.storage.setItem("debug", namespaces);
        } else {
          exports$1.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports$1.storage.getItem("debug") || exports$1.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon()(exports$1);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os2 = require$$0;
  const tty = require$$1;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let flagForceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    flagForceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    flagForceColor = 1;
  }
  function envForceColor() {
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        return 1;
      }
      if (env.FORCE_COLOR === "false") {
        return 0;
      }
      return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== void 0) {
      flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
      return 0;
    }
    if (sniffFlags) {
      if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
        return 3;
      }
      if (hasFlag2("color=256")) {
        return 2;
      }
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os2.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream, options = {}) {
    const level = supportsColor(stream, {
      streamIsTTY: stream && stream.isTTY,
      ...options
    });
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
    stderr: getSupportLevel({ isTTY: tty.isatty(2) })
  };
  return supportsColor_1;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node.exports;
  hasRequiredNode = 1;
  (function(module, exports$1) {
    const tty = require$$1;
    const util2 = require$$1$1;
    exports$1.init = init;
    exports$1.log = log;
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load;
    exports$1.useColors = useColors;
    exports$1.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports$1.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports$1.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports$1.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports$1.inspectOpts ? Boolean(exports$1.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports$1.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.formatWithOptions(exports$1.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports$1.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports$1.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon()(exports$1);
    const { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src.exports;
  hasRequiredSrc = 1;
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    src.exports = requireBrowser();
  } else {
    src.exports = requireNode();
  }
  return src.exports;
}
var srcExports = requireSrc();
const debug = /* @__PURE__ */ getDefaultExportFromCjs(srcExports);
async function serializeTraceCarrier() {
  const otel = await OtelApi.value;
  if (!otel)
    return {};
  const carrier = {};
  otel.propagation.inject(otel.context.active(), carrier);
  return carrier;
}
async function deserializeTraceCarrier(traceCarrier) {
  const otel = await OtelApi.value;
  if (!otel)
    return;
  return otel.propagation.extract(otel.context.active(), traceCarrier);
}
async function withTraceContext(traceCarrier, fn) {
  if (!traceCarrier) {
    return fn();
  }
  const otel = await OtelApi.value;
  if (!otel)
    return fn();
  const extractedContext = await deserializeTraceCarrier(traceCarrier);
  if (!extractedContext) {
    return fn();
  }
  return otel.context.with(extractedContext, async () => await fn());
}
const OtelApi = once$1(async () => {
  try {
    return await import("@opentelemetry/api");
  } catch {
    console.warn("OpenTelemetry not available, tracing will be disabled");
    return null;
  }
});
const Tracer = once$1(async () => {
  const api2 = await OtelApi.value;
  if (!api2)
    return null;
  return api2.trace.getTracer("workflow");
});
async function trace(spanName, ...args) {
  const [tracer, otel] = await Promise.all([Tracer.value, OtelApi.value]);
  const { fn, opts } = typeof args[0] === "function" ? { fn: args[0], opts: {} } : { fn: args[1], opts: args[0] };
  if (!fn)
    throw new Error("Function to trace must be provided");
  if (!tracer || !otel) {
    return await fn();
  }
  return tracer.startActiveSpan(spanName, opts, async (span) => {
    try {
      const result = await fn(span);
      span.setStatus({ code: otel.SpanStatusCode.OK });
      return result;
    } catch (e) {
      span.setStatus({
        code: otel.SpanStatusCode.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  });
}
async function getSpanContextForTraceCarrier(carrier) {
  const [deserialized, otel] = await Promise.all([
    deserializeTraceCarrier(carrier),
    OtelApi.value
  ]);
  if (!deserialized || !otel)
    return;
  return otel.trace.getSpanContext(deserialized);
}
async function getActiveSpan() {
  return await withOtel((otel) => otel.trace.getActiveSpan());
}
async function getSpanKind(field) {
  return withOtel((x) => x.SpanKind[field]);
}
async function withOtel(fn) {
  const otel = await OtelApi.value;
  if (!otel)
    return void 0;
  return await fn(otel);
}
function linkToCurrentContext() {
  return withOtel((otel) => {
    const context = otel.trace.getActiveSpan()?.spanContext();
    if (!context)
      return;
    return [{ context }];
  });
}
function createLogger(namespace) {
  const baseDebug = debug(`workflow:${namespace}`);
  const logger = (level) => {
    const levelDebug = baseDebug.extend(level);
    return (message, metadata) => {
      levelDebug(message, metadata);
      if (levelDebug.enabled) {
        getActiveSpan().then((span) => {
          span?.addEvent(`${level}.${namespace}`, { message, ...metadata });
        }).catch(() => {
        });
      }
    };
  };
  return {
    debug: logger("debug"),
    info: logger("info"),
    warn: logger("warn"),
    error: logger("error")
  };
}
const stepLogger = createLogger("step");
const runtimeLogger = createLogger("runtime");
const webhookLogger = createLogger("webhook");
const eventsLogger = createLogger("events");
createLogger("adapter");
function parseName(tag, name) {
  if (typeof name !== "string") {
    return null;
  }
  const [prefix, path2, ...functionNameParts] = name.split("//");
  if (prefix !== tag || !path2 || functionNameParts.length === 0) {
    return null;
  }
  let shortName = functionNameParts.at(-1) ?? "";
  const functionName = functionNameParts.join("//");
  const filename = path2.split("/").at(-1) ?? "";
  const fileNameWithoutExtension = filename.split(".").at(0) ?? "";
  if (["default", "__default"].includes(shortName) && fileNameWithoutExtension) {
    shortName = fileNameWithoutExtension;
  }
  return {
    shortName,
    path: path2,
    functionName
  };
}
function parseWorkflowName(name) {
  return parseName("workflow", name);
}
const contextStorage = /* @__PURE__ */ new AsyncLocalStorage();
const registeredSteps = /* @__PURE__ */ new Map();
function registerStepFunction(stepId, stepFn) {
  registeredSteps.set(stepId, stepFn);
}
function getStepFunction(stepId) {
  return registeredSteps.get(stepId);
}
function once(fn) {
  const result = {
    get value() {
      const value = fn();
      Object.defineProperty(result, "value", { value });
      return value;
    }
  };
  return result;
}
const getDataDirFromEnv = () => {
  return process.env.WORKFLOW_LOCAL_DATA_DIR || ".workflow-data";
};
const DEFAULT_RESOLVE_DATA_OPTION$1 = "all";
const getBaseUrlFromEnv = () => {
  return process.env.WORKFLOW_LOCAL_BASE_URL;
};
const config = once(() => {
  const dataDir = getDataDirFromEnv();
  const baseUrl = getBaseUrlFromEnv();
  return { dataDir, baseUrl };
});
async function resolveBaseUrl(config2) {
  if (config2.baseUrl) {
    return config2.baseUrl;
  }
  if (typeof config2.port === "number") {
    return `http://localhost:${config2.port}`;
  }
  if (process.env.PORT) {
    return `http://localhost:${process.env.PORT}`;
  }
  const detectedPort = await getPort();
  if (detectedPort) {
    return `http://localhost:${detectedPort}`;
  }
  throw new Error("Unable to resolve base URL for workflow queue.");
}
var MultipartParseError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "MultipartParseError";
  }
};
function createSearch(pattern) {
  const needle = new TextEncoder().encode(pattern);
  return (haystack, start2 = 0) => Buffer.prototype.indexOf.call(haystack, needle, start2);
}
function createPartialTailSearch(pattern) {
  const needle = new TextEncoder().encode(pattern);
  const byteIndexes = {};
  for (let i = 0; i < needle.length; ++i) {
    const byte = needle[i];
    if (byteIndexes[byte] === void 0) byteIndexes[byte] = [];
    byteIndexes[byte].push(i);
  }
  return function(haystack) {
    const haystackEnd = haystack.length - 1;
    if (haystack[haystackEnd] in byteIndexes) {
      const indexes = byteIndexes[haystack[haystackEnd]];
      for (let i = indexes.length - 1; i >= 0; --i) {
        for (let j = indexes[i], k = haystackEnd; j >= 0 && haystack[k] === needle[j]; --j, --k) {
          if (j === 0) return k;
        }
      }
    }
    return -1;
  };
}
function parseHeaders(headerBytes) {
  const headerText = new TextDecoder("iso-8859-1").decode(headerBytes);
  const lines = headerText.trim().split(/\r?\n/);
  const headerInit = [];
  for (const line of lines) {
    const colonIndex = line.indexOf(":");
    if (colonIndex > 0) {
      const name = line.slice(0, colonIndex).trim();
      const value = line.slice(colonIndex + 1).trim();
      headerInit.push([name, value]);
    }
  }
  return new Headers(headerInit);
}
function extractBoundary(contentType) {
  const boundaryMatch = contentType.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!boundaryMatch) {
    throw new MultipartParseError("No boundary found in Content-Type header");
  }
  return boundaryMatch[1] ?? boundaryMatch[2];
}
var AsyncMessageQueue = class {
  queue = [];
  waiters = [];
  finished = false;
  cancelled = false;
  error = null;
  /**
   * Producer: Enqueue a message for consumption
   */
  enqueue(message) {
    if (this.finished || this.cancelled) return;
    if (this.waiters.length > 0) {
      const waiter = this.waiters.shift();
      waiter.resolve(message);
    } else {
      this.queue.push(message);
    }
  }
  /**
   * Producer: Signal completion (with optional error)
   */
  finish(error) {
    if (this.finished) return;
    this.finished = true;
    this.error = error || null;
    while (this.waiters.length > 0) {
      const waiter = this.waiters.shift();
      if (error) {
        waiter.reject(error);
      } else {
        waiter.resolve(null);
      }
    }
  }
  /**
   * Consumer: Cancel the queue (stops accepting new messages and notifies waiters)
   */
  cancel() {
    if (this.cancelled || this.finished) return;
    this.cancelled = true;
    while (this.waiters.length > 0) {
      const waiter = this.waiters.shift();
      waiter.resolve(null);
    }
  }
  /**
   * Consumer: Dequeue next message (or null if finished/cancelled)
   */
  async dequeue() {
    if (this.queue.length > 0) {
      return this.queue.shift();
    }
    if (this.finished || this.cancelled) {
      if (this.error) throw this.error;
      return null;
    }
    return new Promise((resolve2, reject) => {
      this.waiters.push({ resolve: resolve2, reject });
    });
  }
  /**
   * Check if the queue is in a terminal state
   */
  get isTerminal() {
    return this.finished || this.cancelled;
  }
};
async function* parseMultipartStream(response2, options) {
  if (!response2.body) {
    throw new MultipartParseError("Response body is null");
  }
  const contentType = response2.headers.get("content-type");
  if (!contentType) {
    throw new MultipartParseError("Missing Content-Type header");
  }
  const boundary = extractBoundary(contentType);
  const parser = new StreamingMultipartParser(boundary, options);
  yield* parser.parseStream(response2.body);
}
var StreamingMultipartParser = class {
  boundary;
  findOpeningBoundary;
  openingBoundaryLength;
  findBoundary;
  findPartialTailBoundary;
  boundaryLength;
  findDoubleNewline;
  // Safety limits
  maxHeaderSize;
  maxBoundaryBuffer;
  state = 0;
  buffer = null;
  currentHeaders = new Headers();
  currentPayloadController = null;
  constructor(boundary, options = {}) {
    this.boundary = boundary;
    this.findOpeningBoundary = createSearch(`--${boundary}`);
    this.openingBoundaryLength = 2 + boundary.length;
    this.findBoundary = createSearch(`\r
--${boundary}`);
    this.findPartialTailBoundary = createPartialTailSearch(`\r
--${boundary}`);
    this.boundaryLength = 4 + boundary.length;
    this.findDoubleNewline = createSearch("\r\n\r\n");
    this.maxHeaderSize = options.maxHeaderSize ?? 65536;
    this.maxBoundaryBuffer = options.maxBoundaryBuffer ?? 8192;
  }
  async *parseStream(stream) {
    const reader = stream.getReader();
    const messageQueue = new AsyncMessageQueue();
    const producer = this.startProducer(reader, messageQueue);
    try {
      yield* this.consumeMessages(messageQueue);
    } finally {
      messageQueue.cancel();
      this.closeCurrentPayload();
      try {
        await reader.cancel();
      } catch (error) {
      }
      await producer;
    }
  }
  /**
   * Producer: Continuously read chunks and parse messages
   */
  async startProducer(reader, messageQueue) {
    try {
      while (!messageQueue.isTerminal) {
        let result;
        try {
          result = await reader.read();
        } catch (readError) {
          if (readError instanceof Error && (readError.name === "AbortError" || readError.constructor.name === "AbortError" || readError.name === "TimeoutError" || readError.constructor.name === "TimeoutError")) {
            break;
          }
          throw readError;
        }
        const { done, value } = result;
        if (done) {
          if (this.buffer !== null && this.buffer.length > 0) {
            const messages2 = this.write(new Uint8Array(0));
            for (const message of messages2) {
              if (messageQueue.isTerminal) break;
              messageQueue.enqueue(message);
            }
          }
          if (this.state !== 4) {
            if (this.state === 0) {
              throw new MultipartParseError(
                "Invalid multipart stream: missing initial boundary"
              );
            }
            throw new MultipartParseError("Unexpected end of stream");
          }
          break;
        }
        if (!(value instanceof Uint8Array)) {
          throw new MultipartParseError(
            `Invalid chunk type: expected Uint8Array, got ${typeof value}`
          );
        }
        const messages = this.write(value);
        for (const message of messages) {
          if (messageQueue.isTerminal) break;
          messageQueue.enqueue(message);
        }
      }
      if (!messageQueue.isTerminal) {
        messageQueue.finish();
      }
    } catch (error) {
      this.closeCurrentPayload(error);
      if (!messageQueue.isTerminal) {
        messageQueue.finish(error);
      }
    } finally {
      try {
        reader.releaseLock();
      } catch (error) {
      }
    }
  }
  /**
   * Consumer: Yield messages from the queue
   */
  async *consumeMessages(messageQueue) {
    while (true) {
      const message = await messageQueue.dequeue();
      if (message === null) {
        break;
      }
      yield message;
    }
  }
  /**
   * Process a chunk of data through the state machine and return any complete messages.
   *
   * Returns an array because a single chunk can contain multiple complete messages
   * when small messages with headers + body + boundary all fit in one network chunk.
   * All messages must be captured and queued to maintain proper message ordering.
   */
  write(chunk) {
    const newMessages = [];
    if (this.state === 4) {
      throw new MultipartParseError("Unexpected data after end of stream");
    }
    let index = 0;
    let chunkLength = chunk.length;
    if (this.buffer !== null) {
      const newSize = this.buffer.length + chunkLength;
      const maxAllowedSize = this.state === 2 ? this.maxHeaderSize : this.maxBoundaryBuffer;
      if (newSize > maxAllowedSize) {
        throw new MultipartParseError(
          `Buffer size limit exceeded: ${newSize} bytes > ${maxAllowedSize} bytes. This may indicate malformed multipart data with ${this.state === 2 ? "oversized headers" : "invalid boundaries"}.`
        );
      }
      const newChunk = new Uint8Array(newSize);
      newChunk.set(this.buffer, 0);
      newChunk.set(chunk, this.buffer.length);
      chunk = newChunk;
      chunkLength = chunk.length;
      this.buffer = null;
    }
    if (chunkLength === 0 && this.state === 0) {
      throw new MultipartParseError(
        "Invalid multipart stream: missing initial boundary"
      );
    }
    while (true) {
      if (this.state === 3) {
        if (chunkLength - index < this.boundaryLength) {
          const remainingData = chunk.subarray(index);
          if (remainingData.length > this.maxBoundaryBuffer) {
            throw new MultipartParseError(
              `Boundary buffer limit exceeded: ${remainingData.length} > ${this.maxBoundaryBuffer}`
            );
          }
          this.buffer = remainingData;
          break;
        }
        const boundaryIndex = this.findBoundary(chunk, index);
        if (boundaryIndex === -1) {
          const partialTailIndex = this.findPartialTailBoundary(chunk);
          if (partialTailIndex === -1) {
            this.writeBody(index === 0 ? chunk : chunk.subarray(index));
          } else {
            this.writeBody(chunk.subarray(index, partialTailIndex));
            const partialBoundary = chunk.subarray(partialTailIndex);
            if (partialBoundary.length > this.maxBoundaryBuffer) {
              throw new MultipartParseError(
                `Partial boundary too large: ${partialBoundary.length} > ${this.maxBoundaryBuffer}`
              );
            }
            this.buffer = partialBoundary;
          }
          break;
        }
        this.writeBody(chunk.subarray(index, boundaryIndex));
        this.finishMessage();
        index = boundaryIndex + this.boundaryLength;
        this.state = 1;
      }
      if (this.state === 1) {
        if (chunkLength - index < 2) {
          const remainingData = chunk.subarray(index);
          if (remainingData.length > this.maxBoundaryBuffer) {
            throw new MultipartParseError(
              `After-boundary buffer limit exceeded: ${remainingData.length} > ${this.maxBoundaryBuffer}`
            );
          }
          this.buffer = remainingData;
          break;
        }
        if (chunk[index] === 45 && chunk[index + 1] === 45) {
          this.state = 4;
          break;
        }
        if (chunk[index] === 13 && chunk[index + 1] === 10) {
          index += 2;
        } else if (chunk[index] === 10) {
          index += 1;
        } else {
          throw new MultipartParseError(
            `Invalid character after boundary: expected CRLF or LF, got 0x${chunk[index].toString(16)}`
          );
        }
        this.state = 2;
      }
      if (this.state === 2) {
        if (chunkLength - index < 4) {
          const remainingData = chunk.subarray(index);
          if (remainingData.length > this.maxHeaderSize) {
            throw new MultipartParseError(
              `Header buffer limit exceeded: ${remainingData.length} > ${this.maxHeaderSize}`
            );
          }
          this.buffer = remainingData;
          break;
        }
        let headerEndIndex = this.findDoubleNewline(chunk, index);
        let headerEndOffset = 4;
        if (headerEndIndex === -1) {
          const lfDoubleNewline = createSearch("\n\n");
          headerEndIndex = lfDoubleNewline(chunk, index);
          headerEndOffset = 2;
        }
        if (headerEndIndex === -1) {
          const headerData = chunk.subarray(index);
          if (headerData.length > this.maxHeaderSize) {
            throw new MultipartParseError(
              `Headers too large: ${headerData.length} > ${this.maxHeaderSize} bytes`
            );
          }
          this.buffer = headerData;
          break;
        }
        const headerBytes = chunk.subarray(index, headerEndIndex);
        this.currentHeaders = parseHeaders(headerBytes);
        const message = this.createStreamingMessage();
        newMessages.push(message);
        index = headerEndIndex + headerEndOffset;
        this.state = 3;
        continue;
      }
      if (this.state === 0) {
        if (chunkLength < this.openingBoundaryLength) {
          if (chunk.length > this.maxBoundaryBuffer) {
            throw new MultipartParseError(
              `Initial chunk too large for boundary detection: ${chunk.length} > ${this.maxBoundaryBuffer}`
            );
          }
          this.buffer = chunk;
          break;
        }
        const boundaryIndex = this.findOpeningBoundary(chunk);
        if (boundaryIndex !== 0) {
          throw new MultipartParseError(
            "Invalid multipart stream: missing initial boundary"
          );
        }
        index = this.openingBoundaryLength;
        this.state = 1;
      }
    }
    return newMessages;
  }
  createStreamingMessage() {
    const headers2 = new Headers(this.currentHeaders);
    const payload = new ReadableStream({
      start: (controller) => {
        this.currentPayloadController = controller;
      }
    });
    this.currentHeaders = new Headers();
    return {
      headers: headers2,
      payload
    };
  }
  writeBody(chunk) {
    if (this.currentPayloadController) {
      this.currentPayloadController.enqueue(chunk);
    }
  }
  finishMessage() {
    if (this.currentPayloadController) {
      this.currentPayloadController.close();
      this.currentPayloadController = null;
    }
  }
  /**
   * Close current payload controller if open (used during cleanup)
   * If an error is provided, forwards it to the payload consumer
   */
  closeCurrentPayload(error) {
    if (this.currentPayloadController) {
      try {
        if (error) {
          this.currentPayloadController.error(error);
        } else {
          this.currentPayloadController.close();
        }
      } catch (controllerError) {
      }
      this.currentPayloadController = null;
    }
  }
};
var getContext_1;
var hasRequiredGetContext;
function requireGetContext() {
  if (hasRequiredGetContext) return getContext_1;
  hasRequiredGetContext = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var get_context_exports = {};
  __export(get_context_exports, {
    SYMBOL_FOR_REQ_CONTEXT: () => SYMBOL_FOR_REQ_CONTEXT,
    getContext: () => getContext
  });
  getContext_1 = __toCommonJS(get_context_exports);
  const SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
  function getContext() {
    const fromSymbol = globalThis;
    return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
  }
  return getContext_1;
}
var tokenError;
var hasRequiredTokenError;
function requireTokenError() {
  if (hasRequiredTokenError) return tokenError;
  hasRequiredTokenError = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var token_error_exports = {};
  __export(token_error_exports, {
    VercelOidcTokenError: () => VercelOidcTokenError
  });
  tokenError = __toCommonJS(token_error_exports);
  class VercelOidcTokenError extends Error {
    constructor(message, cause) {
      super(message);
      this.name = "VercelOidcTokenError";
      this.cause = cause;
    }
    toString() {
      if (this.cause) {
        return `${this.name}: ${this.message}: ${this.cause}`;
      }
      return `${this.name}: ${this.message}`;
    }
  }
  return tokenError;
}
var getVercelOidcToken_1;
var hasRequiredGetVercelOidcToken;
function requireGetVercelOidcToken() {
  if (hasRequiredGetVercelOidcToken) return getVercelOidcToken_1;
  hasRequiredGetVercelOidcToken = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var get_vercel_oidc_token_exports = {};
  __export(get_vercel_oidc_token_exports, {
    getVercelOidcToken: () => getVercelOidcToken,
    getVercelOidcTokenSync: () => getVercelOidcTokenSync
  });
  getVercelOidcToken_1 = __toCommonJS(get_vercel_oidc_token_exports);
  var import_get_context = requireGetContext();
  var import_token_error = requireTokenError();
  async function getVercelOidcToken() {
    let token = "";
    let err;
    try {
      token = getVercelOidcTokenSync();
    } catch (error) {
      err = error;
    }
    try {
      const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
        await import("./token-util-BT_yJ3Kd.js").then((n) => n.t),
        await import("./token-BVQbJEMB.js").then((n) => n.t)
      ]);
      if (!token || isExpired(getTokenPayload(token))) {
        await refreshToken();
        token = getVercelOidcTokenSync();
      }
    } catch (error) {
      if (err?.message && error instanceof Error) {
        error.message = `${err.message}
${error.message}`;
      }
      throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, error);
    }
    return token;
  }
  function getVercelOidcTokenSync() {
    const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
    if (!token) {
      throw new Error(
        `The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`
      );
    }
    return token;
  }
  return getVercelOidcToken_1;
}
var dist;
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    getContext: () => import_get_context.getContext,
    getVercelOidcToken: () => import_get_vercel_oidc_token.getVercelOidcToken,
    getVercelOidcTokenSync: () => import_get_vercel_oidc_token.getVercelOidcTokenSync
  });
  dist = __toCommonJS(src_exports);
  var import_get_vercel_oidc_token = requireGetVercelOidcToken();
  var import_get_context = requireGetContext();
  return dist;
}
var distExports = requireDist();
async function streamToBuffer(stream) {
  let totalLength = 0;
  const reader = stream.getReader();
  const chunks = [];
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
      totalLength += value.length;
    }
  } finally {
    reader.releaseLock();
  }
  return Buffer.concat(chunks, totalLength);
}
var JsonTransport = class {
  contentType = "application/json";
  replacer;
  reviver;
  constructor(options = {}) {
    this.replacer = options.replacer;
    this.reviver = options.reviver;
  }
  serialize(value) {
    return Buffer.from(JSON.stringify(value, this.replacer), "utf8");
  }
  async deserialize(stream) {
    const buffer = await streamToBuffer(stream);
    return JSON.parse(buffer.toString("utf8"), this.reviver);
  }
};
var MessageNotFoundError = class extends Error {
  constructor(messageId) {
    super(`Message ${messageId} not found`);
    this.name = "MessageNotFoundError";
  }
};
var MessageNotAvailableError = class extends Error {
  constructor(messageId, reason) {
    super(
      `Message ${messageId} not available for processing${reason ? `: ${reason}` : ""}`
    );
    this.name = "MessageNotAvailableError";
  }
};
var MessageCorruptedError = class extends Error {
  constructor(messageId, reason) {
    super(`Message ${messageId} is corrupted: ${reason}`);
    this.name = "MessageCorruptedError";
  }
};
var QueueEmptyError = class extends Error {
  constructor(queueName, consumerGroup) {
    super(
      `No messages available in queue "${queueName}" for consumer group "${consumerGroup}"`
    );
    this.name = "QueueEmptyError";
  }
};
var MessageLockedError = class extends Error {
  retryAfter;
  constructor(messageId, retryAfter) {
    const retryMessage = retryAfter ? ` Retry after ${retryAfter} seconds.` : " Try again later.";
    super(`Message ${messageId} is temporarily locked.${retryMessage}`);
    this.name = "MessageLockedError";
    this.retryAfter = retryAfter;
  }
};
var UnauthorizedError = class extends Error {
  constructor(message = "Missing or invalid authentication token") {
    super(message);
    this.name = "UnauthorizedError";
  }
};
var ForbiddenError = class extends Error {
  constructor(message = "Queue environment doesn't match token environment") {
    super(message);
    this.name = "ForbiddenError";
  }
};
var BadRequestError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "BadRequestError";
  }
};
var InternalServerError = class extends Error {
  constructor(message = "Unexpected server error") {
    super(message);
    this.name = "InternalServerError";
  }
};
var InvalidLimitError = class extends Error {
  constructor(limit, min = 1, max = 10) {
    super(`Invalid limit: ${limit}. Limit must be between ${min} and ${max}.`);
    this.name = "InvalidLimitError";
  }
};
function isDebugEnabled() {
  return process.env.VERCEL_QUEUE_DEBUG === "1" || process.env.VERCEL_QUEUE_DEBUG === "true";
}
async function consumeStream(stream) {
  const reader = stream.getReader();
  try {
    while (true) {
      const { done } = await reader.read();
      if (done) break;
    }
  } finally {
    reader.releaseLock();
  }
}
function parseRetryAfter(headers2) {
  const retryAfterHeader = headers2.get("Retry-After");
  if (retryAfterHeader) {
    const parsed = parseInt(retryAfterHeader, 10);
    return Number.isNaN(parsed) ? void 0 : parsed;
  }
  return void 0;
}
function throwCommonHttpError(status, statusText, errorText, operation, badRequestDefault = "Invalid parameters") {
  if (status === 400) {
    throw new BadRequestError(errorText || badRequestDefault);
  }
  if (status === 401) {
    throw new UnauthorizedError(errorText || void 0);
  }
  if (status === 403) {
    throw new ForbiddenError(errorText || void 0);
  }
  if (status >= 500) {
    throw new InternalServerError(
      errorText || `Server error: ${status} ${statusText}`
    );
  }
  throw new Error(`Failed to ${operation}: ${status} ${statusText}`);
}
function parseQueueHeaders(headers2) {
  const messageId = headers2.get("Vqs-Message-Id");
  const deliveryCountStr = headers2.get("Vqs-Delivery-Count") || "0";
  const timestamp = headers2.get("Vqs-Timestamp");
  const contentType = headers2.get("Content-Type") || "application/octet-stream";
  const ticket = headers2.get("Vqs-Ticket");
  if (!messageId || !timestamp || !ticket) {
    return null;
  }
  const deliveryCount = parseInt(deliveryCountStr, 10);
  if (Number.isNaN(deliveryCount)) {
    return null;
  }
  return {
    messageId,
    deliveryCount,
    createdAt: new Date(timestamp),
    contentType,
    ticket
  };
}
var QueueClient = class {
  baseUrl;
  basePath;
  customHeaders;
  providedToken;
  /**
   * Create a new Vercel Queue Service client
   * @param options QueueClient configuration options
   */
  constructor(options = {}) {
    this.baseUrl = options.baseUrl || process.env.VERCEL_QUEUE_BASE_URL || "https://vercel-queue.com";
    this.basePath = options.basePath || process.env.VERCEL_QUEUE_BASE_PATH || "/api/v2/messages";
    this.customHeaders = options.headers || {};
    this.providedToken = options.token;
  }
  async getToken() {
    if (this.providedToken) {
      return this.providedToken;
    }
    const token = await distExports.getVercelOidcToken();
    if (!token) {
      throw new Error(
        "Failed to get OIDC token from Vercel Functions. Make sure you are running in a Vercel Function environment, or provide a token explicitly.\n\nTo set up your environment:\n1. Link your project: 'vercel link'\n2. Pull environment variables: 'vercel env pull'\n3. Run with environment: 'dotenv -e .env.local -- your-command'"
      );
    }
    return token;
  }
  /**
   * Internal fetch wrapper that automatically handles debug logging
   * when VERCEL_QUEUE_DEBUG is enabled
   */
  async fetch(url, init) {
    const method = init.method || "GET";
    if (isDebugEnabled()) {
      const logData = {
        method,
        url,
        headers: init.headers
      };
      const body2 = init.body;
      if (body2 !== void 0 && body2 !== null) {
        if (body2 instanceof ArrayBuffer) {
          logData.bodySize = body2.byteLength;
        } else if (body2 instanceof Uint8Array) {
          logData.bodySize = body2.byteLength;
        } else if (typeof body2 === "string") {
          logData.bodySize = body2.length;
        } else {
          logData.bodyType = typeof body2;
        }
      }
      console.debug("[VQS Debug] Request:", JSON.stringify(logData, null, 2));
    }
    const response2 = await fetch(url, init);
    if (isDebugEnabled()) {
      const logData = {
        method,
        url,
        status: response2.status,
        statusText: response2.statusText,
        headers: response2.headers
      };
      console.debug("[VQS Debug] Response:", JSON.stringify(logData, null, 2));
    }
    return response2;
  }
  /**
   * Send a message to a queue
   * @param options Send message options
   * @param transport Serializer/deserializer for the payload
   * @returns Promise with the message ID
   * @throws {BadRequestError} When request parameters are invalid
   * @throws {UnauthorizedError} When authentication fails
   * @throws {ForbiddenError} When access is denied (environment mismatch)
   * @throws {InternalServerError} When server encounters an error
   */
  async sendMessage(options, transport) {
    const { queueName, payload, idempotencyKey, retentionSeconds } = options;
    const headers2 = new Headers({
      Authorization: `Bearer ${await this.getToken()}`,
      "Vqs-Queue-Name": queueName,
      "Content-Type": transport.contentType,
      ...this.customHeaders
    });
    const deploymentId = options.deploymentId || process.env.VERCEL_DEPLOYMENT_ID;
    if (deploymentId) {
      headers2.set("Vqs-Deployment-Id", deploymentId);
    }
    if (idempotencyKey) {
      headers2.set("Vqs-Idempotency-Key", idempotencyKey);
    }
    if (retentionSeconds !== void 0) {
      headers2.set("Vqs-Retention-Seconds", retentionSeconds.toString());
    }
    const body2 = transport.serialize(payload);
    const response2 = await this.fetch(`${this.baseUrl}${this.basePath}`, {
      method: "POST",
      body: body2,
      headers: headers2
    });
    if (!response2.ok) {
      const errorText = await response2.text();
      if (response2.status === 409) {
        throw new Error("Duplicate idempotency key detected");
      }
      throwCommonHttpError(
        response2.status,
        response2.statusText,
        errorText,
        "send message"
      );
    }
    const responseData = await response2.json();
    return responseData;
  }
  /**
   * Receive messages from a queue
   * @param options Receive messages options
   * @param transport Serializer/deserializer for the payload
   * @returns AsyncGenerator that yields messages as they arrive
   * @throws {InvalidLimitError} When limit parameter is not between 1 and 10
   * @throws {QueueEmptyError} When no messages are available (204)
   * @throws {MessageLockedError} When messages are temporarily locked (423)
   * @throws {BadRequestError} When request parameters are invalid
   * @throws {UnauthorizedError} When authentication fails
   * @throws {ForbiddenError} When access is denied (environment mismatch)
   * @throws {InternalServerError} When server encounters an error
   */
  async *receiveMessages(options, transport) {
    const { queueName, consumerGroup, visibilityTimeoutSeconds, limit } = options;
    if (limit !== void 0 && (limit < 1 || limit > 10)) {
      throw new InvalidLimitError(limit);
    }
    const headers2 = new Headers({
      Authorization: `Bearer ${await this.getToken()}`,
      "Vqs-Queue-Name": queueName,
      "Vqs-Consumer-Group": consumerGroup,
      Accept: "multipart/mixed",
      ...this.customHeaders
    });
    if (visibilityTimeoutSeconds !== void 0) {
      headers2.set(
        "Vqs-Visibility-Timeout",
        visibilityTimeoutSeconds.toString()
      );
    }
    if (limit !== void 0) {
      headers2.set("Vqs-Limit", limit.toString());
    }
    const response2 = await this.fetch(`${this.baseUrl}${this.basePath}`, {
      method: "GET",
      headers: headers2
    });
    if (response2.status === 204) {
      throw new QueueEmptyError(queueName, consumerGroup);
    }
    if (!response2.ok) {
      const errorText = await response2.text();
      if (response2.status === 423) {
        throw new MessageLockedError(
          "next message",
          parseRetryAfter(response2.headers)
        );
      }
      throwCommonHttpError(
        response2.status,
        response2.statusText,
        errorText,
        "receive messages"
      );
    }
    for await (const multipartMessage of parseMultipartStream(response2)) {
      try {
        const parsedHeaders = parseQueueHeaders(multipartMessage.headers);
        if (!parsedHeaders) {
          console.warn("Missing required queue headers in multipart part");
          await consumeStream(multipartMessage.payload);
          continue;
        }
        const deserializedPayload = await transport.deserialize(
          multipartMessage.payload
        );
        const message = {
          ...parsedHeaders,
          payload: deserializedPayload
        };
        yield message;
      } catch (error) {
        console.warn("Failed to process multipart message:", error);
        await consumeStream(multipartMessage.payload);
      }
    }
  }
  async receiveMessageById(options, transport) {
    const {
      queueName,
      consumerGroup,
      messageId,
      visibilityTimeoutSeconds,
      skipPayload
    } = options;
    const headers2 = new Headers({
      Authorization: `Bearer ${await this.getToken()}`,
      "Vqs-Queue-Name": queueName,
      "Vqs-Consumer-Group": consumerGroup,
      Accept: "multipart/mixed",
      ...this.customHeaders
    });
    if (visibilityTimeoutSeconds !== void 0) {
      headers2.set(
        "Vqs-Visibility-Timeout",
        visibilityTimeoutSeconds.toString()
      );
    }
    if (skipPayload) {
      headers2.set("Vqs-Skip-Payload", "1");
    }
    const response2 = await this.fetch(
      `${this.baseUrl}${this.basePath}/${encodeURIComponent(messageId)}`,
      {
        method: "GET",
        headers: headers2
      }
    );
    if (!response2.ok) {
      const errorText = await response2.text();
      if (response2.status === 404) {
        throw new MessageNotFoundError(messageId);
      }
      if (response2.status === 409) {
        throw new MessageNotAvailableError(messageId);
      }
      if (response2.status === 423) {
        throw new MessageLockedError(
          messageId,
          parseRetryAfter(response2.headers)
        );
      }
      throwCommonHttpError(
        response2.status,
        response2.statusText,
        errorText,
        "receive message by ID"
      );
    }
    if (skipPayload && response2.status === 204) {
      const parsedHeaders = parseQueueHeaders(response2.headers);
      if (!parsedHeaders) {
        throw new MessageCorruptedError(
          messageId,
          "Missing required queue headers in 204 response"
        );
      }
      const message = {
        ...parsedHeaders,
        payload: void 0
      };
      return { message };
    }
    if (!transport) {
      throw new Error("Transport is required when skipPayload is not true");
    }
    try {
      for await (const multipartMessage of parseMultipartStream(response2)) {
        try {
          const parsedHeaders = parseQueueHeaders(multipartMessage.headers);
          if (!parsedHeaders) {
            console.warn("Missing required queue headers in multipart part");
            await consumeStream(multipartMessage.payload);
            continue;
          }
          const deserializedPayload = await transport.deserialize(
            multipartMessage.payload
          );
          const message = {
            ...parsedHeaders,
            payload: deserializedPayload
          };
          return { message };
        } catch (error) {
          console.warn("Failed to deserialize message by ID:", error);
          await consumeStream(multipartMessage.payload);
          throw new MessageCorruptedError(
            messageId,
            `Failed to deserialize payload: ${error}`
          );
        }
      }
    } catch (error) {
      if (error instanceof MessageCorruptedError) {
        throw error;
      }
      throw new MessageCorruptedError(
        messageId,
        `Failed to parse multipart response: ${error}`
      );
    }
    throw new MessageNotFoundError(messageId);
  }
  /**
   * Delete a message (acknowledge processing)
   * @param options Delete message options
   * @returns Promise with delete status
   * @throws {MessageNotFoundError} When the message doesn't exist (404)
   * @throws {MessageNotAvailableError} When message can't be deleted (409)
   * @throws {BadRequestError} When ticket is missing or invalid (400)
   * @throws {UnauthorizedError} When authentication fails
   * @throws {ForbiddenError} When access is denied (environment mismatch)
   * @throws {InternalServerError} When server encounters an error
   */
  async deleteMessage(options) {
    const { queueName, consumerGroup, messageId, ticket } = options;
    const response2 = await this.fetch(
      `${this.baseUrl}${this.basePath}/${encodeURIComponent(messageId)}`,
      {
        method: "DELETE",
        headers: new Headers({
          Authorization: `Bearer ${await this.getToken()}`,
          "Vqs-Queue-Name": queueName,
          "Vqs-Consumer-Group": consumerGroup,
          "Vqs-Ticket": ticket,
          ...this.customHeaders
        })
      }
    );
    if (!response2.ok) {
      const errorText = await response2.text();
      if (response2.status === 404) {
        throw new MessageNotFoundError(messageId);
      }
      if (response2.status === 409) {
        throw new MessageNotAvailableError(
          messageId,
          errorText || "Invalid ticket, message not in correct state, or already processed"
        );
      }
      throwCommonHttpError(
        response2.status,
        response2.statusText,
        errorText,
        "delete message",
        "Missing or invalid ticket"
      );
    }
    return { deleted: true };
  }
  /**
   * Change the visibility timeout of a message
   * @param options Change visibility options
   * @returns Promise with update status
   * @throws {MessageNotFoundError} When the message doesn't exist (404)
   * @throws {MessageNotAvailableError} When message can't be updated (409)
   * @throws {BadRequestError} When ticket is missing or visibility timeout invalid (400)
   * @throws {UnauthorizedError} When authentication fails
   * @throws {ForbiddenError} When access is denied (environment mismatch)
   * @throws {InternalServerError} When server encounters an error
   */
  async changeVisibility(options) {
    const {
      queueName,
      consumerGroup,
      messageId,
      ticket,
      visibilityTimeoutSeconds
    } = options;
    const response2 = await this.fetch(
      `${this.baseUrl}${this.basePath}/${encodeURIComponent(messageId)}`,
      {
        method: "PATCH",
        headers: new Headers({
          Authorization: `Bearer ${await this.getToken()}`,
          "Vqs-Queue-Name": queueName,
          "Vqs-Consumer-Group": consumerGroup,
          "Vqs-Ticket": ticket,
          "Vqs-Visibility-Timeout": visibilityTimeoutSeconds.toString(),
          ...this.customHeaders
        })
      }
    );
    if (!response2.ok) {
      const errorText = await response2.text();
      if (response2.status === 404) {
        throw new MessageNotFoundError(messageId);
      }
      if (response2.status === 409) {
        throw new MessageNotAvailableError(
          messageId,
          errorText || "Invalid ticket, message not in correct state, or already processed"
        );
      }
      throwCommonHttpError(
        response2.status,
        response2.statusText,
        errorText,
        "change visibility",
        "Missing ticket or invalid visibility timeout"
      );
    }
    return { updated: true };
  }
};
var GLOBAL_KEY = Symbol.for("@vercel/queue.devHandlers");
function getDevHandlerState() {
  const g = globalThis;
  if (!g[GLOBAL_KEY]) {
    g[GLOBAL_KEY] = {
      devRouteHandlers: /* @__PURE__ */ new Map(),
      wildcardRouteHandlers: /* @__PURE__ */ new Map()
    };
  }
  return g[GLOBAL_KEY];
}
var { devRouteHandlers, wildcardRouteHandlers } = getDevHandlerState();
function cleanupDeadRefs(key, refs) {
  const aliveRefs = refs.filter((ref) => ref.deref() !== void 0);
  if (aliveRefs.length === 0) {
    wildcardRouteHandlers.delete(key);
  } else if (aliveRefs.length < refs.length) {
    wildcardRouteHandlers.set(key, aliveRefs);
  }
}
function isDevMode() {
  return process.env.NODE_ENV === "development";
}
function registerDevRouteHandler(routeHandler, handlers) {
  for (const topicName in handlers) {
    for (const consumerGroup in handlers[topicName]) {
      const key = `${topicName}:${consumerGroup}`;
      if (topicName.includes("*")) {
        const existing = wildcardRouteHandlers.get(key) || [];
        cleanupDeadRefs(key, existing);
        const cleanedRefs = wildcardRouteHandlers.get(key) || [];
        const weakRef = new WeakRef(routeHandler);
        cleanedRefs.push(weakRef);
        wildcardRouteHandlers.set(key, cleanedRefs);
      } else {
        devRouteHandlers.set(key, {
          routeHandler,
          topicPattern: topicName
        });
      }
    }
  }
}
function findRouteHandlersForTopic(topicName) {
  const handlersMap = /* @__PURE__ */ new Map();
  for (const [
    key,
    { routeHandler, topicPattern }
  ] of devRouteHandlers.entries()) {
    const [_, consumerGroup] = key.split(":");
    if (topicPattern === topicName) {
      if (!handlersMap.has(routeHandler)) {
        handlersMap.set(routeHandler, /* @__PURE__ */ new Set());
      }
      handlersMap.get(routeHandler).add(consumerGroup);
    }
  }
  for (const [key, refs] of wildcardRouteHandlers.entries()) {
    const [pattern, consumerGroup] = key.split(":");
    if (matchesWildcardPattern(topicName, pattern)) {
      cleanupDeadRefs(key, refs);
      const cleanedRefs = wildcardRouteHandlers.get(key) || [];
      for (const ref of cleanedRefs) {
        const routeHandler = ref.deref();
        if (routeHandler) {
          if (!handlersMap.has(routeHandler)) {
            handlersMap.set(routeHandler, /* @__PURE__ */ new Set());
          }
          handlersMap.get(routeHandler).add(consumerGroup);
        }
      }
    }
  }
  return handlersMap;
}
function createMockCloudEventRequest(topicName, consumerGroup, messageId) {
  const cloudEvent = {
    type: "com.vercel.queue.v1beta",
    source: `/topic/${topicName}/consumer/${consumerGroup}`,
    id: messageId,
    datacontenttype: "application/json",
    data: {
      messageId,
      queueName: topicName,
      consumerGroup
    },
    time: (/* @__PURE__ */ new Date()).toISOString(),
    specversion: "1.0"
  };
  return new Request("https://localhost/api/queue/callback", {
    method: "POST",
    headers: {
      "Content-Type": "application/cloudevents+json"
    },
    body: JSON.stringify(cloudEvent)
  });
}
var DEV_CALLBACK_DELAY = 1e3;
function scheduleDevTimeout(topicName, messageId, timeoutSeconds) {
  console.log(
    `[Dev Mode] Message ${messageId} timed out for ${timeoutSeconds}s, will re-trigger`
  );
  setTimeout(
    () => {
      console.log(
        `[Dev Mode] Re-triggering callback for timed-out message ${messageId}`
      );
      triggerDevCallbacks(topicName, messageId);
    },
    timeoutSeconds * 1e3 + DEV_CALLBACK_DELAY
  );
}
function triggerDevCallbacks(topicName, messageId) {
  const handlersMap = findRouteHandlersForTopic(topicName);
  if (handlersMap.size === 0) {
    return;
  }
  const consumerGroups = Array.from(
    new Set(
      Array.from(handlersMap.values()).flatMap((groups) => Array.from(groups))
    )
  );
  console.log(
    `[Dev Mode] Triggering local callbacks for topic "${topicName}" â consumers: ${consumerGroups.join(", ")}`
  );
  setTimeout(async () => {
    for (const [routeHandler, consumerGroups2] of handlersMap.entries()) {
      for (const consumerGroup of consumerGroups2) {
        try {
          const request2 = createMockCloudEventRequest(
            topicName,
            consumerGroup,
            messageId
          );
          const response2 = await routeHandler(request2);
          if (response2.ok) {
            try {
              const responseData = await response2.json();
              if (responseData.status === "success") {
                console.log(
                  `[Dev Mode] Message processed for ${topicName}/${consumerGroup}`
                );
              }
            } catch (jsonError) {
              console.error(
                `[Dev Mode] Failed to parse success response for ${topicName}/${consumerGroup}:`,
                jsonError
              );
            }
          } else {
            try {
              const errorData = await response2.json();
              console.error(
                `[Dev Mode] Failed to process message for ${topicName}/${consumerGroup}:`,
                errorData.error || response2.statusText
              );
            } catch (jsonError) {
              console.error(
                `[Dev Mode] Failed to process message for ${topicName}/${consumerGroup}:`,
                response2.statusText
              );
            }
          }
        } catch (error) {
          console.error(
            `[Dev Mode] Error triggering callback for ${topicName}/${consumerGroup}:`,
            error
          );
        }
      }
    }
  }, DEV_CALLBACK_DELAY);
}
function clearDevHandlers() {
  devRouteHandlers.clear();
  wildcardRouteHandlers.clear();
}
if (process.env.NODE_ENV === "test" || process.env.VITEST) {
  globalThis.__clearDevHandlers = clearDevHandlers;
}
var ConsumerGroup = class {
  client;
  topicName;
  consumerGroupName;
  visibilityTimeout;
  refreshInterval;
  transport;
  /**
   * Create a new ConsumerGroup instance
   * @param client QueueClient instance to use for API calls
   * @param topicName Name of the topic to consume from
   * @param consumerGroupName Name of the consumer group
   * @param options Optional configuration
   */
  constructor(client2, topicName, consumerGroupName, options = {}) {
    this.client = client2;
    this.topicName = topicName;
    this.consumerGroupName = consumerGroupName;
    this.visibilityTimeout = options.visibilityTimeoutSeconds || 30;
    this.refreshInterval = options.refreshInterval || 10;
    this.transport = options.transport || new JsonTransport();
  }
  /**
   * Starts a background loop that periodically extends the visibility timeout for a message.
   * This prevents the message from becoming visible to other consumers while it's being processed.
   *
   * The extension loop runs every `refreshInterval` seconds and updates the message's
   * visibility timeout to `visibilityTimeout` seconds from the current time.
   *
   * @param messageId - The unique identifier of the message to extend visibility for
   * @param ticket - The receipt ticket that proves ownership of the message
   * @returns A function that when called will stop the extension loop
   *
   * @remarks
   * - The first extension attempt occurs after `refreshInterval` seconds, not immediately
   * - If an extension fails, the loop terminates with an error logged to console
   * - The returned stop function is idempotent - calling it multiple times is safe
   * - By default, the stop function returns immediately without waiting for in-flight
   * - Pass `true` to the stop function to wait for any in-flight extension to complete
   */
  startVisibilityExtension(messageId, ticket) {
    let isRunning = true;
    let resolveLifecycle;
    let timeoutId = null;
    const lifecyclePromise = new Promise((resolve2) => {
      resolveLifecycle = resolve2;
    });
    const extend = async () => {
      if (!isRunning) {
        resolveLifecycle();
        return;
      }
      try {
        await this.client.changeVisibility({
          queueName: this.topicName,
          consumerGroup: this.consumerGroupName,
          messageId,
          ticket,
          visibilityTimeoutSeconds: this.visibilityTimeout
        });
        if (isRunning) {
          timeoutId = setTimeout(() => extend(), this.refreshInterval * 1e3);
        } else {
          resolveLifecycle();
        }
      } catch (error) {
        console.error(
          `Failed to extend visibility for message ${messageId}:`,
          error
        );
        resolveLifecycle();
      }
    };
    timeoutId = setTimeout(() => extend(), this.refreshInterval * 1e3);
    return async (waitForCompletion = false) => {
      isRunning = false;
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      if (waitForCompletion) {
        await lifecyclePromise;
      } else {
        resolveLifecycle();
      }
    };
  }
  /**
   * Process a single message with the given handler
   * @param message The message to process
   * @param handler Function to process the message
   */
  async processMessage(message, handler2) {
    const stopExtension = this.startVisibilityExtension(
      message.messageId,
      message.ticket
    );
    try {
      const result = await handler2(message.payload, {
        messageId: message.messageId,
        deliveryCount: message.deliveryCount,
        createdAt: message.createdAt,
        topicName: this.topicName,
        consumerGroup: this.consumerGroupName
      });
      await stopExtension();
      if (result && "timeoutSeconds" in result) {
        await this.client.changeVisibility({
          queueName: this.topicName,
          consumerGroup: this.consumerGroupName,
          messageId: message.messageId,
          ticket: message.ticket,
          visibilityTimeoutSeconds: result.timeoutSeconds
        });
        if (isDevMode()) {
          scheduleDevTimeout(
            this.topicName,
            message.messageId,
            result.timeoutSeconds
          );
        }
      } else {
        await this.client.deleteMessage({
          queueName: this.topicName,
          consumerGroup: this.consumerGroupName,
          messageId: message.messageId,
          ticket: message.ticket
        });
      }
    } catch (error) {
      await stopExtension();
      if (this.transport.finalize && message.payload !== void 0 && message.payload !== null) {
        try {
          await this.transport.finalize(message.payload);
        } catch (finalizeError) {
          console.warn("Failed to finalize message payload:", finalizeError);
        }
      }
      throw error;
    }
  }
  async consume(handler2, options) {
    if (options?.messageId) {
      if (options.skipPayload) {
        const response2 = await this.client.receiveMessageById(
          {
            queueName: this.topicName,
            consumerGroup: this.consumerGroupName,
            messageId: options.messageId,
            visibilityTimeoutSeconds: this.visibilityTimeout,
            skipPayload: true
          },
          this.transport
        );
        await this.processMessage(
          response2.message,
          handler2
        );
      } else {
        const response2 = await this.client.receiveMessageById(
          {
            queueName: this.topicName,
            consumerGroup: this.consumerGroupName,
            messageId: options.messageId,
            visibilityTimeoutSeconds: this.visibilityTimeout
          },
          this.transport
        );
        await this.processMessage(
          response2.message,
          handler2
        );
      }
    } else {
      let messageFound = false;
      for await (const message of this.client.receiveMessages(
        {
          queueName: this.topicName,
          consumerGroup: this.consumerGroupName,
          visibilityTimeoutSeconds: this.visibilityTimeout,
          limit: 1
        },
        this.transport
      )) {
        messageFound = true;
        await this.processMessage(message, handler2);
        break;
      }
      if (!messageFound) {
        throw new Error("No messages available");
      }
    }
  }
  /**
   * Get the consumer group name
   */
  get name() {
    return this.consumerGroupName;
  }
  /**
   * Get the topic name this consumer group is subscribed to
   */
  get topic() {
    return this.topicName;
  }
};
var Topic = class {
  client;
  topicName;
  transport;
  /**
   * Create a new Topic instance
   * @param client QueueClient instance to use for API calls
   * @param topicName Name of the topic to work with
   * @param transport Optional serializer/deserializer for the payload (defaults to JSON)
   */
  constructor(client2, topicName, transport) {
    this.client = client2;
    this.topicName = topicName;
    this.transport = transport || new JsonTransport();
  }
  /**
   * Publish a message to the topic
   * @param payload The data to publish
   * @param options Optional publish options
   * @returns An object containing the message ID
   * @throws {BadRequestError} When request parameters are invalid
   * @throws {UnauthorizedError} When authentication fails
   * @throws {ForbiddenError} When access is denied (environment mismatch)
   * @throws {InternalServerError} When server encounters an error
   */
  async publish(payload, options) {
    const result = await this.client.sendMessage(
      {
        queueName: this.topicName,
        payload,
        idempotencyKey: options?.idempotencyKey,
        retentionSeconds: options?.retentionSeconds,
        deploymentId: options?.deploymentId
      },
      this.transport
    );
    if (isDevMode()) {
      triggerDevCallbacks(this.topicName, result.messageId);
    }
    return { messageId: result.messageId };
  }
  /**
   * Create a consumer group for this topic
   * @param consumerGroupName Name of the consumer group
   * @param options Optional configuration for the consumer group
   * @returns A ConsumerGroup instance
   */
  consumerGroup(consumerGroupName, options) {
    const consumerOptions = {
      ...options,
      transport: options?.transport || this.transport
    };
    return new ConsumerGroup(
      this.client,
      this.topicName,
      consumerGroupName,
      consumerOptions
    );
  }
  /**
   * Get the topic name
   */
  get name() {
    return this.topicName;
  }
  /**
   * Get the transport used by this topic
   */
  get serializer() {
    return this.transport;
  }
};
function validateWildcardPattern(pattern) {
  const firstIndex = pattern.indexOf("*");
  const lastIndex = pattern.lastIndexOf("*");
  if (firstIndex !== lastIndex) {
    return false;
  }
  if (firstIndex === -1) {
    return false;
  }
  if (firstIndex !== pattern.length - 1) {
    return false;
  }
  return true;
}
function matchesWildcardPattern(topicName, pattern) {
  const prefix = pattern.slice(0, -1);
  return topicName.startsWith(prefix);
}
function findTopicHandler(queueName, handlers) {
  const exactHandler = handlers[queueName];
  if (exactHandler) {
    return exactHandler;
  }
  for (const pattern in handlers) {
    if (pattern.includes("*") && matchesWildcardPattern(queueName, pattern)) {
      return handlers[pattern];
    }
  }
  return null;
}
async function parseCallback(request2) {
  const contentType = request2.headers.get("content-type");
  if (!contentType || !contentType.includes("application/cloudevents+json")) {
    throw new Error(
      "Invalid content type: expected 'application/cloudevents+json'"
    );
  }
  let cloudEvent;
  try {
    cloudEvent = await request2.json();
  } catch (error) {
    throw new Error("Failed to parse CloudEvent from request body");
  }
  if (!cloudEvent.type || !cloudEvent.source || !cloudEvent.id || typeof cloudEvent.data !== "object" || cloudEvent.data == null) {
    throw new Error("Invalid CloudEvent: missing required fields");
  }
  if (cloudEvent.type !== "com.vercel.queue.v1beta") {
    throw new Error(
      `Invalid CloudEvent type: expected 'com.vercel.queue.v1beta', got '${cloudEvent.type}'`
    );
  }
  const missingFields = [];
  if (!("queueName" in cloudEvent.data)) missingFields.push("queueName");
  if (!("consumerGroup" in cloudEvent.data))
    missingFields.push("consumerGroup");
  if (!("messageId" in cloudEvent.data)) missingFields.push("messageId");
  if (missingFields.length > 0) {
    throw new Error(
      `Missing required CloudEvent data fields: ${missingFields.join(", ")}`
    );
  }
  const { messageId, queueName, consumerGroup } = cloudEvent.data;
  return {
    queueName,
    consumerGroup,
    messageId
  };
}
function createCallbackHandler(handlers, client2) {
  for (const topicPattern in handlers) {
    if (topicPattern.includes("*")) {
      if (!validateWildcardPattern(topicPattern)) {
        throw new Error(
          `Invalid wildcard pattern "${topicPattern}": * may only appear once and must be at the end of the topic name`
        );
      }
    }
  }
  const routeHandler = async (request2) => {
    try {
      const { queueName, consumerGroup, messageId } = await parseCallback(request2);
      const topicHandler = findTopicHandler(queueName, handlers);
      if (!topicHandler) {
        const availableTopics = Object.keys(handlers).join(", ");
        return Response.json(
          {
            error: `No handler found for topic: ${queueName}`,
            availableTopics
          },
          { status: 404 }
        );
      }
      const consumerGroupHandler = topicHandler[consumerGroup];
      if (!consumerGroupHandler) {
        const availableGroups = Object.keys(topicHandler).join(", ");
        return Response.json(
          {
            error: `No handler found for consumer group "${consumerGroup}" in topic "${queueName}".`,
            availableGroups
          },
          { status: 404 }
        );
      }
      const topic = new Topic(client2, queueName);
      const cg = topic.consumerGroup(consumerGroup);
      await cg.consume(consumerGroupHandler, { messageId });
      return Response.json({ status: "success" });
    } catch (error) {
      console.error("Queue callback error:", error);
      if (error instanceof Error && (error.message.includes("Missing required CloudEvent data fields") || error.message.includes("Invalid CloudEvent") || error.message.includes("Invalid CloudEvent type") || error.message.includes("Invalid content type") || error.message.includes("Failed to parse CloudEvent"))) {
        return Response.json({ error: error.message }, { status: 400 });
      }
      return Response.json(
        { error: "Failed to process queue message" },
        { status: 500 }
      );
    }
  };
  if (isDevMode()) {
    registerDevRouteHandler(routeHandler, handlers);
  }
  return routeHandler;
}
function handleCallback(handlers, client2) {
  return createCallbackHandler(handlers, client2 || new QueueClient());
}
async function send(topicName, payload, options) {
  const transport = options?.transport || new JsonTransport();
  const client2 = options?.client || new QueueClient();
  const result = await client2.sendMessage(
    {
      queueName: topicName,
      payload,
      idempotencyKey: options?.idempotencyKey,
      retentionSeconds: options?.retentionSeconds,
      deploymentId: options?.deploymentId
    },
    transport
  );
  if (isDevMode()) {
    triggerDevCallbacks(topicName, result.messageId);
  }
  return { messageId: result.messageId };
}
var Client = class {
  client;
  /**
   * Create a new Client
   * @param options QueueClient configuration options
   */
  constructor(options = {}) {
    this.client = new QueueClient(options);
  }
  /**
   * Send a message to a topic
   * @param topicName Name of the topic to send to
   * @param payload The data to send
   * @param options Optional publish options and transport
   * @returns Promise with the message ID
   * @throws {BadRequestError} When request parameters are invalid
   * @throws {UnauthorizedError} When authentication fails
   * @throws {ForbiddenError} When access is denied (environment mismatch)
   * @throws {InternalServerError} When server encounters an error
   */
  async send(topicName, payload, options) {
    return send(topicName, payload, {
      ...options,
      client: this.client
    });
  }
  /**
   * Create a callback handler for processing queue messages
   * Returns a Next.js route handler function that routes messages to appropriate handlers
   * @param handlers Object with topic-specific handlers organized by consumer groups
   * @returns A Next.js route handler function
   *
   * @example
   * ```typescript
   * export const POST = client.handleCallback({
   *   "user-events": {
   *     "welcome": (user, metadata) => console.log("Welcoming user", user),
   *     "analytics": (user, metadata) => console.log("Tracking user", user),
   *   },
   * });
   * ```
   */
  handleCallback(handlers) {
    return handleCallback(handlers, this.client);
  }
};
var lib = {};
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var __importDefault = lib && lib.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(lib, "__esModule", { value: true });
  lib.RateLimit = lib.Sema = void 0;
  const events_1 = __importDefault(require$$0$1);
  function arrayMove(src2, srcIndex, dst, dstIndex, len) {
    for (let j = 0; j < len; ++j) {
      dst[j + dstIndex] = src2[j + srcIndex];
      src2[j + srcIndex] = void 0;
    }
  }
  function pow2AtLeast(n) {
    n = n >>> 0;
    n = n - 1;
    n = n | n >> 1;
    n = n | n >> 2;
    n = n | n >> 4;
    n = n | n >> 8;
    n = n | n >> 16;
    return n + 1;
  }
  function getCapacity(capacity) {
    return pow2AtLeast(Math.min(Math.max(16, capacity), 1073741824));
  }
  class Deque {
    constructor(capacity) {
      this._capacity = getCapacity(capacity);
      this._length = 0;
      this._front = 0;
      this.arr = [];
    }
    push(item) {
      const length = this._length;
      this.checkCapacity(length + 1);
      const i = this._front + length & this._capacity - 1;
      this.arr[i] = item;
      this._length = length + 1;
      return length + 1;
    }
    pop() {
      const length = this._length;
      if (length === 0) {
        return void 0;
      }
      const i = this._front + length - 1 & this._capacity - 1;
      const ret = this.arr[i];
      this.arr[i] = void 0;
      this._length = length - 1;
      return ret;
    }
    shift() {
      const length = this._length;
      if (length === 0) {
        return void 0;
      }
      const front = this._front;
      const ret = this.arr[front];
      this.arr[front] = void 0;
      this._front = front + 1 & this._capacity - 1;
      this._length = length - 1;
      return ret;
    }
    get length() {
      return this._length;
    }
    checkCapacity(size) {
      if (this._capacity < size) {
        this.resizeTo(getCapacity(this._capacity * 1.5 + 16));
      }
    }
    resizeTo(capacity) {
      const oldCapacity = this._capacity;
      this._capacity = capacity;
      const front = this._front;
      const length = this._length;
      if (front + length > oldCapacity) {
        const moveItemsCount = front + length & oldCapacity - 1;
        arrayMove(this.arr, 0, this.arr, oldCapacity, moveItemsCount);
      }
    }
  }
  class ReleaseEmitter extends events_1.default {
  }
  function isFn(x) {
    return typeof x === "function";
  }
  function defaultInit() {
    return "1";
  }
  class Sema {
    constructor(nr, { initFn = defaultInit, pauseFn, resumeFn, capacity = 10 } = {}) {
      if (isFn(pauseFn) !== isFn(resumeFn)) {
        throw new Error("pauseFn and resumeFn must be both set for pausing");
      }
      this.nrTokens = nr;
      this.free = new Deque(nr);
      this.waiting = new Deque(capacity);
      this.releaseEmitter = new ReleaseEmitter();
      this.noTokens = initFn === defaultInit;
      this.pauseFn = pauseFn;
      this.resumeFn = resumeFn;
      this.paused = false;
      this.releaseEmitter.on("release", (token) => {
        const p = this.waiting.shift();
        if (p) {
          p.resolve(token);
        } else {
          if (this.resumeFn && this.paused) {
            this.paused = false;
            this.resumeFn();
          }
          this.free.push(token);
        }
      });
      for (let i = 0; i < nr; i++) {
        this.free.push(initFn());
      }
    }
    tryAcquire() {
      return this.free.pop();
    }
    async acquire() {
      let token = this.tryAcquire();
      if (token !== void 0) {
        return token;
      }
      return new Promise((resolve2, reject) => {
        if (this.pauseFn && !this.paused) {
          this.paused = true;
          this.pauseFn();
        }
        this.waiting.push({ resolve: resolve2, reject });
      });
    }
    release(token) {
      this.releaseEmitter.emit("release", this.noTokens ? "1" : token);
    }
    drain() {
      const a = new Array(this.nrTokens);
      for (let i = 0; i < this.nrTokens; i++) {
        a[i] = this.acquire();
      }
      return Promise.all(a);
    }
    nrWaiting() {
      return this.waiting.length;
    }
  }
  lib.Sema = Sema;
  function RateLimit(rps, { timeUnit = 1e3, uniformDistribution = false } = {}) {
    const sema = new Sema(uniformDistribution ? 1 : rps);
    const delay = uniformDistribution ? timeUnit / rps : timeUnit;
    return async function rl() {
      await sema.acquire();
      setTimeout(() => sema.release(), delay);
    };
  }
  lib.RateLimit = RateLimit;
  return lib;
}
var libExports = requireLib();
const ENCODING = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
const ENCODING_LEN = 32;
const RANDOM_LEN = 16;
const TIME_LEN = 10;
const TIME_MAX = 281474976710655;
var ULIDErrorCode;
(function(ULIDErrorCode2) {
  ULIDErrorCode2["Base32IncorrectEncoding"] = "B32_ENC_INVALID";
  ULIDErrorCode2["DecodeTimeInvalidCharacter"] = "DEC_TIME_CHAR";
  ULIDErrorCode2["DecodeTimeValueMalformed"] = "DEC_TIME_MALFORMED";
  ULIDErrorCode2["EncodeTimeNegative"] = "ENC_TIME_NEG";
  ULIDErrorCode2["EncodeTimeSizeExceeded"] = "ENC_TIME_SIZE_EXCEED";
  ULIDErrorCode2["EncodeTimeValueMalformed"] = "ENC_TIME_MALFORMED";
  ULIDErrorCode2["PRNGDetectFailure"] = "PRNG_DETECT";
  ULIDErrorCode2["ULIDInvalid"] = "ULID_INVALID";
  ULIDErrorCode2["Unexpected"] = "UNEXPECTED";
  ULIDErrorCode2["UUIDInvalid"] = "UUID_INVALID";
})(ULIDErrorCode || (ULIDErrorCode = {}));
class ULIDError extends Error {
  constructor(errorCode, message) {
    super(`${message} (${errorCode})`);
    this.name = "ULIDError";
    this.code = errorCode;
  }
}
function randomChar(prng) {
  const randomPosition = Math.floor(prng() * ENCODING_LEN) % ENCODING_LEN;
  return ENCODING.charAt(randomPosition);
}
function replaceCharAt(str, index, char) {
  if (index > str.length - 1) {
    return str;
  }
  return str.substr(0, index) + char + str.substr(index + 1);
}
function incrementBase32(str) {
  let done = void 0, index = str.length, char, charIndex, output = str;
  const maxCharIndex = ENCODING_LEN - 1;
  while (!done && index-- >= 0) {
    char = output[index];
    charIndex = ENCODING.indexOf(char);
    if (charIndex === -1) {
      throw new ULIDError(ULIDErrorCode.Base32IncorrectEncoding, "Incorrectly encoded string");
    }
    if (charIndex === maxCharIndex) {
      output = replaceCharAt(output, index, ENCODING[0]);
      continue;
    }
    done = replaceCharAt(output, index, ENCODING[charIndex + 1]);
  }
  if (typeof done === "string") {
    return done;
  }
  throw new ULIDError(ULIDErrorCode.Base32IncorrectEncoding, "Failed incrementing string");
}
function decodeTime(id) {
  if (id.length !== TIME_LEN + RANDOM_LEN) {
    throw new ULIDError(ULIDErrorCode.DecodeTimeValueMalformed, "Malformed ULID");
  }
  const time = id.substr(0, TIME_LEN).toUpperCase().split("").reverse().reduce((carry, char, index) => {
    const encodingIndex = ENCODING.indexOf(char);
    if (encodingIndex === -1) {
      throw new ULIDError(ULIDErrorCode.DecodeTimeInvalidCharacter, `Time decode error: Invalid character: ${char}`);
    }
    return carry += encodingIndex * Math.pow(ENCODING_LEN, index);
  }, 0);
  if (time > TIME_MAX) {
    throw new ULIDError(ULIDErrorCode.DecodeTimeValueMalformed, `Malformed ULID: timestamp too large: ${time}`);
  }
  return time;
}
function detectPRNG(root2) {
  const rootLookup = detectRoot();
  const globalCrypto = rootLookup && (rootLookup.crypto || rootLookup.msCrypto) || (typeof crypto$1 !== "undefined" ? crypto$1 : null);
  if (typeof globalCrypto?.getRandomValues === "function") {
    return () => {
      const buffer = new Uint8Array(1);
      globalCrypto.getRandomValues(buffer);
      return buffer[0] / 255;
    };
  } else if (typeof globalCrypto?.randomBytes === "function") {
    return () => globalCrypto.randomBytes(1).readUInt8() / 255;
  } else if (crypto$1?.randomBytes) {
    return () => crypto$1.randomBytes(1).readUInt8() / 255;
  }
  throw new ULIDError(ULIDErrorCode.PRNGDetectFailure, "Failed to find a reliable PRNG");
}
function detectRoot() {
  if (inWebWorker())
    return self;
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  return null;
}
function encodeRandom(len, prng) {
  let str = "";
  for (; len > 0; len--) {
    str = randomChar(prng) + str;
  }
  return str;
}
function encodeTime(now, len = TIME_LEN) {
  if (isNaN(now)) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeValueMalformed, `Time must be a number: ${now}`);
  } else if (now > TIME_MAX) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeSizeExceeded, `Cannot encode a time larger than ${TIME_MAX}: ${now}`);
  } else if (now < 0) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeNegative, `Time must be positive: ${now}`);
  } else if (Number.isInteger(now) === false) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeValueMalformed, `Time must be an integer: ${now}`);
  }
  let mod, str = "";
  for (let currentLen = len; currentLen > 0; currentLen--) {
    mod = now % ENCODING_LEN;
    str = ENCODING.charAt(mod) + str;
    now = (now - mod) / ENCODING_LEN;
  }
  return str;
}
function inWebWorker() {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
}
function monotonicFactory(prng) {
  const currentPRNG = prng || detectPRNG();
  let lastTime = 0, lastRandom;
  return function _ulid(seedTime) {
    const seed = !seedTime || isNaN(seedTime) ? Date.now() : seedTime;
    if (seed <= lastTime) {
      const incrementedRandom = lastRandom = incrementBase32(lastRandom);
      return encodeTime(lastTime, TIME_LEN) + incrementedRandom;
    }
    lastTime = seed;
    const newRandom = lastRandom = encodeRandom(RANDOM_LEN, currentPRNG);
    return encodeTime(seed, TIME_LEN) + newRandom;
  };
}
var undici = {};
var symbols$4;
var hasRequiredSymbols$4;
function requireSymbols$4() {
  if (hasRequiredSymbols$4) return symbols$4;
  hasRequiredSymbols$4 = 1;
  symbols$4 = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kBody: Symbol("abstracted request body"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kResume: Symbol("resume"),
    kOnError: Symbol("on error"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kInterceptors: Symbol("dispatch interceptors"),
    kMaxResponseSize: Symbol("max response size"),
    kHTTP2Session: Symbol("http2Session"),
    kHTTP2SessionState: Symbol("http2Session state"),
    kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
    kConstruct: Symbol("constructable"),
    kListeners: Symbol("listeners"),
    kHTTPContext: Symbol("http context"),
    kMaxConcurrentStreams: Symbol("max concurrent streams"),
    kNoProxyAgent: Symbol("no proxy agent"),
    kHttpProxyAgent: Symbol("http proxy agent"),
    kHttpsProxyAgent: Symbol("https proxy agent")
  };
  return symbols$4;
}
var errors;
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  class UndiciError extends Error {
    constructor(message) {
      super(message);
      this.name = "UndiciError";
      this.code = "UND_ERR";
    }
  }
  class ConnectTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ConnectTimeoutError";
      this.message = message || "Connect Timeout Error";
      this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
  }
  class HeadersTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "HeadersTimeoutError";
      this.message = message || "Headers Timeout Error";
      this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  }
  class HeadersOverflowError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "HeadersOverflowError";
      this.message = message || "Headers Overflow Error";
      this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
  }
  class BodyTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "BodyTimeoutError";
      this.message = message || "Body Timeout Error";
      this.code = "UND_ERR_BODY_TIMEOUT";
    }
  }
  class ResponseStatusCodeError extends UndiciError {
    constructor(message, statusCode, headers2, body2) {
      super(message);
      this.name = "ResponseStatusCodeError";
      this.message = message || "Response Status Code Error";
      this.code = "UND_ERR_RESPONSE_STATUS_CODE";
      this.body = body2;
      this.status = statusCode;
      this.statusCode = statusCode;
      this.headers = headers2;
    }
  }
  class InvalidArgumentError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InvalidArgumentError";
      this.message = message || "Invalid Argument Error";
      this.code = "UND_ERR_INVALID_ARG";
    }
  }
  class InvalidReturnValueError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InvalidReturnValueError";
      this.message = message || "Invalid Return Value Error";
      this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  }
  class AbortError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "AbortError";
      this.message = message || "The operation was aborted";
    }
  }
  class RequestAbortedError extends AbortError {
    constructor(message) {
      super(message);
      this.name = "AbortError";
      this.message = message || "Request aborted";
      this.code = "UND_ERR_ABORTED";
    }
  }
  class InformationalError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InformationalError";
      this.message = message || "Request information";
      this.code = "UND_ERR_INFO";
    }
  }
  class RequestContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "RequestContentLengthMismatchError";
      this.message = message || "Request body length does not match content-length header";
      this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
  }
  class ResponseContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ResponseContentLengthMismatchError";
      this.message = message || "Response body length does not match content-length header";
      this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
  }
  class ClientDestroyedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ClientDestroyedError";
      this.message = message || "The client is destroyed";
      this.code = "UND_ERR_DESTROYED";
    }
  }
  class ClientClosedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ClientClosedError";
      this.message = message || "The client is closed";
      this.code = "UND_ERR_CLOSED";
    }
  }
  class SocketError extends UndiciError {
    constructor(message, socket) {
      super(message);
      this.name = "SocketError";
      this.message = message || "Socket error";
      this.code = "UND_ERR_SOCKET";
      this.socket = socket;
    }
  }
  class NotSupportedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "NotSupportedError";
      this.message = message || "Not supported error";
      this.code = "UND_ERR_NOT_SUPPORTED";
    }
  }
  class BalancedPoolMissingUpstreamError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "MissingUpstreamError";
      this.message = message || "No upstream has been added to the BalancedPool";
      this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
  }
  class HTTPParserError extends Error {
    constructor(message, code, data) {
      super(message);
      this.name = "HTTPParserError";
      this.code = code ? `HPE_${code}` : void 0;
      this.data = data ? data.toString() : void 0;
    }
  }
  class ResponseExceededMaxSizeError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ResponseExceededMaxSizeError";
      this.message = message || "Response content exceeded max size";
      this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
  }
  class RequestRetryError extends UndiciError {
    constructor(message, code, { headers: headers2, data }) {
      super(message);
      this.name = "RequestRetryError";
      this.message = message || "Request retry error";
      this.code = "UND_ERR_REQ_RETRY";
      this.statusCode = code;
      this.data = data;
      this.headers = headers2;
    }
  }
  class SecureProxyConnectionError extends UndiciError {
    constructor(cause, message, options) {
      super(message, { cause, ...options ?? {} });
      this.name = "SecureProxyConnectionError";
      this.message = message || "Secure Proxy Connection failed";
      this.code = "UND_ERR_PRX_TLS";
      this.cause = cause;
    }
  }
  errors = {
    AbortError,
    HTTPParserError,
    UndiciError,
    HeadersTimeoutError,
    HeadersOverflowError,
    BodyTimeoutError,
    RequestContentLengthMismatchError,
    ConnectTimeoutError,
    ResponseStatusCodeError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError,
    ResponseContentLengthMismatchError,
    BalancedPoolMissingUpstreamError,
    ResponseExceededMaxSizeError,
    RequestRetryError,
    SecureProxyConnectionError
  };
  return errors;
}
var constants$4;
var hasRequiredConstants$4;
function requireConstants$4() {
  if (hasRequiredConstants$4) return constants$4;
  hasRequiredConstants$4 = 1;
  const headerNameLowerCasedRecord = {};
  const wellknownHeaderNames = [
    "Accept",
    "Accept-Encoding",
    "Accept-Language",
    "Accept-Ranges",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Age",
    "Allow",
    "Alt-Svc",
    "Alt-Used",
    "Authorization",
    "Cache-Control",
    "Clear-Site-Data",
    "Connection",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-Length",
    "Content-Location",
    "Content-Range",
    "Content-Security-Policy",
    "Content-Security-Policy-Report-Only",
    "Content-Type",
    "Cookie",
    "Cross-Origin-Embedder-Policy",
    "Cross-Origin-Opener-Policy",
    "Cross-Origin-Resource-Policy",
    "Date",
    "Device-Memory",
    "Downlink",
    "ECT",
    "ETag",
    "Expect",
    "Expect-CT",
    "Expires",
    "Forwarded",
    "From",
    "Host",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Keep-Alive",
    "Last-Modified",
    "Link",
    "Location",
    "Max-Forwards",
    "Origin",
    "Permissions-Policy",
    "Pragma",
    "Proxy-Authenticate",
    "Proxy-Authorization",
    "RTT",
    "Range",
    "Referer",
    "Referrer-Policy",
    "Refresh",
    "Retry-After",
    "Sec-WebSocket-Accept",
    "Sec-WebSocket-Extensions",
    "Sec-WebSocket-Key",
    "Sec-WebSocket-Protocol",
    "Sec-WebSocket-Version",
    "Server",
    "Server-Timing",
    "Service-Worker-Allowed",
    "Service-Worker-Navigation-Preload",
    "Set-Cookie",
    "SourceMap",
    "Strict-Transport-Security",
    "Supports-Loading-Mode",
    "TE",
    "Timing-Allow-Origin",
    "Trailer",
    "Transfer-Encoding",
    "Upgrade",
    "Upgrade-Insecure-Requests",
    "User-Agent",
    "Vary",
    "Via",
    "WWW-Authenticate",
    "X-Content-Type-Options",
    "X-DNS-Prefetch-Control",
    "X-Frame-Options",
    "X-Permitted-Cross-Domain-Policies",
    "X-Powered-By",
    "X-Requested-With",
    "X-XSS-Protection"
  ];
  for (let i = 0; i < wellknownHeaderNames.length; ++i) {
    const key = wellknownHeaderNames[i];
    const lowerCasedKey = key.toLowerCase();
    headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
  }
  Object.setPrototypeOf(headerNameLowerCasedRecord, null);
  constants$4 = {
    wellknownHeaderNames,
    headerNameLowerCasedRecord
  };
  return constants$4;
}
var tree_1;
var hasRequiredTree;
function requireTree() {
  if (hasRequiredTree) return tree_1;
  hasRequiredTree = 1;
  const {
    wellknownHeaderNames,
    headerNameLowerCasedRecord
  } = requireConstants$4();
  class TstNode {
    /** @type {any} */
    value = null;
    /** @type {null | TstNode} */
    left = null;
    /** @type {null | TstNode} */
    middle = null;
    /** @type {null | TstNode} */
    right = null;
    /** @type {number} */
    code;
    /**
     * @param {string} key
     * @param {any} value
     * @param {number} index
     */
    constructor(key, value, index) {
      if (index === void 0 || index >= key.length) {
        throw new TypeError("Unreachable");
      }
      const code = this.code = key.charCodeAt(index);
      if (code > 127) {
        throw new TypeError("key must be ascii string");
      }
      if (key.length !== ++index) {
        this.middle = new TstNode(key, value, index);
      } else {
        this.value = value;
      }
    }
    /**
     * @param {string} key
     * @param {any} value
     */
    add(key, value) {
      const length = key.length;
      if (length === 0) {
        throw new TypeError("Unreachable");
      }
      let index = 0;
      let node2 = this;
      while (true) {
        const code = key.charCodeAt(index);
        if (code > 127) {
          throw new TypeError("key must be ascii string");
        }
        if (node2.code === code) {
          if (length === ++index) {
            node2.value = value;
            break;
          } else if (node2.middle !== null) {
            node2 = node2.middle;
          } else {
            node2.middle = new TstNode(key, value, index);
            break;
          }
        } else if (node2.code < code) {
          if (node2.left !== null) {
            node2 = node2.left;
          } else {
            node2.left = new TstNode(key, value, index);
            break;
          }
        } else if (node2.right !== null) {
          node2 = node2.right;
        } else {
          node2.right = new TstNode(key, value, index);
          break;
        }
      }
    }
    /**
     * @param {Uint8Array} key
     * @return {TstNode | null}
     */
    search(key) {
      const keylength = key.length;
      let index = 0;
      let node2 = this;
      while (node2 !== null && index < keylength) {
        let code = key[index];
        if (code <= 90 && code >= 65) {
          code |= 32;
        }
        while (node2 !== null) {
          if (code === node2.code) {
            if (keylength === ++index) {
              return node2;
            }
            node2 = node2.middle;
            break;
          }
          node2 = node2.code < code ? node2.left : node2.right;
        }
      }
      return null;
    }
  }
  class TernarySearchTree {
    /** @type {TstNode | null} */
    node = null;
    /**
     * @param {string} key
     * @param {any} value
     * */
    insert(key, value) {
      if (this.node === null) {
        this.node = new TstNode(key, value, 0);
      } else {
        this.node.add(key, value);
      }
    }
    /**
     * @param {Uint8Array} key
     * @return {any}
     */
    lookup(key) {
      return this.node?.search(key)?.value ?? null;
    }
  }
  const tree = new TernarySearchTree();
  for (let i = 0; i < wellknownHeaderNames.length; ++i) {
    const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]];
    tree.insert(key, key);
  }
  tree_1 = {
    TernarySearchTree,
    tree
  };
  return tree_1;
}
var util$7;
var hasRequiredUtil$7;
function requireUtil$7() {
  if (hasRequiredUtil$7) return util$7;
  hasRequiredUtil$7 = 1;
  const assert = require$$0$3;
  const { kDestroyed, kBodyUsed, kListeners, kBody } = requireSymbols$4();
  const { IncomingMessage } = require$$2;
  const stream = require$$0$4;
  const net = require$$4;
  const { Blob: Blob2 } = require$$0$2;
  const nodeUtil = require$$0$5;
  const { stringify: stringify2 } = require$$7;
  const { EventEmitter: EE } = require$$8;
  const { InvalidArgumentError } = requireErrors();
  const { headerNameLowerCasedRecord } = requireConstants$4();
  const { tree } = requireTree();
  const [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
  class BodyAsyncIterable {
    constructor(body2) {
      this[kBody] = body2;
      this[kBodyUsed] = false;
    }
    async *[Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }
  function wrapRequestBody(body2) {
    if (isStream(body2)) {
      if (bodyLength(body2) === 0) {
        body2.on("data", function() {
          assert(false);
        });
      }
      if (typeof body2.readableDidRead !== "boolean") {
        body2[kBodyUsed] = false;
        EE.prototype.on.call(body2, "data", function() {
          this[kBodyUsed] = true;
        });
      }
      return body2;
    } else if (body2 && typeof body2.pipeTo === "function") {
      return new BodyAsyncIterable(body2);
    } else if (body2 && typeof body2 !== "string" && !ArrayBuffer.isView(body2) && isIterable(body2)) {
      return new BodyAsyncIterable(body2);
    } else {
      return body2;
    }
  }
  function nop() {
  }
  function isStream(obj) {
    return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
  }
  function isBlobLike(object) {
    if (object === null) {
      return false;
    } else if (object instanceof Blob2) {
      return true;
    } else if (typeof object !== "object") {
      return false;
    } else {
      const sTag = object[Symbol.toStringTag];
      return (sTag === "Blob" || sTag === "File") && ("stream" in object && typeof object.stream === "function" || "arrayBuffer" in object && typeof object.arrayBuffer === "function");
    }
  }
  function buildURL(url, queryParams) {
    if (url.includes("?") || url.includes("#")) {
      throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    }
    const stringified = stringify2(queryParams);
    if (stringified) {
      url += "?" + stringified;
    }
    return url;
  }
  function isValidPort(port) {
    const value = parseInt(port, 10);
    return value === Number(port) && value >= 0 && value <= 65535;
  }
  function isHttpOrHttpsPrefixed(value) {
    return value != null && value[0] === "h" && value[1] === "t" && value[2] === "t" && value[3] === "p" && (value[4] === ":" || value[4] === "s" && value[5] === ":");
  }
  function parseURL(url) {
    if (typeof url === "string") {
      url = new URL(url);
      if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      return url;
    }
    if (!url || typeof url !== "object") {
      throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
    }
    if (!(url instanceof URL)) {
      if (url.port != null && url.port !== "" && isValidPort(url.port) === false) {
        throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
      }
      if (url.path != null && typeof url.path !== "string") {
        throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
      }
      if (url.pathname != null && typeof url.pathname !== "string") {
        throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
      }
      if (url.hostname != null && typeof url.hostname !== "string") {
        throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
      }
      if (url.origin != null && typeof url.origin !== "string") {
        throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
      }
      if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
      let origin = url.origin != null ? url.origin : `${url.protocol || ""}//${url.hostname || ""}:${port}`;
      let path2 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
      if (origin[origin.length - 1] === "/") {
        origin = origin.slice(0, origin.length - 1);
      }
      if (path2 && path2[0] !== "/") {
        path2 = `/${path2}`;
      }
      return new URL(`${origin}${path2}`);
    }
    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
      throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    }
    return url;
  }
  function parseOrigin(url) {
    url = parseURL(url);
    if (url.pathname !== "/" || url.search || url.hash) {
      throw new InvalidArgumentError("invalid url");
    }
    return url;
  }
  function getHostname(host) {
    if (host[0] === "[") {
      const idx2 = host.indexOf("]");
      assert(idx2 !== -1);
      return host.substring(1, idx2);
    }
    const idx = host.indexOf(":");
    if (idx === -1) return host;
    return host.substring(0, idx);
  }
  function getServerName(host) {
    if (!host) {
      return null;
    }
    assert.strictEqual(typeof host, "string");
    const servername = getHostname(host);
    if (net.isIP(servername)) {
      return "";
    }
    return servername;
  }
  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  function isAsyncIterable(obj) {
    return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
  }
  function isIterable(obj) {
    return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
  }
  function bodyLength(body2) {
    if (body2 == null) {
      return 0;
    } else if (isStream(body2)) {
      const state = body2._readableState;
      return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
    } else if (isBlobLike(body2)) {
      return body2.size != null ? body2.size : null;
    } else if (isBuffer(body2)) {
      return body2.byteLength;
    }
    return null;
  }
  function isDestroyed(body2) {
    return body2 && !!(body2.destroyed || body2[kDestroyed] || stream.isDestroyed?.(body2));
  }
  function destroy(stream2, err) {
    if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
      return;
    }
    if (typeof stream2.destroy === "function") {
      if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
        stream2.socket = null;
      }
      stream2.destroy(err);
    } else if (err) {
      queueMicrotask(() => {
        stream2.emit("error", err);
      });
    }
    if (stream2.destroyed !== true) {
      stream2[kDestroyed] = true;
    }
  }
  const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  function parseKeepAliveTimeout(val) {
    const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
    return m ? parseInt(m[1], 10) * 1e3 : null;
  }
  function headerNameToString(value) {
    return typeof value === "string" ? headerNameLowerCasedRecord[value] ?? value.toLowerCase() : tree.lookup(value) ?? value.toString("latin1").toLowerCase();
  }
  function bufferToLowerCasedHeaderName(value) {
    return tree.lookup(value) ?? value.toString("latin1").toLowerCase();
  }
  function parseHeaders2(headers2, obj) {
    if (obj === void 0) obj = {};
    for (let i = 0; i < headers2.length; i += 2) {
      const key = headerNameToString(headers2[i]);
      let val = obj[key];
      if (val) {
        if (typeof val === "string") {
          val = [val];
          obj[key] = val;
        }
        val.push(headers2[i + 1].toString("utf8"));
      } else {
        const headersValue = headers2[i + 1];
        if (typeof headersValue === "string") {
          obj[key] = headersValue;
        } else {
          obj[key] = Array.isArray(headersValue) ? headersValue.map((x) => x.toString("utf8")) : headersValue.toString("utf8");
        }
      }
    }
    if ("content-length" in obj && "content-disposition" in obj) {
      obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
    }
    return obj;
  }
  function parseRawHeaders(headers2) {
    const len = headers2.length;
    const ret = new Array(len);
    let hasContentLength = false;
    let contentDispositionIdx = -1;
    let key;
    let val;
    let kLen = 0;
    for (let n = 0; n < headers2.length; n += 2) {
      key = headers2[n];
      val = headers2[n + 1];
      typeof key !== "string" && (key = key.toString());
      typeof val !== "string" && (val = val.toString("utf8"));
      kLen = key.length;
      if (kLen === 14 && key[7] === "-" && (key === "content-length" || key.toLowerCase() === "content-length")) {
        hasContentLength = true;
      } else if (kLen === 19 && key[7] === "-" && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
        contentDispositionIdx = n + 1;
      }
      ret[n] = key;
      ret[n + 1] = val;
    }
    if (hasContentLength && contentDispositionIdx !== -1) {
      ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
    }
    return ret;
  }
  function isBuffer(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  }
  function validateHandler(handler2, method, upgrade) {
    if (!handler2 || typeof handler2 !== "object") {
      throw new InvalidArgumentError("handler must be an object");
    }
    if (typeof handler2.onConnect !== "function") {
      throw new InvalidArgumentError("invalid onConnect method");
    }
    if (typeof handler2.onError !== "function") {
      throw new InvalidArgumentError("invalid onError method");
    }
    if (typeof handler2.onBodySent !== "function" && handler2.onBodySent !== void 0) {
      throw new InvalidArgumentError("invalid onBodySent method");
    }
    if (upgrade || method === "CONNECT") {
      if (typeof handler2.onUpgrade !== "function") {
        throw new InvalidArgumentError("invalid onUpgrade method");
      }
    } else {
      if (typeof handler2.onHeaders !== "function") {
        throw new InvalidArgumentError("invalid onHeaders method");
      }
      if (typeof handler2.onData !== "function") {
        throw new InvalidArgumentError("invalid onData method");
      }
      if (typeof handler2.onComplete !== "function") {
        throw new InvalidArgumentError("invalid onComplete method");
      }
    }
  }
  function isDisturbed(body2) {
    return !!(body2 && (stream.isDisturbed(body2) || body2[kBodyUsed]));
  }
  function isErrored(body2) {
    return !!(body2 && stream.isErrored(body2));
  }
  function isReadable(body2) {
    return !!(body2 && stream.isReadable(body2));
  }
  function getSocketInfo(socket) {
    return {
      localAddress: socket.localAddress,
      localPort: socket.localPort,
      remoteAddress: socket.remoteAddress,
      remotePort: socket.remotePort,
      remoteFamily: socket.remoteFamily,
      timeout: socket.timeout,
      bytesWritten: socket.bytesWritten,
      bytesRead: socket.bytesRead
    };
  }
  function ReadableStreamFrom(iterable) {
    let iterator;
    return new ReadableStream(
      {
        async start() {
          iterator = iterable[Symbol.asyncIterator]();
        },
        async pull(controller) {
          const { done, value } = await iterator.next();
          if (done) {
            queueMicrotask(() => {
              controller.close();
              controller.byobRequest?.respond(0);
            });
          } else {
            const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
            if (buf.byteLength) {
              controller.enqueue(new Uint8Array(buf));
            }
          }
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        },
        type: "bytes"
      }
    );
  }
  function isFormDataLike(object) {
    return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
  }
  function addAbortListener(signal, listener) {
    if ("addEventListener" in signal) {
      signal.addEventListener("abort", listener, { once: true });
      return () => signal.removeEventListener("abort", listener);
    }
    signal.addListener("abort", listener);
    return () => signal.removeListener("abort", listener);
  }
  const hasToWellFormed = typeof String.prototype.toWellFormed === "function";
  const hasIsWellFormed = typeof String.prototype.isWellFormed === "function";
  function toUSVString(val) {
    return hasToWellFormed ? `${val}`.toWellFormed() : nodeUtil.toUSVString(val);
  }
  function isUSVString(val) {
    return hasIsWellFormed ? `${val}`.isWellFormed() : toUSVString(val) === `${val}`;
  }
  function isTokenCharCode(c) {
    switch (c) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return false;
      default:
        return c >= 33 && c <= 126;
    }
  }
  function isValidHTTPToken(characters) {
    if (characters.length === 0) {
      return false;
    }
    for (let i = 0; i < characters.length; ++i) {
      if (!isTokenCharCode(characters.charCodeAt(i))) {
        return false;
      }
    }
    return true;
  }
  const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function isValidHeaderValue(characters) {
    return !headerCharRegex.test(characters);
  }
  function parseRangeHeader(range) {
    if (range == null || range === "") return { start: 0, end: null, size: null };
    const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
    return m ? {
      start: parseInt(m[1]),
      end: m[2] ? parseInt(m[2]) : null,
      size: m[3] ? parseInt(m[3]) : null
    } : null;
  }
  function addListener(obj, name, listener) {
    const listeners = obj[kListeners] ??= [];
    listeners.push([name, listener]);
    obj.on(name, listener);
    return obj;
  }
  function removeAllListeners(obj) {
    for (const [name, listener] of obj[kListeners] ?? []) {
      obj.removeListener(name, listener);
    }
    obj[kListeners] = null;
  }
  function errorRequest(client2, request2, err) {
    try {
      request2.onError(err);
      assert(request2.aborted);
    } catch (err2) {
      client2.emit("error", err2);
    }
  }
  const kEnumerableProperty = /* @__PURE__ */ Object.create(null);
  kEnumerableProperty.enumerable = true;
  const normalizedMethodRecordsBase = {
    delete: "DELETE",
    DELETE: "DELETE",
    get: "GET",
    GET: "GET",
    head: "HEAD",
    HEAD: "HEAD",
    options: "OPTIONS",
    OPTIONS: "OPTIONS",
    post: "POST",
    POST: "POST",
    put: "PUT",
    PUT: "PUT"
  };
  const normalizedMethodRecords = {
    ...normalizedMethodRecordsBase,
    patch: "patch",
    PATCH: "PATCH"
  };
  Object.setPrototypeOf(normalizedMethodRecordsBase, null);
  Object.setPrototypeOf(normalizedMethodRecords, null);
  util$7 = {
    kEnumerableProperty,
    nop,
    isDisturbed,
    isErrored,
    isReadable,
    toUSVString,
    isUSVString,
    isBlobLike,
    parseOrigin,
    parseURL,
    getServerName,
    isStream,
    isIterable,
    isAsyncIterable,
    isDestroyed,
    headerNameToString,
    bufferToLowerCasedHeaderName,
    addListener,
    removeAllListeners,
    errorRequest,
    parseRawHeaders,
    parseHeaders: parseHeaders2,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    deepClone,
    ReadableStreamFrom,
    isBuffer,
    validateHandler,
    getSocketInfo,
    isFormDataLike,
    buildURL,
    addAbortListener,
    isValidHTTPToken,
    isValidHeaderValue,
    isTokenCharCode,
    parseRangeHeader,
    normalizedMethodRecordsBase,
    normalizedMethodRecords,
    isValidPort,
    isHttpOrHttpsPrefixed,
    nodeMajor,
    nodeMinor,
    safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"],
    wrapRequestBody
  };
  return util$7;
}
var diagnostics;
var hasRequiredDiagnostics;
function requireDiagnostics() {
  if (hasRequiredDiagnostics) return diagnostics;
  hasRequiredDiagnostics = 1;
  const diagnosticsChannel = require$$0$6;
  const util2 = require$$0$5;
  const undiciDebugLog = util2.debuglog("undici");
  const fetchDebuglog = util2.debuglog("fetch");
  const websocketDebuglog = util2.debuglog("websocket");
  let isClientSet = false;
  const channels = {
    // Client
    beforeConnect: diagnosticsChannel.channel("undici:client:beforeConnect"),
    connected: diagnosticsChannel.channel("undici:client:connected"),
    connectError: diagnosticsChannel.channel("undici:client:connectError"),
    sendHeaders: diagnosticsChannel.channel("undici:client:sendHeaders"),
    // Request
    create: diagnosticsChannel.channel("undici:request:create"),
    bodySent: diagnosticsChannel.channel("undici:request:bodySent"),
    headers: diagnosticsChannel.channel("undici:request:headers"),
    trailers: diagnosticsChannel.channel("undici:request:trailers"),
    error: diagnosticsChannel.channel("undici:request:error"),
    // WebSocket
    open: diagnosticsChannel.channel("undici:websocket:open"),
    close: diagnosticsChannel.channel("undici:websocket:close"),
    socketError: diagnosticsChannel.channel("undici:websocket:socket_error"),
    ping: diagnosticsChannel.channel("undici:websocket:ping"),
    pong: diagnosticsChannel.channel("undici:websocket:pong")
  };
  if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
    const debuglog = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog;
    diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((evt) => {
      const {
        connectParams: { version: version2, protocol, port, host }
      } = evt;
      debuglog(
        "connecting to %s using %s%s",
        `${host}${port ? `:${port}` : ""}`,
        protocol,
        version2
      );
    });
    diagnosticsChannel.channel("undici:client:connected").subscribe((evt) => {
      const {
        connectParams: { version: version2, protocol, port, host }
      } = evt;
      debuglog(
        "connected to %s using %s%s",
        `${host}${port ? `:${port}` : ""}`,
        protocol,
        version2
      );
    });
    diagnosticsChannel.channel("undici:client:connectError").subscribe((evt) => {
      const {
        connectParams: { version: version2, protocol, port, host },
        error
      } = evt;
      debuglog(
        "connection to %s using %s%s errored - %s",
        `${host}${port ? `:${port}` : ""}`,
        protocol,
        version2,
        error.message
      );
    });
    diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((evt) => {
      const {
        request: { method, path: path2, origin }
      } = evt;
      debuglog("sending request to %s %s/%s", method, origin, path2);
    });
    diagnosticsChannel.channel("undici:request:headers").subscribe((evt) => {
      const {
        request: { method, path: path2, origin },
        response: { statusCode }
      } = evt;
      debuglog(
        "received response to %s %s/%s - HTTP %d",
        method,
        origin,
        path2,
        statusCode
      );
    });
    diagnosticsChannel.channel("undici:request:trailers").subscribe((evt) => {
      const {
        request: { method, path: path2, origin }
      } = evt;
      debuglog("trailers received from %s %s/%s", method, origin, path2);
    });
    diagnosticsChannel.channel("undici:request:error").subscribe((evt) => {
      const {
        request: { method, path: path2, origin },
        error
      } = evt;
      debuglog(
        "request to %s %s/%s errored - %s",
        method,
        origin,
        path2,
        error.message
      );
    });
    isClientSet = true;
  }
  if (websocketDebuglog.enabled) {
    if (!isClientSet) {
      const debuglog = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog;
      diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((evt) => {
        const {
          connectParams: { version: version2, protocol, port, host }
        } = evt;
        debuglog(
          "connecting to %s%s using %s%s",
          host,
          port ? `:${port}` : "",
          protocol,
          version2
        );
      });
      diagnosticsChannel.channel("undici:client:connected").subscribe((evt) => {
        const {
          connectParams: { version: version2, protocol, port, host }
        } = evt;
        debuglog(
          "connected to %s%s using %s%s",
          host,
          port ? `:${port}` : "",
          protocol,
          version2
        );
      });
      diagnosticsChannel.channel("undici:client:connectError").subscribe((evt) => {
        const {
          connectParams: { version: version2, protocol, port, host },
          error
        } = evt;
        debuglog(
          "connection to %s%s using %s%s errored - %s",
          host,
          port ? `:${port}` : "",
          protocol,
          version2,
          error.message
        );
      });
      diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((evt) => {
        const {
          request: { method, path: path2, origin }
        } = evt;
        debuglog("sending request to %s %s/%s", method, origin, path2);
      });
    }
    diagnosticsChannel.channel("undici:websocket:open").subscribe((evt) => {
      const {
        address: { address, port }
      } = evt;
      websocketDebuglog("connection opened %s%s", address, port ? `:${port}` : "");
    });
    diagnosticsChannel.channel("undici:websocket:close").subscribe((evt) => {
      const { websocket: websocket2, code, reason } = evt;
      websocketDebuglog(
        "closed connection to %s - %s %s",
        websocket2.url,
        code,
        reason
      );
    });
    diagnosticsChannel.channel("undici:websocket:socket_error").subscribe((err) => {
      websocketDebuglog("connection errored - %s", err.message);
    });
    diagnosticsChannel.channel("undici:websocket:ping").subscribe((evt) => {
      websocketDebuglog("ping received");
    });
    diagnosticsChannel.channel("undici:websocket:pong").subscribe((evt) => {
      websocketDebuglog("pong received");
    });
  }
  diagnostics = {
    channels
  };
  return diagnostics;
}
var request$1;
var hasRequiredRequest$1;
function requireRequest$1() {
  if (hasRequiredRequest$1) return request$1;
  hasRequiredRequest$1 = 1;
  const {
    InvalidArgumentError,
    NotSupportedError
  } = requireErrors();
  const assert = require$$0$3;
  const {
    isValidHTTPToken,
    isValidHeaderValue,
    isStream,
    destroy,
    isBuffer,
    isFormDataLike,
    isIterable,
    isBlobLike,
    buildURL,
    validateHandler,
    getServerName,
    normalizedMethodRecords
  } = requireUtil$7();
  const { channels } = requireDiagnostics();
  const { headerNameLowerCasedRecord } = requireConstants$4();
  const invalidPathRegex = /[^\u0021-\u00ff]/;
  const kHandler = Symbol("handler");
  class Request2 {
    constructor(origin, {
      path: path2,
      method,
      body: body2,
      headers: headers2,
      query,
      idempotent,
      blocking,
      upgrade,
      headersTimeout,
      bodyTimeout,
      reset,
      throwOnError,
      expectContinue,
      servername
    }, handler2) {
      if (typeof path2 !== "string") {
        throw new InvalidArgumentError("path must be a string");
      } else if (path2[0] !== "/" && !(path2.startsWith("http://") || path2.startsWith("https://")) && method !== "CONNECT") {
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      } else if (invalidPathRegex.test(path2)) {
        throw new InvalidArgumentError("invalid request path");
      }
      if (typeof method !== "string") {
        throw new InvalidArgumentError("method must be a string");
      } else if (normalizedMethodRecords[method] === void 0 && !isValidHTTPToken(method)) {
        throw new InvalidArgumentError("invalid request method");
      }
      if (upgrade && typeof upgrade !== "string") {
        throw new InvalidArgumentError("upgrade must be a string");
      }
      if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("invalid headersTimeout");
      }
      if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("invalid bodyTimeout");
      }
      if (reset != null && typeof reset !== "boolean") {
        throw new InvalidArgumentError("invalid reset");
      }
      if (expectContinue != null && typeof expectContinue !== "boolean") {
        throw new InvalidArgumentError("invalid expectContinue");
      }
      this.headersTimeout = headersTimeout;
      this.bodyTimeout = bodyTimeout;
      this.throwOnError = throwOnError === true;
      this.method = method;
      this.abort = null;
      if (body2 == null) {
        this.body = null;
      } else if (isStream(body2)) {
        this.body = body2;
        const rState = this.body._readableState;
        if (!rState || !rState.autoDestroy) {
          this.endHandler = function autoDestroy() {
            destroy(this);
          };
          this.body.on("end", this.endHandler);
        }
        this.errorHandler = (err) => {
          if (this.abort) {
            this.abort(err);
          } else {
            this.error = err;
          }
        };
        this.body.on("error", this.errorHandler);
      } else if (isBuffer(body2)) {
        this.body = body2.byteLength ? body2 : null;
      } else if (ArrayBuffer.isView(body2)) {
        this.body = body2.buffer.byteLength ? Buffer.from(body2.buffer, body2.byteOffset, body2.byteLength) : null;
      } else if (body2 instanceof ArrayBuffer) {
        this.body = body2.byteLength ? Buffer.from(body2) : null;
      } else if (typeof body2 === "string") {
        this.body = body2.length ? Buffer.from(body2) : null;
      } else if (isFormDataLike(body2) || isIterable(body2) || isBlobLike(body2)) {
        this.body = body2;
      } else {
        throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      }
      this.completed = false;
      this.aborted = false;
      this.upgrade = upgrade || null;
      this.path = query ? buildURL(path2, query) : path2;
      this.origin = origin;
      this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
      this.blocking = blocking == null ? false : blocking;
      this.reset = reset == null ? null : reset;
      this.host = null;
      this.contentLength = null;
      this.contentType = null;
      this.headers = [];
      this.expectContinue = expectContinue != null ? expectContinue : false;
      if (Array.isArray(headers2)) {
        if (headers2.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i = 0; i < headers2.length; i += 2) {
          processHeader(this, headers2[i], headers2[i + 1]);
        }
      } else if (headers2 && typeof headers2 === "object") {
        if (headers2[Symbol.iterator]) {
          for (const header of headers2) {
            if (!Array.isArray(header) || header.length !== 2) {
              throw new InvalidArgumentError("headers must be in key-value pair format");
            }
            processHeader(this, header[0], header[1]);
          }
        } else {
          const keys = Object.keys(headers2);
          for (let i = 0; i < keys.length; ++i) {
            processHeader(this, keys[i], headers2[keys[i]]);
          }
        }
      } else if (headers2 != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      validateHandler(handler2, method, upgrade);
      this.servername = servername || getServerName(this.host);
      this[kHandler] = handler2;
      if (channels.create.hasSubscribers) {
        channels.create.publish({ request: this });
      }
    }
    onBodySent(chunk) {
      if (this[kHandler].onBodySent) {
        try {
          return this[kHandler].onBodySent(chunk);
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onRequestSent() {
      if (channels.bodySent.hasSubscribers) {
        channels.bodySent.publish({ request: this });
      }
      if (this[kHandler].onRequestSent) {
        try {
          return this[kHandler].onRequestSent();
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onConnect(abort) {
      assert(!this.aborted);
      assert(!this.completed);
      if (this.error) {
        abort(this.error);
      } else {
        this.abort = abort;
        return this[kHandler].onConnect(abort);
      }
    }
    onResponseStarted() {
      return this[kHandler].onResponseStarted?.();
    }
    onHeaders(statusCode, headers2, resume, statusText) {
      assert(!this.aborted);
      assert(!this.completed);
      if (channels.headers.hasSubscribers) {
        channels.headers.publish({ request: this, response: { statusCode, headers: headers2, statusText } });
      }
      try {
        return this[kHandler].onHeaders(statusCode, headers2, resume, statusText);
      } catch (err) {
        this.abort(err);
      }
    }
    onData(chunk) {
      assert(!this.aborted);
      assert(!this.completed);
      try {
        return this[kHandler].onData(chunk);
      } catch (err) {
        this.abort(err);
        return false;
      }
    }
    onUpgrade(statusCode, headers2, socket) {
      assert(!this.aborted);
      assert(!this.completed);
      return this[kHandler].onUpgrade(statusCode, headers2, socket);
    }
    onComplete(trailers) {
      this.onFinally();
      assert(!this.aborted);
      this.completed = true;
      if (channels.trailers.hasSubscribers) {
        channels.trailers.publish({ request: this, trailers });
      }
      try {
        return this[kHandler].onComplete(trailers);
      } catch (err) {
        this.onError(err);
      }
    }
    onError(error) {
      this.onFinally();
      if (channels.error.hasSubscribers) {
        channels.error.publish({ request: this, error });
      }
      if (this.aborted) {
        return;
      }
      this.aborted = true;
      return this[kHandler].onError(error);
    }
    onFinally() {
      if (this.errorHandler) {
        this.body.off("error", this.errorHandler);
        this.errorHandler = null;
      }
      if (this.endHandler) {
        this.body.off("end", this.endHandler);
        this.endHandler = null;
      }
    }
    addHeader(key, value) {
      processHeader(this, key, value);
      return this;
    }
  }
  function processHeader(request2, key, val) {
    if (val && (typeof val === "object" && !Array.isArray(val))) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    } else if (val === void 0) {
      return;
    }
    let headerName = headerNameLowerCasedRecord[key];
    if (headerName === void 0) {
      headerName = key.toLowerCase();
      if (headerNameLowerCasedRecord[headerName] === void 0 && !isValidHTTPToken(headerName)) {
        throw new InvalidArgumentError("invalid header key");
      }
    }
    if (Array.isArray(val)) {
      const arr = [];
      for (let i = 0; i < val.length; i++) {
        if (typeof val[i] === "string") {
          if (!isValidHeaderValue(val[i])) {
            throw new InvalidArgumentError(`invalid ${key} header`);
          }
          arr.push(val[i]);
        } else if (val[i] === null) {
          arr.push("");
        } else if (typeof val[i] === "object") {
          throw new InvalidArgumentError(`invalid ${key} header`);
        } else {
          arr.push(`${val[i]}`);
        }
      }
      val = arr;
    } else if (typeof val === "string") {
      if (!isValidHeaderValue(val)) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
    } else if (val === null) {
      val = "";
    } else {
      val = `${val}`;
    }
    if (request2.host === null && headerName === "host") {
      if (typeof val !== "string") {
        throw new InvalidArgumentError("invalid host header");
      }
      request2.host = val;
    } else if (request2.contentLength === null && headerName === "content-length") {
      request2.contentLength = parseInt(val, 10);
      if (!Number.isFinite(request2.contentLength)) {
        throw new InvalidArgumentError("invalid content-length header");
      }
    } else if (request2.contentType === null && headerName === "content-type") {
      request2.contentType = val;
      request2.headers.push(key, val);
    } else if (headerName === "transfer-encoding" || headerName === "keep-alive" || headerName === "upgrade") {
      throw new InvalidArgumentError(`invalid ${headerName} header`);
    } else if (headerName === "connection") {
      const value = typeof val === "string" ? val.toLowerCase() : null;
      if (value !== "close" && value !== "keep-alive") {
        throw new InvalidArgumentError("invalid connection header");
      }
      if (value === "close") {
        request2.reset = true;
      }
    } else if (headerName === "expect") {
      throw new NotSupportedError("expect header not supported");
    } else {
      request2.headers.push(key, val);
    }
  }
  request$1 = Request2;
  return request$1;
}
var dispatcher;
var hasRequiredDispatcher;
function requireDispatcher() {
  if (hasRequiredDispatcher) return dispatcher;
  hasRequiredDispatcher = 1;
  const EventEmitter2 = require$$8;
  class Dispatcher extends EventEmitter2 {
    dispatch() {
      throw new Error("not implemented");
    }
    close() {
      throw new Error("not implemented");
    }
    destroy() {
      throw new Error("not implemented");
    }
    compose(...args) {
      const interceptors = Array.isArray(args[0]) ? args[0] : args;
      let dispatch = this.dispatch.bind(this);
      for (const interceptor of interceptors) {
        if (interceptor == null) {
          continue;
        }
        if (typeof interceptor !== "function") {
          throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);
        }
        dispatch = interceptor(dispatch);
        if (dispatch == null || typeof dispatch !== "function" || dispatch.length !== 2) {
          throw new TypeError("invalid interceptor");
        }
      }
      return new ComposedDispatcher(this, dispatch);
    }
  }
  class ComposedDispatcher extends Dispatcher {
    #dispatcher = null;
    #dispatch = null;
    constructor(dispatcher2, dispatch) {
      super();
      this.#dispatcher = dispatcher2;
      this.#dispatch = dispatch;
    }
    dispatch(...args) {
      this.#dispatch(...args);
    }
    close(...args) {
      return this.#dispatcher.close(...args);
    }
    destroy(...args) {
      return this.#dispatcher.destroy(...args);
    }
  }
  dispatcher = Dispatcher;
  return dispatcher;
}
var dispatcherBase;
var hasRequiredDispatcherBase;
function requireDispatcherBase() {
  if (hasRequiredDispatcherBase) return dispatcherBase;
  hasRequiredDispatcherBase = 1;
  const Dispatcher = requireDispatcher();
  const {
    ClientDestroyedError,
    ClientClosedError,
    InvalidArgumentError
  } = requireErrors();
  const { kDestroy, kClose, kClosed, kDestroyed, kDispatch, kInterceptors } = requireSymbols$4();
  const kOnDestroyed = Symbol("onDestroyed");
  const kOnClosed = Symbol("onClosed");
  const kInterceptedDispatch = Symbol("Intercepted Dispatch");
  class DispatcherBase extends Dispatcher {
    constructor() {
      super();
      this[kDestroyed] = false;
      this[kOnDestroyed] = null;
      this[kClosed] = false;
      this[kOnClosed] = [];
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    get interceptors() {
      return this[kInterceptors];
    }
    set interceptors(newInterceptors) {
      if (newInterceptors) {
        for (let i = newInterceptors.length - 1; i >= 0; i--) {
          const interceptor = this[kInterceptors][i];
          if (typeof interceptor !== "function") {
            throw new InvalidArgumentError("interceptor must be an function");
          }
        }
      }
      this[kInterceptors] = newInterceptors;
    }
    close(callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject) => {
          this.close((err, data) => {
            return err ? reject(err) : resolve2(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        queueMicrotask(() => callback(new ClientDestroyedError(), null));
        return;
      }
      if (this[kClosed]) {
        if (this[kOnClosed]) {
          this[kOnClosed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      this[kClosed] = true;
      this[kOnClosed].push(callback);
      const onClosed = () => {
        const callbacks = this[kOnClosed];
        this[kOnClosed] = null;
        for (let i = 0; i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kClose]().then(() => this.destroy()).then(() => {
        queueMicrotask(onClosed);
      });
    }
    destroy(err, callback) {
      if (typeof err === "function") {
        callback = err;
        err = null;
      }
      if (callback === void 0) {
        return new Promise((resolve2, reject) => {
          this.destroy(err, (err2, data) => {
            return err2 ? (
              /* istanbul ignore next: should never error */
              reject(err2)
            ) : resolve2(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        if (this[kOnDestroyed]) {
          this[kOnDestroyed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      if (!err) {
        err = new ClientDestroyedError();
      }
      this[kDestroyed] = true;
      this[kOnDestroyed] = this[kOnDestroyed] || [];
      this[kOnDestroyed].push(callback);
      const onDestroyed = () => {
        const callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (let i = 0; i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kDestroy](err).then(() => {
        queueMicrotask(onDestroyed);
      });
    }
    [kInterceptedDispatch](opts, handler2) {
      if (!this[kInterceptors] || this[kInterceptors].length === 0) {
        this[kInterceptedDispatch] = this[kDispatch];
        return this[kDispatch](opts, handler2);
      }
      let dispatch = this[kDispatch].bind(this);
      for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
        dispatch = this[kInterceptors][i](dispatch);
      }
      this[kInterceptedDispatch] = dispatch;
      return dispatch(opts, handler2);
    }
    dispatch(opts, handler2) {
      if (!handler2 || typeof handler2 !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      try {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object.");
        }
        if (this[kDestroyed] || this[kOnDestroyed]) {
          throw new ClientDestroyedError();
        }
        if (this[kClosed]) {
          throw new ClientClosedError();
        }
        return this[kInterceptedDispatch](opts, handler2);
      } catch (err) {
        if (typeof handler2.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        handler2.onError(err);
        return false;
      }
    }
  }
  dispatcherBase = DispatcherBase;
  return dispatcherBase;
}
var connect;
var hasRequiredConnect;
function requireConnect() {
  if (hasRequiredConnect) return connect;
  hasRequiredConnect = 1;
  const net = require$$4;
  const assert = require$$0$3;
  const util2 = requireUtil$7();
  const { InvalidArgumentError, ConnectTimeoutError } = requireErrors();
  let tls;
  let SessionCache;
  if (commonjsGlobal.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {
    SessionCache = class WeakSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = /* @__PURE__ */ new Map();
        this._sessionRegistry = new commonjsGlobal.FinalizationRegistry((key) => {
          if (this._sessionCache.size < this._maxCachedSessions) {
            return;
          }
          const ref = this._sessionCache.get(key);
          if (ref !== void 0 && ref.deref() === void 0) {
            this._sessionCache.delete(key);
          }
        });
      }
      get(sessionKey) {
        const ref = this._sessionCache.get(sessionKey);
        return ref ? ref.deref() : null;
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        this._sessionCache.set(sessionKey, new WeakRef(session));
        this._sessionRegistry.register(session, sessionKey);
      }
    };
  } else {
    SessionCache = class SimpleSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = /* @__PURE__ */ new Map();
      }
      get(sessionKey) {
        return this._sessionCache.get(sessionKey);
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        if (this._sessionCache.size >= this._maxCachedSessions) {
          const { value: oldestKey } = this._sessionCache.keys().next();
          this._sessionCache.delete(oldestKey);
        }
        this._sessionCache.set(sessionKey, session);
      }
    };
  }
  function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {
    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
      throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
    }
    const options = { path: socketPath, ...opts };
    const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
    timeout = timeout == null ? 1e4 : timeout;
    allowH2 = allowH2 != null ? allowH2 : false;
    return function connect2({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
      let socket;
      if (protocol === "https:") {
        if (!tls) {
          tls = require$$4$1;
        }
        servername = servername || options.servername || util2.getServerName(host) || null;
        const sessionKey = servername || hostname;
        const session = customSession || sessionCache.get(sessionKey) || null;
        assert(sessionKey);
        socket = tls.connect({
          highWaterMark: 16384,
          // TLS in node can't have bigger HWM anyway...
          ...options,
          servername,
          session,
          localAddress,
          // TODO(HTTP/2): Add support for h2c
          ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
          socket: httpSocket,
          // upgrade socket connection
          port: port || 443,
          host: hostname
        });
        socket.on("session", function(session2) {
          sessionCache.set(sessionKey, session2);
        });
      } else {
        assert(!httpSocket, "httpSocket can only be sent on TLS update");
        socket = net.connect({
          highWaterMark: 64 * 1024,
          // Same as nodejs fs streams.
          ...options,
          localAddress,
          port: port || 80,
          host: hostname
        });
      }
      if (options.keepAlive == null || options.keepAlive) {
        const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
        socket.setKeepAlive(true, keepAliveInitialDelay);
      }
      const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
      socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
        cancelTimeout();
        if (callback) {
          const cb = callback;
          callback = null;
          cb(null, this);
        }
      }).on("error", function(err) {
        cancelTimeout();
        if (callback) {
          const cb = callback;
          callback = null;
          cb(err);
        }
      });
      return socket;
    };
  }
  function setupTimeout(onConnectTimeout2, timeout) {
    if (!timeout) {
      return () => {
      };
    }
    let s1 = null;
    let s2 = null;
    const timeoutId = setTimeout(() => {
      s1 = setImmediate(() => {
        if (process.platform === "win32") {
          s2 = setImmediate(() => onConnectTimeout2());
        } else {
          onConnectTimeout2();
        }
      });
    }, timeout);
    return () => {
      clearTimeout(timeoutId);
      clearImmediate(s1);
      clearImmediate(s2);
    };
  }
  function onConnectTimeout(socket) {
    let message = "Connect Timeout Error";
    if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {
      message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(", ")})`;
    }
    util2.destroy(socket, new ConnectTimeoutError(message));
  }
  connect = buildConnector;
  return connect;
}
var timers;
var hasRequiredTimers;
function requireTimers() {
  if (hasRequiredTimers) return timers;
  hasRequiredTimers = 1;
  const TICK_MS = 499;
  let fastNow = Date.now();
  let fastNowTimeout;
  const fastTimers = [];
  function onTimeout() {
    fastNow = Date.now();
    let len = fastTimers.length;
    let idx = 0;
    while (idx < len) {
      const timer = fastTimers[idx];
      if (timer.state === 0) {
        timer.state = fastNow + timer.delay - TICK_MS;
      } else if (timer.state > 0 && fastNow >= timer.state) {
        timer.state = -1;
        timer.callback(timer.opaque);
      }
      if (timer.state === -1) {
        timer.state = -2;
        if (idx !== len - 1) {
          fastTimers[idx] = fastTimers.pop();
        } else {
          fastTimers.pop();
        }
        len -= 1;
      } else {
        idx += 1;
      }
    }
    if (fastTimers.length > 0) {
      refreshTimeout();
    }
  }
  function refreshTimeout() {
    if (fastNowTimeout?.refresh) {
      fastNowTimeout.refresh();
    } else {
      clearTimeout(fastNowTimeout);
      fastNowTimeout = setTimeout(onTimeout, TICK_MS);
      if (fastNowTimeout.unref) {
        fastNowTimeout.unref();
      }
    }
  }
  class Timeout {
    constructor(callback, delay, opaque) {
      this.callback = callback;
      this.delay = delay;
      this.opaque = opaque;
      this.state = -2;
      this.refresh();
    }
    refresh() {
      if (this.state === -2) {
        fastTimers.push(this);
        if (!fastNowTimeout || fastTimers.length === 1) {
          refreshTimeout();
        }
      }
      this.state = 0;
    }
    clear() {
      this.state = -1;
    }
  }
  timers = {
    setTimeout(callback, delay, opaque) {
      return delay <= 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
    },
    clearTimeout(timeout) {
      if (timeout instanceof Timeout) {
        timeout.clear();
      } else {
        clearTimeout(timeout);
      }
    }
  };
  return timers;
}
var constants$3 = {};
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  Object.defineProperty(utils, "__esModule", { value: true });
  utils.enumToMap = void 0;
  function enumToMap(obj) {
    const res = {};
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      if (typeof value === "number") {
        res[key] = value;
      }
    });
    return res;
  }
  utils.enumToMap = enumToMap;
  return utils;
}
var hasRequiredConstants$3;
function requireConstants$3() {
  if (hasRequiredConstants$3) return constants$3;
  hasRequiredConstants$3 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.SPECIAL_HEADERS = exports$1.HEADER_STATE = exports$1.MINOR = exports$1.MAJOR = exports$1.CONNECTION_TOKEN_CHARS = exports$1.HEADER_CHARS = exports$1.TOKEN = exports$1.STRICT_TOKEN = exports$1.HEX = exports$1.URL_CHAR = exports$1.STRICT_URL_CHAR = exports$1.USERINFO_CHARS = exports$1.MARK = exports$1.ALPHANUM = exports$1.NUM = exports$1.HEX_MAP = exports$1.NUM_MAP = exports$1.ALPHA = exports$1.FINISH = exports$1.H_METHOD_MAP = exports$1.METHOD_MAP = exports$1.METHODS_RTSP = exports$1.METHODS_ICE = exports$1.METHODS_HTTP = exports$1.METHODS = exports$1.LENIENT_FLAGS = exports$1.FLAGS = exports$1.TYPE = exports$1.ERROR = void 0;
    const utils_1 = requireUtils();
    (function(ERROR) {
      ERROR[ERROR["OK"] = 0] = "OK";
      ERROR[ERROR["INTERNAL"] = 1] = "INTERNAL";
      ERROR[ERROR["STRICT"] = 2] = "STRICT";
      ERROR[ERROR["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR[ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR[ERROR["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR[ERROR["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR[ERROR["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR[ERROR["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR[ERROR["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR[ERROR["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR[ERROR["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR[ERROR["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR[ERROR["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR[ERROR["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR[ERROR["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR[ERROR["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR[ERROR["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR[ERROR["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR[ERROR["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR[ERROR["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR[ERROR["PAUSED"] = 21] = "PAUSED";
      ERROR[ERROR["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR[ERROR["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR[ERROR["USER"] = 24] = "USER";
    })(exports$1.ERROR || (exports$1.ERROR = {}));
    (function(TYPE) {
      TYPE[TYPE["BOTH"] = 0] = "BOTH";
      TYPE[TYPE["REQUEST"] = 1] = "REQUEST";
      TYPE[TYPE["RESPONSE"] = 2] = "RESPONSE";
    })(exports$1.TYPE || (exports$1.TYPE = {}));
    (function(FLAGS) {
      FLAGS[FLAGS["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS[FLAGS["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS[FLAGS["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS[FLAGS["CHUNKED"] = 8] = "CHUNKED";
      FLAGS[FLAGS["UPGRADE"] = 16] = "UPGRADE";
      FLAGS[FLAGS["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS[FLAGS["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS[FLAGS["TRAILING"] = 128] = "TRAILING";
      FLAGS[FLAGS["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(exports$1.FLAGS || (exports$1.FLAGS = {}));
    (function(LENIENT_FLAGS) {
      LENIENT_FLAGS[LENIENT_FLAGS["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS[LENIENT_FLAGS["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS[LENIENT_FLAGS["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(exports$1.LENIENT_FLAGS || (exports$1.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
      METHODS2[METHODS2["GET"] = 1] = "GET";
      METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
      METHODS2[METHODS2["POST"] = 3] = "POST";
      METHODS2[METHODS2["PUT"] = 4] = "PUT";
      METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
      METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
      METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
      METHODS2[METHODS2["COPY"] = 8] = "COPY";
      METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
      METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
      METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
      METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
      METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
      METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
      METHODS2[METHODS2["BIND"] = 16] = "BIND";
      METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
      METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
      METHODS2[METHODS2["ACL"] = 19] = "ACL";
      METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
      METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
      METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
      METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
      METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
      METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS2[METHODS2["LINK"] = 31] = "LINK";
      METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
      METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
      METHODS2[METHODS2["PRI"] = 34] = "PRI";
      METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
      METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
      METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
      METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
      METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
      METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
    })(METHODS = exports$1.METHODS || (exports$1.METHODS = {}));
    exports$1.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE
    ];
    exports$1.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports$1.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST
    ];
    exports$1.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports$1.H_METHOD_MAP = {};
    Object.keys(exports$1.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports$1.H_METHOD_MAP[key] = exports$1.METHOD_MAP[key];
      }
    });
    (function(FINISH) {
      FINISH[FINISH["SAFE"] = 0] = "SAFE";
      FINISH[FINISH["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH[FINISH["UNSAFE"] = 2] = "UNSAFE";
    })(exports$1.FINISH || (exports$1.FINISH = {}));
    exports$1.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports$1.ALPHA.push(String.fromCharCode(i));
      exports$1.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports$1.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports$1.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports$1.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports$1.ALPHANUM = exports$1.ALPHA.concat(exports$1.NUM);
    exports$1.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports$1.USERINFO_CHARS = exports$1.ALPHANUM.concat(exports$1.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports$1.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports$1.ALPHANUM);
    exports$1.URL_CHAR = exports$1.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i = 128; i <= 255; i++) {
      exports$1.URL_CHAR.push(i);
    }
    exports$1.HEX = exports$1.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports$1.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports$1.ALPHANUM);
    exports$1.TOKEN = exports$1.STRICT_TOKEN.concat([" "]);
    exports$1.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports$1.HEADER_CHARS.push(i);
      }
    }
    exports$1.CONNECTION_TOKEN_CHARS = exports$1.HEADER_CHARS.filter((c) => c !== 44);
    exports$1.MAJOR = exports$1.NUM_MAP;
    exports$1.MINOR = exports$1.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports$1.HEADER_STATE || (exports$1.HEADER_STATE = {}));
    exports$1.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  })(constants$3);
  return constants$3;
}
var llhttpWasm;
var hasRequiredLlhttpWasm;
function requireLlhttpWasm() {
  if (hasRequiredLlhttpWasm) return llhttpWasm;
  hasRequiredLlhttpWasm = 1;
  const { Buffer: Buffer2 } = require$$0$2;
  llhttpWasm = Buffer2.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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CABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv", "base64");
  return llhttpWasm;
}
var llhttp_simdWasm;
var hasRequiredLlhttp_simdWasm;
function requireLlhttp_simdWasm() {
  if (hasRequiredLlhttp_simdWasm) return llhttp_simdWasm;
  hasRequiredLlhttp_simdWasm = 1;
  const { Buffer: Buffer2 } = require$$0$2;
  llhttp_simdWasm = Buffer2.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxBACEDDKIBCyACQeQANgIcIAIgATYCFCACQeMXNgIQIAJBFTYCDEEAIQMMoQELIAJBADYCACAGQQFqIQEgAi0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACEDIAJBADYCHCACIAE2AhQgAkH3CTYCECACQQg2AgwMoAELIAJBADYCACAGQQFqIQEgAi0AKUEhRg0DIAJBADYCHCACIAE2AhQgAkGbCjYCECACQQg2AgxBACEDDJ8BCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJBkDM2AhAgAkEINgIMDJ0BCyACQQA2AgAgBkEBaiEBIAItAClBI0kNACACQQA2AhwgAiABNgIUIAJB0wk2AhAgAkEINgIMQQAhAwycAQtB0QAhAwyCAQsgAS0AAEEwayIAQf8BcUEKSQRAIAIgADoAKiABQQFqIQFBzwAhAwyCAQsgAigCBCEAIAJBADYCBCACIAAgARAoIgBFDYYBIAJB3gA2AhwgAiABNgIUIAIgADYCDEEAIQMMmgELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ2GASACQdwANgIcIAIgATYCFCACIAA2AgxBACEDDJkBCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMhwELIAJB2gA2AhwgAiAFNgIUIAIgADYCDAyYAQtBACEBQQEhAwsgAiADOgArIAVBAWohAwJAAkACQCACLQAtQRBxDQACQAJAAkAgAi0AKg4DAQACBAsgBkUNAwwCCyAADQEMAgsgAUUNAQsgAigCBCEAIAJBADYCBCACIAAgAxAoIgBFBEAgAyEBDAILIAJB2AA2AhwgAiADNgIUIAIgADYCDEEAIQMMmAELIAIoAgQhACACQQA2AgQgAiAAIAMQKCIARQRAIAMhAQyHAQsgAkHZADYCHCACIAM2AhQgAiAANgIMQQAhAwyXAQtBzAAhAwx9CyAAQRVHBEAgAkEANgIcIAIgATYCFCACQZQNNgIQIAJBITYCDEEAIQMMlgELIAJB1wA2AhwgAiABNgIUIAJByRc2AhAgAkEVNgIMQQAhAwyVAQtBACEDIAJBADYCHCACIAE2AhQgAkGAETYCECACQQk2AgwMlAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0AIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMkwELQckAIQMMeQsgAkEANgIcIAIgATYCFCACQcEoNgIQIAJBBzYCDCACQQA2AgBBACEDDJEBCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAlIgBFDQAgAkHSADYCHCACIAE2AhQgAiAANgIMDJABC0HIACEDDHYLIAJBADYCACAFIQELIAJBgBI7ASogAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANAQtBxwAhAwxzCyAAQRVGBEAgAkHRADYCHCACIAE2AhQgAkHjFzYCECACQRU2AgxBACEDDIwBC0EAIQMgAkEANgIcIAIgATYCFCACQbkNNgIQIAJBGjYCDAyLAQtBACEDIAJBADYCHCACIAE2AhQgAkGgGTYCECACQR42AgwMigELIAEtAABBOkYEQCACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgBFDQEgAkHDADYCHCACIAA2AgwgAiABQQFqNgIUDIoBC0EAIQMgAkEANgIcIAIgATYCFCACQbERNgIQIAJBCjYCDAyJAQsgAUEBaiEBQTshAwxvCyACQcMANgIcIAIgADYCDCACIAFBAWo2AhQMhwELQQAhAyACQQA2AhwgAiABNgIUIAJB8A42AhAgAkEcNgIMDIYBCyACIAIvATBBEHI7ATAMZgsCQCACLwEwIgBBCHFFDQAgAi0AKEEBRw0AIAItAC1BCHFFDQMLIAIgAEH3+wNxQYAEcjsBMAwECyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE1IQMMbgsgAikDICIKQpmz5syZs+bMGVYNASACIApCCn4iCjcDICAKIACtQv8BgyILQn+FVg0BIAIgCiALfDcDICAEIAFBAWoiAUcNAAtBOSEDDIUBCyACKAIEIQBBACEDIAJBADYCBCACIAAgAUEBaiIBECoiAA0MDHcLQTkhAwyDAQsgAi0AMEEgcQ0GQcUBIQMMaQtBACEDIAJBADYCBCACIAEgARAqIgBFDQQgAkE6NgIcIAIgADYCDCACIAFBAWo2AhQMgQELIAItAChBAUcNACACLQAtQQhxRQ0BC0E3IQMMZgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIABEAgAkE7NgIcIAIgADYCDCACIAFBAWo2AhQMfwsgAUEBaiEBDG4LIAJBCDoALAwECyABQQFqIQEMbQtBACEDIAJBADYCHCACIAE2AhQgAkHkEjYCECACQQQ2AgwMewsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ1sIAJBNzYCHCACIAE2AhQgAiAANgIMDHoLIAIgAi8BMEEgcjsBMAtBMCEDDF8LIAJBNjYCHCACIAE2AhQgAiAANgIMDHcLIABBLEcNASABQQFqIQBBASEBAkACQAJAAkACQCACLQAsQQVrDgQDAQIEAAsgACEBDAQLQQIhAQwBC0EEIQELIAJBAToALCACIAIvATAgAXI7ATAgACEBDAELIAIgAi8BMEEIcjsBMCAAIQELQTkhAwxcCyACQQA6ACwLQTQhAwxaCyABIARGBEBBLSEDDHMLAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0EtIQMMdAsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ0CIAJBLDYCHCACIAE2AhQgAiAANgIMDHMLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAS0AAEENRgRAIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAi0ALUEBcQRAQcQBIQMMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIADQEMZQtBLyEDDFcLIAJBLjYCHCACIAE2AhQgAiAANgIMDG8LQQAhAyACQQA2AhwgAiABNgIUIAJB8BQ2AhAgAkEDNgIMDG4LQQEhAwJAAkACQAJAIAItACxBBWsOBAMBAgAECyACIAIvATBBCHI7ATAMAwtBAiEDDAELQQQhAwsgAkEBOgAsIAIgAi8BMCADcjsBMAtBKiEDDFMLQQAhAyACQQA2AhwgAiABNgIUIAJB4Q82AhAgAkEKNgIMDGsLQQEhAwJAAkACQAJAAkACQCACLQAsQQJrDgcFBAQDAQIABAsgAiACLwEwQQhyOwEwDAMLQQIhAwwBC0EEIQMLIAJBAToALCACIAIvATAgA3I7ATALQSshAwxSC0EAIQMgAkEANgIcIAIgATYCFCACQasSNgIQIAJBCzYCDAxqC0EAIQMgAkEANgIcIAIgATYCFCACQf0NNgIQIAJBHTYCDAxpCyABIARHBEADQCABLQAAQSBHDUggBCABQQFqIgFHDQALQSUhAwxpC0ElIQMMaAsgAi0ALUEBcQRAQcMBIQMMTwsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKSIABEAgAkEmNgIcIAIgADYCDCACIAFBAWo2AhQMaAsgAUEBaiEBDFwLIAFBAWohASACLwEwIgBBgAFxBEBBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAEUNBiAAQRVHDR8gAkEFNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMZwsCQCAAQaAEcUGgBEcNACACLQAtQQJxDQBBACEDIAJBADYCHCACIAE2AhQgAkGWEzYCECACQQQ2AgwMZwsgAgJ/IAIvATBBFHFBFEYEQEEBIAItAChBAUYNARogAi8BMkHlAEYMAQsgAi0AKUEFRgs6AC5BACEAAkAgAigCOCIDRQ0AIAMoAiQiA0UNACACIAMRAAAhAAsCQAJAAkACQAJAIAAOFgIBAAQEBAQEBAQEBAQEBAQEBAQEBAMECyACQQE6AC4LIAIgAi8BMEHAAHI7ATALQSchAwxPCyACQSM2AhwgAiABNgIUIAJBpRY2AhAgAkEVNgIMQQAhAwxnC0EAIQMgAkEANgIcIAIgATYCFCACQdULNgIQIAJBETYCDAxmC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAADQELQQ4hAwxLCyAAQRVGBEAgAkECNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMZAtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMYwtBACEDIAJBADYCHCACIAE2AhQgAkGqHDYCECACQQ82AgwMYgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEgCqdqIgEQKyIARQ0AIAJBBTYCHCACIAE2AhQgAiAANgIMDGELQQ8hAwxHC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxfC0IBIQoLIAFBAWohAQJAIAIpAyAiC0L//////////w9YBEAgAiALQgSGIAqENwMgDAELQQAhAyACQQA2AhwgAiABNgIUIAJBrQk2AhAgAkEMNgIMDF4LQSQhAwxEC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxcCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAsIgBFBEAgAUEBaiEBDFILIAJBFzYCHCACIAA2AgwgAiABQQFqNgIUDFsLIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQRY2AhwgAiAANgIMIAIgAUEBajYCFAxbC0EfIQMMQQtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQLSIARQRAIAFBAWohAQxQCyACQRQ2AhwgAiAANgIMIAIgAUEBajYCFAxYCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABEC0iAEUEQCABQQFqIQEMAQsgAkETNgIcIAIgADYCDCACIAFBAWo2AhQMWAtBHiEDDD4LQQAhAyACQQA2AhwgAiABNgIUIAJBxgw2AhAgAkEjNgIMDFYLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABEC0iAEUEQCABQQFqIQEMTgsgAkERNgIcIAIgADYCDCACIAFBAWo2AhQMVQsgAkEQNgIcIAIgATYCFCACIAA2AgwMVAtBACEDIAJBADYCHCACIAE2AhQgAkHGDDYCECACQSM2AgwMUwtBACEDIAJBADYCHCACIAE2AhQgAkHAFTYCECACQQI2AgwMUgsgAigCBCEAQQAhAyACQQA2AgQCQCACIAAgARAtIgBFBEAgAUEBaiEBDAELIAJBDjYCHCACIAA2AgwgAiABQQFqNgIUDFILQRshAww4C0EAIQMgAkEANgIcIAIgATYCFCACQcYMNgIQIAJBIzYCDAxQCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABECwiAEUEQCABQQFqIQEMAQsgAkENNgIcIAIgADYCDCACIAFBAWo2AhQMUAtBGiEDDDYLQQAhAyACQQA2AhwgAiABNgIUIAJBmg82AhAgAkEiNgIMDE4LIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQQw2AhwgAiAANgIMIAIgAUEBajYCFAxOC0EZIQMMNAtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMTAsgAEEVRwRAQQAhAyACQQA2AhwgAiABNgIUIAJBgww2AhAgAkETNgIMDEwLIAJBCjYCHCACIAE2AhQgAkHkFjYCECACQRU2AgxBACEDDEsLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABIAqnaiIBECsiAARAIAJBBzYCHCACIAE2AhQgAiAANgIMDEsLQRMhAwwxCyAAQRVHBEBBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMSgsgAkEeNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMSQtBACEAAkAgAigCOCIDRQ0AIAMoAiwiA0UNACACIAMRAAAhAAsgAEUNQSAAQRVGBEAgAkEDNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMSQtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMSAtBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMRwtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMRgsgAkEAOgAvIAItAC1BBHFFDT8LIAJBADoALyACQQE6ADRBACEDDCsLQQAhAyACQQA2AhwgAkHkETYCECACQQc2AgwgAiABQQFqNgIUDEMLAkADQAJAIAEtAABBCmsOBAACAgACCyAEIAFBAWoiAUcNAAtB3QEhAwxDCwJAAkAgAi0ANEEBRw0AQQAhAAJAIAIoAjgiA0UNACADKAJYIgNFDQAgAiADEQAAIQALIABFDQAgAEEVRw0BIAJB3AE2AhwgAiABNgIUIAJB1RY2AhAgAkEVNgIMQQAhAwxEC0HBASEDDCoLIAJBADYCHCACIAE2AhQgAkHpCzYCECACQR82AgxBACEDDEILAkACQCACLQAoQQFrDgIEAQALQcABIQMMKQtBuQEhAwwoCyACQQI6AC9BACEAAkAgAigCOCIDRQ0AIAMoAgAiA0UNACACIAMRAAAhAAsgAEUEQEHCASEDDCgLIABBFUcEQCACQQA2AhwgAiABNgIUIAJBpAw2AhAgAkEQNgIMQQAhAwxBCyACQdsBNgIcIAIgATYCFCACQfoWNgIQIAJBFTYCDEEAIQMMQAsgASAERgRAQdoBIQMMQAsgAS0AAEHIAEYNASACQQE6ACgLQawBIQMMJQtBvwEhAwwkCyABIARHBEAgAkEQNgIIIAIgATYCBEG+ASEDDCQLQdkBIQMMPAsgASAERgRAQdgBIQMMPAsgAS0AAEHIAEcNBCABQQFqIQFBvQEhAwwiCyABIARGBEBB1wEhAww7CwJAAkAgAS0AAEHFAGsOEAAFBQUFBQUFBQUFBQUFBQEFCyABQQFqIQFBuwEhAwwiCyABQQFqIQFBvAEhAwwhC0HWASEDIAEgBEYNOSACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGD0ABqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw6CyACKAIEIQAgAkIANwMAIAIgACAGQQFqIgEQJyIARQRAQcYBIQMMIQsgAkHVATYCHCACIAE2AhQgAiAANgIMQQAhAww5C0HUASEDIAEgBEYNOCACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGB0ABqLQAARw0CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw5CyACQYEEOwEoIAIoAgQhACACQgA3AwAgAiAAIAZBAWoiARAnIgANAwwCCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB2Bs2AhAgAkEINgIMDDYLQboBIQMMHAsgAkHTATYCHCACIAE2AhQgAiAANgIMQQAhAww0C0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAARQ0AIABBFUYNASACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwwzC0HkACEDDBkLIAJB+AA2AhwgAiABNgIUIAJByhg2AhAgAkEVNgIMQQAhAwwxC0HSASEDIAQgASIARg0wIAQgAWsgAigCACIBaiEFIAAgAWtBBGohBgJAA0AgAC0AACABQfzPAGotAABHDQEgAUEERg0DIAFBAWohASAEIABBAWoiAEcNAAsgAiAFNgIADDELIAJBADYCHCACIAA2AhQgAkGQMzYCECACQQg2AgwgAkEANgIAQQAhAwwwCyABIARHBEAgAkEONgIIIAIgATYCBEG3ASEDDBcLQdEBIQMMLwsgAkEANgIAIAZBAWohAQtBuAEhAwwUCyABIARGBEBB0AEhAwwtCyABLQAAQTBrIgBB/wFxQQpJBEAgAiAAOgAqIAFBAWohAUG2ASEDDBQLIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0UIAJBzwE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAsgASAERgRAQc4BIQMMLAsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0VIAJBzQE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAtBtQEhAwwSCyAEIAEiBUYEQEHMASEDDCsLQQAhAEEBIQFBASEGQQAhAwJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAUtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyEDQQAhAUEAIQYMAgtBCSEDQQEhAEEAIQFBACEGDAELQQAhAUEBIQMLIAIgAzoAKyAFQQFqIQMCQAJAIAItAC1BEHENAAJAAkACQCACLQAqDgMBAAIECyAGRQ0DDAILIAANAQwCCyABRQ0BCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMAwsgAkHJATYCHCACIAM2AhQgAiAANgIMQQAhAwwtCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMGAsgAkHKATYCHCACIAM2AhQgAiAANgIMQQAhAwwsCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMFgsgAkHLATYCHCACIAU2AhQgAiAANgIMDCsLQbQBIQMMEQtBACEAAkAgAigCOCIDRQ0AIAMoAjwiA0UNACACIAMRAAAhAAsCQCAABEAgAEEVRg0BIAJBADYCHCACIAE2AhQgAkGUDTYCECACQSE2AgxBACEDDCsLQbIBIQMMEQsgAkHIATYCHCACIAE2AhQgAkHJFzYCECACQRU2AgxBACEDDCkLIAJBADYCACAGQQFqIQFB9QAhAwwPCyACLQApQQVGBEBB4wAhAwwPC0HiACEDDA4LIAAhASACQQA2AgALIAJBADoALEEJIQMMDAsgAkEANgIAIAdBAWohAUHAACEDDAsLQQELOgAsIAJBADYCACAGQQFqIQELQSkhAwwIC0E4IQMMBwsCQCABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBPiEDDCELQT4hAwwgCwsgAkEAOgAsDAELQQshAwwEC0E6IQMMAwsgAUEBaiEBQS0hAwwCCyACIAE6ACwgAkEANgIAIAZBAWohAUEMIQMMAQsgAkEANgIAIAZBAWohAUEKIQMMAAsAC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwXC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwWC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwVC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwUC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwTC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwSC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwRC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwQC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwPC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwOC0EAIQMgAkEANgIcIAIgATYCFCACQcASNgIQIAJBCzYCDAwNC0EAIQMgAkEANgIcIAIgATYCFCACQZUJNgIQIAJBCzYCDAwMC0EAIQMgAkEANgIcIAIgATYCFCACQeEPNgIQIAJBCjYCDAwLC0EAIQMgAkEANgIcIAIgATYCFCACQfsPNgIQIAJBCjYCDAwKC0EAIQMgAkEANgIcIAIgATYCFCACQfEZNgIQIAJBAjYCDAwJC0EAIQMgAkEANgIcIAIgATYCFCACQcQUNgIQIAJBAjYCDAwIC0EAIQMgAkEANgIcIAIgATYCFCACQfIVNgIQIAJBAjYCDAwHCyACQQI2AhwgAiABNgIUIAJBnBo2AhAgAkEWNgIMQQAhAwwGC0EBIQMMBQtB1AAhAyABIARGDQQgCEEIaiEJIAIoAgAhBQJAAkAgASAERwRAIAVB2MIAaiEHIAQgBWogAWshACAFQX9zQQpqIgUgAWohBgNAIAEtAAAgBy0AAEcEQEECIQcMAwsgBUUEQEEAIQcgBiEBDAMLIAVBAWshBSAHQQFqIQcgBCABQQFqIgFHDQALIAAhBSAEIQELIAlBATYCACACIAU2AgAMAQsgAkEANgIAIAkgBzYCAAsgCSABNgIEIAgoAgwhACAIKAIIDgMBBAIACwALIAJBADYCHCACQbUaNgIQIAJBFzYCDCACIABBAWo2AhRBACEDDAILIAJBADYCHCACIAA2AhQgAkHKGjYCECACQQk2AgxBACEDDAELIAEgBEYEQEEiIQMMAQsgAkEJNgIIIAIgATYCBEEhIQMLIAhBEGokACADRQRAIAIoAgwhAAwBCyACIAM2AhxBACEAIAIoAgQiAUUNACACIAEgBCACKAIIEQEAIgFFDQAgAiAENgIUIAIgATYCDCABIQALIAALvgIBAn8gAEEAOgAAIABB3ABqIgFBAWtBADoAACAAQQA6AAIgAEEAOgABIAFBA2tBADoAACABQQJrQQA6AAAgAEEAOgADIAFBBGtBADoAAEEAIABrQQNxIgEgAGoiAEEANgIAQdwAIAFrQXxxIgIgAGoiAUEEa0EANgIAAkAgAkEJSQ0AIABBADYCCCAAQQA2AgQgAUEIa0EANgIAIAFBDGtBADYCACACQRlJDQAgAEEANgIYIABBADYCFCAAQQA2AhAgAEEANgIMIAFBEGtBADYCACABQRRrQQA2AgAgAUEYa0EANgIAIAFBHGtBADYCACACIABBBHFBGHIiAmsiAUEgSQ0AIAAgAmohAANAIABCADcDGCAAQgA3AxAgAEIANwMIIABCADcDACAAQSBqIQAgAUEgayIBQR9LDQALCwtWAQF/AkAgACgCDA0AAkACQAJAAkAgAC0ALw4DAQADAgsgACgCOCIBRQ0AIAEoAiwiAUUNACAAIAERAAAiAQ0DC0EADwsACyAAQcMWNgIQQQ4hAQsgAQsaACAAKAIMRQRAIABB0Rs2AhAgAEEVNgIMCwsUACAAKAIMQRVGBEAgAEEANgIMCwsUACAAKAIMQRZGBEAgAEEANgIMCwsHACAAKAIMCwcAIAAoAhALCQAgACABNgIQCwcAIAAoAhQLFwAgAEEkTwRAAAsgAEECdEGgM2ooAgALFwAgAEEuTwRAAAsgAEECdEGwNGooAgALvwkBAX9B6yghAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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AAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==", "base64");
  return llhttp_simdWasm;
}
var constants$2;
var hasRequiredConstants$2;
function requireConstants$2() {
  if (hasRequiredConstants$2) return constants$2;
  hasRequiredConstants$2 = 1;
  const corsSafeListedMethods = ["GET", "HEAD", "POST"];
  const corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
  const nullBodyStatus = [101, 204, 205, 304];
  const redirectStatus = [301, 302, 303, 307, 308];
  const redirectStatusSet = new Set(redirectStatus);
  const badPorts = [
    "1",
    "7",
    "9",
    "11",
    "13",
    "15",
    "17",
    "19",
    "20",
    "21",
    "22",
    "23",
    "25",
    "37",
    "42",
    "43",
    "53",
    "69",
    "77",
    "79",
    "87",
    "95",
    "101",
    "102",
    "103",
    "104",
    "109",
    "110",
    "111",
    "113",
    "115",
    "117",
    "119",
    "123",
    "135",
    "137",
    "139",
    "143",
    "161",
    "179",
    "389",
    "427",
    "465",
    "512",
    "513",
    "514",
    "515",
    "526",
    "530",
    "531",
    "532",
    "540",
    "548",
    "554",
    "556",
    "563",
    "587",
    "601",
    "636",
    "989",
    "990",
    "993",
    "995",
    "1719",
    "1720",
    "1723",
    "2049",
    "3659",
    "4045",
    "4190",
    "5060",
    "5061",
    "6000",
    "6566",
    "6665",
    "6666",
    "6667",
    "6668",
    "6669",
    "6679",
    "6697",
    "10080"
  ];
  const badPortsSet = new Set(badPorts);
  const referrerPolicy = [
    "",
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url"
  ];
  const referrerPolicySet = new Set(referrerPolicy);
  const requestRedirect = ["follow", "manual", "error"];
  const safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
  const safeMethodsSet = new Set(safeMethods);
  const requestMode = ["navigate", "same-origin", "no-cors", "cors"];
  const requestCredentials = ["omit", "same-origin", "include"];
  const requestCache = [
    "default",
    "no-store",
    "reload",
    "no-cache",
    "force-cache",
    "only-if-cached"
  ];
  const requestBodyHeader = [
    "content-encoding",
    "content-language",
    "content-location",
    "content-type",
    // See https://github.com/nodejs/undici/issues/2021
    // 'Content-Length' is a forbidden header name, which is typically
    // removed in the Headers implementation. However, undici doesn't
    // filter out headers, so we add it here.
    "content-length"
  ];
  const requestDuplex = [
    "half"
  ];
  const forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
  const forbiddenMethodsSet = new Set(forbiddenMethods);
  const subresource = [
    "audio",
    "audioworklet",
    "font",
    "image",
    "manifest",
    "paintworklet",
    "script",
    "style",
    "track",
    "video",
    "xslt",
    ""
  ];
  const subresourceSet = new Set(subresource);
  constants$2 = {
    subresource,
    forbiddenMethods,
    requestBodyHeader,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    redirectStatus,
    corsSafeListedMethods,
    nullBodyStatus,
    safeMethods,
    badPorts,
    requestDuplex,
    subresourceSet,
    badPortsSet,
    redirectStatusSet,
    corsSafeListedMethodsSet,
    safeMethodsSet,
    forbiddenMethodsSet,
    referrerPolicySet
  };
  return constants$2;
}
var global$2;
var hasRequiredGlobal$1;
function requireGlobal$1() {
  if (hasRequiredGlobal$1) return global$2;
  hasRequiredGlobal$1 = 1;
  const globalOrigin = Symbol.for("undici.globalOrigin.1");
  function getGlobalOrigin() {
    return globalThis[globalOrigin];
  }
  function setGlobalOrigin(newOrigin) {
    if (newOrigin === void 0) {
      Object.defineProperty(globalThis, globalOrigin, {
        value: void 0,
        writable: true,
        enumerable: false,
        configurable: false
      });
      return;
    }
    const parsedURL = new URL(newOrigin);
    if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
      throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
    }
    Object.defineProperty(globalThis, globalOrigin, {
      value: parsedURL,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  global$2 = {
    getGlobalOrigin,
    setGlobalOrigin
  };
  return global$2;
}
var dataUrl;
var hasRequiredDataUrl;
function requireDataUrl() {
  if (hasRequiredDataUrl) return dataUrl;
  hasRequiredDataUrl = 1;
  const assert = require$$0$3;
  const encoder = new TextEncoder();
  const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/;
  const HTTP_WHITESPACE_REGEX = /[\u000A\u000D\u0009\u0020]/;
  const ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g;
  const HTTP_QUOTED_STRING_TOKENS = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
  function dataURLProcessor(dataURL) {
    assert(dataURL.protocol === "data:");
    let input = URLSerializer(dataURL, true);
    input = input.slice(5);
    const position = { position: 0 };
    let mimeType = collectASequenceOfCodePointsFast(
      ",",
      input,
      position
    );
    const mimeTypeLength = mimeType.length;
    mimeType = removeASCIIWhitespace(mimeType, true, true);
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    const encodedBody = input.slice(mimeTypeLength + 1);
    let body2 = stringPercentDecode(encodedBody);
    if (/;(\u0020){0,}base64$/i.test(mimeType)) {
      const stringBody = isomorphicDecode(body2);
      body2 = forgivingBase64(stringBody);
      if (body2 === "failure") {
        return "failure";
      }
      mimeType = mimeType.slice(0, -6);
      mimeType = mimeType.replace(/(\u0020)+$/, "");
      mimeType = mimeType.slice(0, -1);
    }
    if (mimeType.startsWith(";")) {
      mimeType = "text/plain" + mimeType;
    }
    let mimeTypeRecord = parseMIMEType(mimeType);
    if (mimeTypeRecord === "failure") {
      mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
    }
    return { mimeType: mimeTypeRecord, body: body2 };
  }
  function URLSerializer(url, excludeFragment = false) {
    if (!excludeFragment) {
      return url.href;
    }
    const href = url.href;
    const hashLength = url.hash.length;
    const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    if (!hashLength && href.endsWith("#")) {
      return serialized.slice(0, -1);
    }
    return serialized;
  }
  function collectASequenceOfCodePoints(condition, input, position) {
    let result = "";
    while (position.position < input.length && condition(input[position.position])) {
      result += input[position.position];
      position.position++;
    }
    return result;
  }
  function collectASequenceOfCodePointsFast(char, input, position) {
    const idx = input.indexOf(char, position.position);
    const start2 = position.position;
    if (idx === -1) {
      position.position = input.length;
      return input.slice(start2);
    }
    position.position = idx;
    return input.slice(start2, position.position);
  }
  function stringPercentDecode(input) {
    const bytes = encoder.encode(input);
    return percentDecode(bytes);
  }
  function isHexCharByte(byte) {
    return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
  }
  function hexByteToNumber(byte) {
    return (
      // 0-9
      byte >= 48 && byte <= 57 ? byte - 48 : (byte & 223) - 55
    );
  }
  function percentDecode(input) {
    const length = input.length;
    const output = new Uint8Array(length);
    let j = 0;
    for (let i = 0; i < length; ++i) {
      const byte = input[i];
      if (byte !== 37) {
        output[j++] = byte;
      } else if (byte === 37 && !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))) {
        output[j++] = 37;
      } else {
        output[j++] = hexByteToNumber(input[i + 1]) << 4 | hexByteToNumber(input[i + 2]);
        i += 2;
      }
    }
    return length === j ? output : output.subarray(0, j);
  }
  function parseMIMEType(input) {
    input = removeHTTPWhitespace(input, true, true);
    const position = { position: 0 };
    const type = collectASequenceOfCodePointsFast(
      "/",
      input,
      position
    );
    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
      return "failure";
    }
    if (position.position > input.length) {
      return "failure";
    }
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(
      ";",
      input,
      position
    );
    subtype = removeHTTPWhitespace(subtype, false, true);
    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
      return "failure";
    }
    const typeLowercase = type.toLowerCase();
    const subtypeLowercase = subtype.toLowerCase();
    const mimeType = {
      type: typeLowercase,
      subtype: subtypeLowercase,
      /** @type {Map<string, string>} */
      parameters: /* @__PURE__ */ new Map(),
      // https://mimesniff.spec.whatwg.org/#mime-type-essence
      essence: `${typeLowercase}/${subtypeLowercase}`
    };
    while (position.position < input.length) {
      position.position++;
      collectASequenceOfCodePoints(
        // https://fetch.spec.whatwg.org/#http-whitespace
        (char) => HTTP_WHITESPACE_REGEX.test(char),
        input,
        position
      );
      let parameterName = collectASequenceOfCodePoints(
        (char) => char !== ";" && char !== "=",
        input,
        position
      );
      parameterName = parameterName.toLowerCase();
      if (position.position < input.length) {
        if (input[position.position] === ";") {
          continue;
        }
        position.position++;
      }
      if (position.position > input.length) {
        break;
      }
      let parameterValue = null;
      if (input[position.position] === '"') {
        parameterValue = collectAnHTTPQuotedString(input, position, true);
        collectASequenceOfCodePointsFast(
          ";",
          input,
          position
        );
      } else {
        parameterValue = collectASequenceOfCodePointsFast(
          ";",
          input,
          position
        );
        parameterValue = removeHTTPWhitespace(parameterValue, false, true);
        if (parameterValue.length === 0) {
          continue;
        }
      }
      if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
        mimeType.parameters.set(parameterName, parameterValue);
      }
    }
    return mimeType;
  }
  function forgivingBase64(data) {
    data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, "");
    let dataLength = data.length;
    if (dataLength % 4 === 0) {
      if (data.charCodeAt(dataLength - 1) === 61) {
        --dataLength;
        if (data.charCodeAt(dataLength - 1) === 61) {
          --dataLength;
        }
      }
    }
    if (dataLength % 4 === 1) {
      return "failure";
    }
    if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {
      return "failure";
    }
    const buffer = Buffer.from(data, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  }
  function collectAnHTTPQuotedString(input, position, extractValue) {
    const positionStart = position.position;
    let value = "";
    assert(input[position.position] === '"');
    position.position++;
    while (true) {
      value += collectASequenceOfCodePoints(
        (char) => char !== '"' && char !== "\\",
        input,
        position
      );
      if (position.position >= input.length) {
        break;
      }
      const quoteOrBackslash = input[position.position];
      position.position++;
      if (quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position];
        position.position++;
      } else {
        assert(quoteOrBackslash === '"');
        break;
      }
    }
    if (extractValue) {
      return value;
    }
    return input.slice(positionStart, position.position);
  }
  function serializeAMimeType(mimeType) {
    assert(mimeType !== "failure");
    const { parameters, essence } = mimeType;
    let serialization = essence;
    for (let [name, value] of parameters.entries()) {
      serialization += ";";
      serialization += name;
      serialization += "=";
      if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
        value = value.replace(/(\\|")/g, "\\$1");
        value = '"' + value;
        value += '"';
      }
      serialization += value;
    }
    return serialization;
  }
  function isHTTPWhiteSpace(char) {
    return char === 13 || char === 10 || char === 9 || char === 32;
  }
  function removeHTTPWhitespace(str, leading = true, trailing = true) {
    return removeChars(str, leading, trailing, isHTTPWhiteSpace);
  }
  function isASCIIWhitespace(char) {
    return char === 13 || char === 10 || char === 9 || char === 12 || char === 32;
  }
  function removeASCIIWhitespace(str, leading = true, trailing = true) {
    return removeChars(str, leading, trailing, isASCIIWhitespace);
  }
  function removeChars(str, leading, trailing, predicate) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      while (lead < str.length && predicate(str.charCodeAt(lead))) lead++;
    }
    if (trailing) {
      while (trail > 0 && predicate(str.charCodeAt(trail))) trail--;
    }
    return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);
  }
  function isomorphicDecode(input) {
    const length = input.length;
    if ((2 << 15) - 1 > length) {
      return String.fromCharCode.apply(null, input);
    }
    let result = "";
    let i = 0;
    let addition = (2 << 15) - 1;
    while (i < length) {
      if (i + addition > length) {
        addition = length - i;
      }
      result += String.fromCharCode.apply(null, input.subarray(i, i += addition));
    }
    return result;
  }
  function minimizeSupportedMimeType(mimeType) {
    switch (mimeType.essence) {
      case "application/ecmascript":
      case "application/javascript":
      case "application/x-ecmascript":
      case "application/x-javascript":
      case "text/ecmascript":
      case "text/javascript":
      case "text/javascript1.0":
      case "text/javascript1.1":
      case "text/javascript1.2":
      case "text/javascript1.3":
      case "text/javascript1.4":
      case "text/javascript1.5":
      case "text/jscript":
      case "text/livescript":
      case "text/x-ecmascript":
      case "text/x-javascript":
        return "text/javascript";
      case "application/json":
      case "text/json":
        return "application/json";
      case "image/svg+xml":
        return "image/svg+xml";
      case "text/xml":
      case "application/xml":
        return "application/xml";
    }
    if (mimeType.subtype.endsWith("+json")) {
      return "application/json";
    }
    if (mimeType.subtype.endsWith("+xml")) {
      return "application/xml";
    }
    return "";
  }
  dataUrl = {
    dataURLProcessor,
    URLSerializer,
    collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast,
    stringPercentDecode,
    parseMIMEType,
    collectAnHTTPQuotedString,
    serializeAMimeType,
    removeChars,
    removeHTTPWhitespace,
    minimizeSupportedMimeType,
    HTTP_TOKEN_CODEPOINTS,
    isomorphicDecode
  };
  return dataUrl;
}
var webidl_1;
var hasRequiredWebidl;
function requireWebidl() {
  if (hasRequiredWebidl) return webidl_1;
  hasRequiredWebidl = 1;
  const { types: types2, inspect } = require$$0$5;
  const { toUSVString } = requireUtil$7();
  const webidl = {};
  webidl.converters = {};
  webidl.util = {};
  webidl.errors = {};
  webidl.errors.exception = function(message) {
    return new TypeError(`${message.header}: ${message.message}`);
  };
  webidl.errors.conversionFailed = function(context) {
    const plural = context.types.length === 1 ? "" : " one of";
    const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
    return webidl.errors.exception({
      header: context.prefix,
      message
    });
  };
  webidl.errors.invalidArgument = function(context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function(V, I, opts) {
    if (opts?.strict !== false) {
      if (!(V instanceof I)) {
        const err = new TypeError("Illegal invocation");
        err.code = "ERR_INVALID_THIS";
        throw err;
      }
    } else {
      if (V?.[Symbol.toStringTag] !== I.prototype[Symbol.toStringTag]) {
        const err = new TypeError("Illegal invocation");
        err.code = "ERR_INVALID_THIS";
        throw err;
      }
    }
  };
  webidl.argumentLengthCheck = function({ length }, min, ctx) {
    if (length < min) {
      throw webidl.errors.exception({
        message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
        header: ctx
      });
    }
  };
  webidl.illegalConstructor = function() {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.Type = function(V) {
    switch (typeof V) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object": {
        if (V === null) {
          return "Null";
        }
        return "Object";
      }
    }
  };
  webidl.util.ConvertToInt = function(V, bitLength, signedness, opts) {
    let upperBound2;
    let lowerBound2;
    if (bitLength === 64) {
      upperBound2 = Math.pow(2, 53) - 1;
      if (signedness === "unsigned") {
        lowerBound2 = 0;
      } else {
        lowerBound2 = Math.pow(-2, 53) + 1;
      }
    } else if (signedness === "unsigned") {
      lowerBound2 = 0;
      upperBound2 = Math.pow(2, bitLength) - 1;
    } else {
      lowerBound2 = Math.pow(-2, bitLength) - 1;
      upperBound2 = Math.pow(2, bitLength - 1) - 1;
    }
    let x = Number(V);
    if (x === 0) {
      x = 0;
    }
    if (opts?.enforceRange === true) {
      if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`
        });
      }
      x = webidl.util.IntegerPart(x);
      if (x < lowerBound2 || x > upperBound2) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${lowerBound2}-${upperBound2}, got ${x}.`
        });
      }
      return x;
    }
    if (!Number.isNaN(x) && opts?.clamp === true) {
      x = Math.min(Math.max(x, lowerBound2), upperBound2);
      if (Math.floor(x) % 2 === 0) {
        x = Math.floor(x);
      } else {
        x = Math.ceil(x);
      }
      return x;
    }
    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
      return 0;
    }
    x = webidl.util.IntegerPart(x);
    x = x % Math.pow(2, bitLength);
    if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
      return x - Math.pow(2, bitLength);
    }
    return x;
  };
  webidl.util.IntegerPart = function(n) {
    const r = Math.floor(Math.abs(n));
    if (n < 0) {
      return -1 * r;
    }
    return r;
  };
  webidl.util.Stringify = function(V) {
    const type = webidl.util.Type(V);
    switch (type) {
      case "Symbol":
        return `Symbol(${V.description})`;
      case "Object":
        return inspect(V);
      case "String":
        return `"${V}"`;
      default:
        return `${V}`;
    }
  };
  webidl.sequenceConverter = function(converter) {
    return (V, prefix, argument, Iterable) => {
      if (webidl.util.Type(V) !== "Object") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`
        });
      }
      const method = typeof Iterable === "function" ? Iterable() : V?.[Symbol.iterator]?.();
      const seq = [];
      let index = 0;
      if (method === void 0 || typeof method.next !== "function") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} is not iterable.`
        });
      }
      while (true) {
        const { done, value } = method.next();
        if (done) {
          break;
        }
        seq.push(converter(value, prefix, `${argument}[${index++}]`));
      }
      return seq;
    };
  };
  webidl.recordConverter = function(keyConverter, valueConverter) {
    return (O, prefix, argument) => {
      if (webidl.util.Type(O) !== "Object") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} ("${webidl.util.Type(O)}") is not an Object.`
        });
      }
      const result = {};
      if (!types2.isProxy(O)) {
        const keys2 = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)];
        for (const key of keys2) {
          const typedKey = keyConverter(key, prefix, argument);
          const typedValue = valueConverter(O[key], prefix, argument);
          result[typedKey] = typedValue;
        }
        return result;
      }
      const keys = Reflect.ownKeys(O);
      for (const key of keys) {
        const desc = Reflect.getOwnPropertyDescriptor(O, key);
        if (desc?.enumerable) {
          const typedKey = keyConverter(key, prefix, argument);
          const typedValue = valueConverter(O[key], prefix, argument);
          result[typedKey] = typedValue;
        }
      }
      return result;
    };
  };
  webidl.interfaceConverter = function(i) {
    return (V, prefix, argument, opts) => {
      if (opts?.strict !== false && !(V instanceof i)) {
        throw webidl.errors.exception({
          header: prefix,
          message: `Expected ${argument} ("${webidl.util.Stringify(V)}") to be an instance of ${i.name}.`
        });
      }
      return V;
    };
  };
  webidl.dictionaryConverter = function(converters) {
    return (dictionary, prefix, argument) => {
      const type = webidl.util.Type(dictionary);
      const dict = {};
      if (type === "Null" || type === "Undefined") {
        return dict;
      } else if (type !== "Object") {
        throw webidl.errors.exception({
          header: prefix,
          message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
        });
      }
      for (const options of converters) {
        const { key, defaultValue, required, converter } = options;
        if (required === true) {
          if (!Object.hasOwn(dictionary, key)) {
            throw webidl.errors.exception({
              header: prefix,
              message: `Missing required key "${key}".`
            });
          }
        }
        let value = dictionary[key];
        const hasDefault = Object.hasOwn(options, "defaultValue");
        if (hasDefault && value !== null) {
          value ??= defaultValue();
        }
        if (required || hasDefault || value !== void 0) {
          value = converter(value, prefix, `${argument}.${key}`);
          if (options.allowedValues && !options.allowedValues.includes(value)) {
            throw webidl.errors.exception({
              header: prefix,
              message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
            });
          }
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function(converter) {
    return (V, prefix, argument) => {
      if (V === null) {
        return V;
      }
      return converter(V, prefix, argument);
    };
  };
  webidl.converters.DOMString = function(V, prefix, argument, opts) {
    if (V === null && opts?.legacyNullToEmptyString) {
      return "";
    }
    if (typeof V === "symbol") {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} is a symbol, which cannot be converted to a DOMString.`
      });
    }
    return String(V);
  };
  webidl.converters.ByteString = function(V, prefix, argument) {
    const x = webidl.converters.DOMString(V, prefix, argument);
    for (let index = 0; index < x.length; index++) {
      if (x.charCodeAt(index) > 255) {
        throw new TypeError(
          `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
        );
      }
    }
    return x;
  };
  webidl.converters.USVString = toUSVString;
  webidl.converters.boolean = function(V) {
    const x = Boolean(V);
    return x;
  };
  webidl.converters.any = function(V) {
    return V;
  };
  webidl.converters["long long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 64, "signed", void 0, prefix, argument);
    return x;
  };
  webidl.converters["unsigned long long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 64, "unsigned", void 0, prefix, argument);
    return x;
  };
  webidl.converters["unsigned long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 32, "unsigned", void 0, prefix, argument);
    return x;
  };
  webidl.converters["unsigned short"] = function(V, prefix, argument, opts) {
    const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts, prefix, argument);
    return x;
  };
  webidl.converters.ArrayBuffer = function(V, prefix, argument, opts) {
    if (webidl.util.Type(V) !== "Object" || !types2.isAnyArrayBuffer(V)) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: ["ArrayBuffer"]
      });
    }
    if (opts?.allowShared === false && types2.isSharedArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.resizable || V.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters.TypedArray = function(V, T, prefix, name, opts) {
    if (webidl.util.Type(V) !== "Object" || !types2.isTypedArray(V) || V.constructor.name !== T.name) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${name} ("${webidl.util.Stringify(V)}")`,
        types: [T.name]
      });
    }
    if (opts?.allowShared === false && types2.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.buffer.resizable || V.buffer.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters.DataView = function(V, prefix, name, opts) {
    if (webidl.util.Type(V) !== "Object" || !types2.isDataView(V)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${name} is not a DataView.`
      });
    }
    if (opts?.allowShared === false && types2.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.buffer.resizable || V.buffer.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters.BufferSource = function(V, prefix, name, opts) {
    if (types2.isAnyArrayBuffer(V)) {
      return webidl.converters.ArrayBuffer(V, prefix, name, { ...opts, allowShared: false });
    }
    if (types2.isTypedArray(V)) {
      return webidl.converters.TypedArray(V, V.constructor, prefix, name, { ...opts, allowShared: false });
    }
    if (types2.isDataView(V)) {
      return webidl.converters.DataView(V, prefix, name, { ...opts, allowShared: false });
    }
    throw webidl.errors.conversionFailed({
      prefix,
      argument: `${name} ("${webidl.util.Stringify(V)}")`,
      types: ["BufferSource"]
    });
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
    webidl.converters.ByteString
  );
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
    webidl.converters["sequence<ByteString>"]
  );
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
    webidl.converters.ByteString,
    webidl.converters.ByteString
  );
  webidl_1 = {
    webidl
  };
  return webidl_1;
}
var util$6;
var hasRequiredUtil$6;
function requireUtil$6() {
  if (hasRequiredUtil$6) return util$6;
  hasRequiredUtil$6 = 1;
  const { Transform } = require$$0$4;
  const zlib = require$$1$2;
  const { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = requireConstants$2();
  const { getGlobalOrigin } = requireGlobal$1();
  const { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = requireDataUrl();
  const { performance: performance2 } = require$$5;
  const { isBlobLike, ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = requireUtil$7();
  const assert = require$$0$3;
  const { isUint8Array } = require$$8$1;
  const { webidl } = requireWebidl();
  let supportedHashes = [];
  let crypto;
  try {
    crypto = require("node:crypto");
    const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
    supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
  } catch {
  }
  function responseURL(response2) {
    const urlList = response2.urlList;
    const length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  }
  function responseLocationURL(response2, requestFragment) {
    if (!redirectStatusSet.has(response2.status)) {
      return null;
    }
    let location = response2.headersList.get("location", true);
    if (location !== null && isValidHeaderValue(location)) {
      if (!isValidEncodedURL(location)) {
        location = normalizeBinaryStringToUtf8(location);
      }
      location = new URL(location, responseURL(response2));
    }
    if (location && !location.hash) {
      location.hash = requestFragment;
    }
    return location;
  }
  function isValidEncodedURL(url) {
    for (let i = 0; i < url.length; ++i) {
      const code = url.charCodeAt(i);
      if (code > 126 || // Non-US-ASCII + DEL
      code < 32) {
        return false;
      }
    }
    return true;
  }
  function normalizeBinaryStringToUtf8(value) {
    return Buffer.from(value, "binary").toString("utf8");
  }
  function requestCurrentURL(request2) {
    return request2.urlList[request2.urlList.length - 1];
  }
  function requestBadPort(request2) {
    const url = requestCurrentURL(request2);
    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
      return "blocked";
    }
    return "allowed";
  }
  function isErrorLike(object) {
    return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
  }
  function isValidReasonPhrase(statusText) {
    for (let i = 0; i < statusText.length; ++i) {
      const c = statusText.charCodeAt(i);
      if (!(c === 9 || // HTAB
      c >= 32 && c <= 126 || // SP / VCHAR
      c >= 128 && c <= 255)) {
        return false;
      }
    }
    return true;
  }
  const isValidHeaderName = isValidHTTPToken;
  function isValidHeaderValue(potentialValue) {
    return (potentialValue[0] === "	" || potentialValue[0] === " " || potentialValue[potentialValue.length - 1] === "	" || potentialValue[potentialValue.length - 1] === " " || potentialValue.includes("\n") || potentialValue.includes("\r") || potentialValue.includes("\0")) === false;
  }
  function setRequestReferrerPolicyOnRedirect(request2, actualResponse) {
    const { headersList } = actualResponse;
    const policyHeader = (headersList.get("referrer-policy", true) ?? "").split(",");
    let policy = "";
    if (policyHeader.length > 0) {
      for (let i = policyHeader.length; i !== 0; i--) {
        const token = policyHeader[i - 1].trim();
        if (referrerPolicyTokens.has(token)) {
          policy = token;
          break;
        }
      }
    }
    if (policy !== "") {
      request2.referrerPolicy = policy;
    }
  }
  function crossOriginResourcePolicyCheck() {
    return "allowed";
  }
  function corsCheck() {
    return "success";
  }
  function TAOCheck() {
    return "success";
  }
  function appendFetchMetadata(httpRequest) {
    let header = null;
    header = httpRequest.mode;
    httpRequest.headersList.set("sec-fetch-mode", header, true);
  }
  function appendRequestOriginHeader(request2) {
    let serializedOrigin = request2.origin;
    if (serializedOrigin === "client") {
      return;
    }
    if (request2.responseTainting === "cors" || request2.mode === "websocket") {
      request2.headersList.append("origin", serializedOrigin, true);
    } else if (request2.method !== "GET" && request2.method !== "HEAD") {
      switch (request2.referrerPolicy) {
        case "no-referrer":
          serializedOrigin = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (request2.origin && urlHasHttpsScheme(request2.origin) && !urlHasHttpsScheme(requestCurrentURL(request2))) {
            serializedOrigin = null;
          }
          break;
        case "same-origin":
          if (!sameOrigin(request2, requestCurrentURL(request2))) {
            serializedOrigin = null;
          }
          break;
      }
      request2.headersList.append("origin", serializedOrigin, true);
    }
  }
  function coarsenTime(timestamp, crossOriginIsolatedCapability) {
    return timestamp;
  }
  function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
    if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {
      return {
        domainLookupStartTime: defaultStartTime,
        domainLookupEndTime: defaultStartTime,
        connectionStartTime: defaultStartTime,
        connectionEndTime: defaultStartTime,
        secureConnectionStartTime: defaultStartTime,
        ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol
      };
    }
    return {
      domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime),
      domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime),
      connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime),
      connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime),
      secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime),
      ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
    };
  }
  function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
    return coarsenTime(performance2.now());
  }
  function createOpaqueTimingInfo(timingInfo) {
    return {
      startTime: timingInfo.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: timingInfo.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function makePolicyContainer() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function clonePolicyContainer(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  }
  function determineRequestsReferrer(request2) {
    const policy = request2.referrerPolicy;
    assert(policy);
    let referrerSource = null;
    if (request2.referrer === "client") {
      const globalOrigin = getGlobalOrigin();
      if (!globalOrigin || globalOrigin.origin === "null") {
        return "no-referrer";
      }
      referrerSource = new URL(globalOrigin);
    } else if (request2.referrer instanceof URL) {
      referrerSource = request2.referrer;
    }
    let referrerURL = stripURLForReferrer(referrerSource);
    const referrerOrigin = stripURLForReferrer(referrerSource, true);
    if (referrerURL.toString().length > 4096) {
      referrerURL = referrerOrigin;
    }
    const areSameOrigin = sameOrigin(request2, referrerURL);
    const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request2.url);
    switch (policy) {
      case "origin":
        return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
      case "unsafe-url":
        return referrerURL;
      case "same-origin":
        return areSameOrigin ? referrerOrigin : "no-referrer";
      case "origin-when-cross-origin":
        return areSameOrigin ? referrerURL : referrerOrigin;
      case "strict-origin-when-cross-origin": {
        const currentURL = requestCurrentURL(request2);
        if (sameOrigin(referrerURL, currentURL)) {
          return referrerURL;
        }
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "strict-origin":
      // eslint-disable-line
      /**
         * 1. If referrerURL is a potentially trustworthy URL and
         * requestâs current URL is not a potentially trustworthy URL,
         * then return no referrer.
         * 2. Return referrerOrigin
        */
      case "no-referrer-when-downgrade":
      // eslint-disable-line
      /**
       * 1. If referrerURL is a potentially trustworthy URL and
       * requestâs current URL is not a potentially trustworthy URL,
       * then return no referrer.
       * 2. Return referrerOrigin
      */
      default:
        return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
    }
  }
  function stripURLForReferrer(url, originOnly) {
    assert(url instanceof URL);
    url = new URL(url);
    if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
      return "no-referrer";
    }
    url.username = "";
    url.password = "";
    url.hash = "";
    if (originOnly) {
      url.pathname = "";
      url.search = "";
    }
    return url;
  }
  function isURLPotentiallyTrustworthy(url) {
    if (!(url instanceof URL)) {
      return false;
    }
    if (url.href === "about:blank" || url.href === "about:srcdoc") {
      return true;
    }
    if (url.protocol === "data:") return true;
    if (url.protocol === "file:") return true;
    return isOriginPotentiallyTrustworthy(url.origin);
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null") return false;
      const originAsURL = new URL(origin);
      if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
        return true;
      }
      if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
        return true;
      }
      return false;
    }
  }
  function bytesMatch(bytes, metadataList) {
    if (crypto === void 0) {
      return true;
    }
    const parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata === "no metadata") {
      return true;
    }
    if (parsedMetadata.length === 0) {
      return true;
    }
    const strongest = getStrongestMetadata(parsedMetadata);
    const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
    for (const item of metadata) {
      const algorithm = item.algo;
      const expectedValue = item.hash;
      let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
      if (actualValue[actualValue.length - 1] === "=") {
        if (actualValue[actualValue.length - 2] === "=") {
          actualValue = actualValue.slice(0, -2);
        } else {
          actualValue = actualValue.slice(0, -1);
        }
      }
      if (compareBase64Mixed(actualValue, expectedValue)) {
        return true;
      }
    }
    return false;
  }
  const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  function parseMetadata(metadata) {
    const result = [];
    let empty = true;
    for (const token of metadata.split(" ")) {
      empty = false;
      const parsedToken = parseHashWithOptions.exec(token);
      if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
        continue;
      }
      const algorithm = parsedToken.groups.algo.toLowerCase();
      if (supportedHashes.includes(algorithm)) {
        result.push(parsedToken.groups);
      }
    }
    if (empty === true) {
      return "no metadata";
    }
    return result;
  }
  function getStrongestMetadata(metadataList) {
    let algorithm = metadataList[0].algo;
    if (algorithm[3] === "5") {
      return algorithm;
    }
    for (let i = 1; i < metadataList.length; ++i) {
      const metadata = metadataList[i];
      if (metadata.algo[3] === "5") {
        algorithm = "sha512";
        break;
      } else if (algorithm[3] === "3") {
        continue;
      } else if (metadata.algo[3] === "3") {
        algorithm = "sha384";
      }
    }
    return algorithm;
  }
  function filterMetadataListByAlgorithm(metadataList, algorithm) {
    if (metadataList.length === 1) {
      return metadataList;
    }
    let pos = 0;
    for (let i = 0; i < metadataList.length; ++i) {
      if (metadataList[i].algo === algorithm) {
        metadataList[pos++] = metadataList[i];
      }
    }
    metadataList.length = pos;
    return metadataList;
  }
  function compareBase64Mixed(actualValue, expectedValue) {
    if (actualValue.length !== expectedValue.length) {
      return false;
    }
    for (let i = 0; i < actualValue.length; ++i) {
      if (actualValue[i] !== expectedValue[i]) {
        if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
          continue;
        }
        return false;
      }
    }
    return true;
  }
  function tryUpgradeRequestToAPotentiallyTrustworthyURL(request2) {
  }
  function sameOrigin(A, B) {
    if (A.origin === B.origin && A.origin === "null") {
      return true;
    }
    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
      return true;
    }
    return false;
  }
  function createDeferredPromise() {
    let res;
    let rej;
    const promise = new Promise((resolve2, reject) => {
      res = resolve2;
      rej = reject;
    });
    return { promise, resolve: res, reject: rej };
  }
  function isAborted(fetchParams) {
    return fetchParams.controller.state === "aborted";
  }
  function isCancelled(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  }
  function normalizeMethod(method) {
    return normalizedMethodRecordsBase[method.toLowerCase()] ?? method;
  }
  function serializeJavascriptValueToJSONString(value) {
    const result = JSON.stringify(value);
    if (result === void 0) {
      throw new TypeError("Value is not JSON serializable");
    }
    assert(typeof result === "string");
    return result;
  }
  const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {
    class FastIterableIterator {
      /** @type {any} */
      #target;
      /** @type {'key' | 'value' | 'key+value'} */
      #kind;
      /** @type {number} */
      #index;
      /**
       * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object
       * @param {unknown} target
       * @param {'key' | 'value' | 'key+value'} kind
       */
      constructor(target, kind) {
        this.#target = target;
        this.#kind = kind;
        this.#index = 0;
      }
      next() {
        if (typeof this !== "object" || this === null || !(#target in this)) {
          throw new TypeError(
            `'next' called on an object that does not implement interface ${name} Iterator.`
          );
        }
        const index = this.#index;
        const values = this.#target[kInternalIterator];
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        const { [keyIndex]: key, [valueIndex]: value } = values[index];
        this.#index = index + 1;
        let result;
        switch (this.#kind) {
          case "key":
            result = key;
            break;
          case "value":
            result = value;
            break;
          case "key+value":
            result = [key, value];
            break;
        }
        return {
          value: result,
          done: false
        };
      }
    }
    delete FastIterableIterator.prototype.constructor;
    Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);
    Object.defineProperties(FastIterableIterator.prototype, {
      [Symbol.toStringTag]: {
        writable: false,
        enumerable: false,
        configurable: true,
        value: `${name} Iterator`
      },
      next: { writable: true, enumerable: true, configurable: true }
    });
    return function(target, kind) {
      return new FastIterableIterator(target, kind);
    };
  }
  function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {
    const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);
    const properties = {
      keys: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function keys() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "key");
        }
      },
      values: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function values() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "value");
        }
      },
      entries: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function entries() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "key+value");
        }
      },
      forEach: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function forEach(callbackfn, thisArg = globalThis) {
          webidl.brandCheck(this, object);
          webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);
          if (typeof callbackfn !== "function") {
            throw new TypeError(
              `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`
            );
          }
          for (const { 0: key, 1: value } of makeIterator(this, "key+value")) {
            callbackfn.call(thisArg, value, key, this);
          }
        }
      }
    };
    return Object.defineProperties(object.prototype, {
      ...properties,
      [Symbol.iterator]: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: properties.entries.value
      }
    });
  }
  async function fullyReadBody(body2, processBody, processBodyError, shouldClone) {
    const successSteps = processBody;
    const errorSteps = processBodyError;
    let reader;
    try {
      reader = body2.stream.getReader();
    } catch (e) {
      errorSteps(e);
      return;
    }
    try {
      successSteps(await readAllBytes(reader, shouldClone));
    } catch (e) {
      errorSteps(e);
    }
  }
  function isReadableStreamLike(stream) {
    return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
  }
  function readableStreamClose(controller) {
    try {
      controller.close();
      controller.byobRequest?.respond(0);
    } catch (err) {
      if (!err.message.includes("Controller is already closed") && !err.message.includes("ReadableStream is already closed")) {
        throw err;
      }
    }
  }
  const invalidIsomorphicEncodeValueRegex = /[^\x00-\xFF]/;
  function isomorphicEncode(input) {
    assert(!invalidIsomorphicEncodeValueRegex.test(input));
    return input;
  }
  async function readAllBytes(reader, shouldClone) {
    const bytes = [];
    let byteLength = 0;
    while (true) {
      const { done, value: chunk } = await reader.read();
      if (done) {
        if (bytes.length === 1) {
          const { buffer, byteOffset, byteLength: byteLength2 } = bytes[0];
          if (shouldClone === false) {
            return Buffer.from(buffer, byteOffset, byteLength2);
          }
          return Buffer.from(buffer.slice(byteOffset, byteOffset + byteLength2), 0, byteLength2);
        }
        return Buffer.concat(bytes, byteLength);
      }
      if (!isUint8Array(chunk)) {
        throw new TypeError("Received non-Uint8Array chunk");
      }
      bytes.push(chunk);
      byteLength += chunk.length;
    }
  }
  function urlIsLocal(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  }
  function urlHasHttpsScheme(url) {
    return typeof url === "string" && url[5] === ":" && url[0] === "h" && url[1] === "t" && url[2] === "t" && url[3] === "p" && url[4] === "s" || url.protocol === "https:";
  }
  function urlIsHttpHttpsScheme(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  }
  function simpleRangeHeaderValue(value, allowWhitespace) {
    const data = value;
    if (!data.startsWith("bytes")) {
      return "failure";
    }
    const position = { position: 5 };
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data,
        position
      );
    }
    if (data.charCodeAt(position.position) !== 61) {
      return "failure";
    }
    position.position++;
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data,
        position
      );
    }
    const rangeStart = collectASequenceOfCodePoints(
      (char) => {
        const code = char.charCodeAt(0);
        return code >= 48 && code <= 57;
      },
      data,
      position
    );
    const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data,
        position
      );
    }
    if (data.charCodeAt(position.position) !== 45) {
      return "failure";
    }
    position.position++;
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data,
        position
      );
    }
    const rangeEnd = collectASequenceOfCodePoints(
      (char) => {
        const code = char.charCodeAt(0);
        return code >= 48 && code <= 57;
      },
      data,
      position
    );
    const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;
    if (position.position < data.length) {
      return "failure";
    }
    if (rangeEndValue === null && rangeStartValue === null) {
      return "failure";
    }
    if (rangeStartValue > rangeEndValue) {
      return "failure";
    }
    return { rangeStartValue, rangeEndValue };
  }
  function buildContentRange(rangeStart, rangeEnd, fullLength) {
    let contentRange = "bytes ";
    contentRange += isomorphicEncode(`${rangeStart}`);
    contentRange += "-";
    contentRange += isomorphicEncode(`${rangeEnd}`);
    contentRange += "/";
    contentRange += isomorphicEncode(`${fullLength}`);
    return contentRange;
  }
  class InflateStream extends Transform {
    _transform(chunk, encoding2, callback) {
      if (!this._inflateStream) {
        if (chunk.length === 0) {
          callback();
          return;
        }
        this._inflateStream = (chunk[0] & 15) === 8 ? zlib.createInflate() : zlib.createInflateRaw();
        this._inflateStream.on("data", this.push.bind(this));
        this._inflateStream.on("end", () => this.push(null));
        this._inflateStream.on("error", (err) => this.destroy(err));
      }
      this._inflateStream.write(chunk, encoding2, callback);
    }
    _final(callback) {
      if (this._inflateStream) {
        this._inflateStream.end();
        this._inflateStream = null;
      }
      callback();
    }
  }
  function createInflate() {
    return new InflateStream();
  }
  function extractMimeType(headers2) {
    let charset = null;
    let essence = null;
    let mimeType = null;
    const values = getDecodeSplit("content-type", headers2);
    if (values === null) {
      return "failure";
    }
    for (const value of values) {
      const temporaryMimeType = parseMIMEType(value);
      if (temporaryMimeType === "failure" || temporaryMimeType.essence === "*/*") {
        continue;
      }
      mimeType = temporaryMimeType;
      if (mimeType.essence !== essence) {
        charset = null;
        if (mimeType.parameters.has("charset")) {
          charset = mimeType.parameters.get("charset");
        }
        essence = mimeType.essence;
      } else if (!mimeType.parameters.has("charset") && charset !== null) {
        mimeType.parameters.set("charset", charset);
      }
    }
    if (mimeType == null) {
      return "failure";
    }
    return mimeType;
  }
  function gettingDecodingSplitting(value) {
    const input = value;
    const position = { position: 0 };
    const values = [];
    let temporaryValue = "";
    while (position.position < input.length) {
      temporaryValue += collectASequenceOfCodePoints(
        (char) => char !== '"' && char !== ",",
        input,
        position
      );
      if (position.position < input.length) {
        if (input.charCodeAt(position.position) === 34) {
          temporaryValue += collectAnHTTPQuotedString(
            input,
            position
          );
          if (position.position < input.length) {
            continue;
          }
        } else {
          assert(input.charCodeAt(position.position) === 44);
          position.position++;
        }
      }
      temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 9 || char === 32);
      values.push(temporaryValue);
      temporaryValue = "";
    }
    return values;
  }
  function getDecodeSplit(name, list) {
    const value = list.get(name, true);
    if (value === null) {
      return null;
    }
    return gettingDecodingSplitting(value);
  }
  const textDecoder = new TextDecoder();
  function utf8DecodeBytes(buffer) {
    if (buffer.length === 0) {
      return "";
    }
    if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
      buffer = buffer.subarray(3);
    }
    const output = textDecoder.decode(buffer);
    return output;
  }
  class EnvironmentSettingsObjectBase {
    get baseUrl() {
      return getGlobalOrigin();
    }
    get origin() {
      return this.baseUrl?.origin;
    }
    policyContainer = makePolicyContainer();
  }
  class EnvironmentSettingsObject {
    settingsObject = new EnvironmentSettingsObjectBase();
  }
  const environmentSettingsObject = new EnvironmentSettingsObject();
  util$6 = {
    isAborted,
    isCancelled,
    isValidEncodedURL,
    createDeferredPromise,
    ReadableStreamFrom,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    clampAndCoarsenConnectionTimingInfo,
    coarsenedSharedCurrentTime,
    determineRequestsReferrer,
    makePolicyContainer,
    clonePolicyContainer,
    appendFetchMetadata,
    appendRequestOriginHeader,
    TAOCheck,
    corsCheck,
    crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken,
    requestBadPort,
    requestCurrentURL,
    responseURL,
    responseLocationURL,
    isBlobLike,
    isURLPotentiallyTrustworthy,
    isValidReasonPhrase,
    sameOrigin,
    normalizeMethod,
    serializeJavascriptValueToJSONString,
    iteratorMixin,
    createIterator,
    isValidHeaderName,
    isValidHeaderValue,
    isErrorLike,
    fullyReadBody,
    bytesMatch,
    isReadableStreamLike,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlHasHttpsScheme,
    urlIsHttpHttpsScheme,
    readAllBytes,
    simpleRangeHeaderValue,
    buildContentRange,
    parseMetadata,
    createInflate,
    extractMimeType,
    getDecodeSplit,
    utf8DecodeBytes,
    environmentSettingsObject
  };
  return util$6;
}
var symbols$3;
var hasRequiredSymbols$3;
function requireSymbols$3() {
  if (hasRequiredSymbols$3) return symbols$3;
  hasRequiredSymbols$3 = 1;
  symbols$3 = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kDispatcher: Symbol("dispatcher")
  };
  return symbols$3;
}
var file;
var hasRequiredFile;
function requireFile() {
  if (hasRequiredFile) return file;
  hasRequiredFile = 1;
  const { Blob: Blob2, File } = require$$0$2;
  const { kState } = requireSymbols$3();
  const { webidl } = requireWebidl();
  class FileLike {
    constructor(blobLike, fileName, options = {}) {
      const n = fileName;
      const t = options.type;
      const d = options.lastModified ?? Date.now();
      this[kState] = {
        blobLike,
        name: n,
        type: t,
        lastModified: d
      };
    }
    stream(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.stream(...args);
    }
    arrayBuffer(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.arrayBuffer(...args);
    }
    slice(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.slice(...args);
    }
    text(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.text(...args);
    }
    get size() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.size;
    }
    get type() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.type;
    }
    get name() {
      webidl.brandCheck(this, FileLike);
      return this[kState].name;
    }
    get lastModified() {
      webidl.brandCheck(this, FileLike);
      return this[kState].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  webidl.converters.Blob = webidl.interfaceConverter(Blob2);
  function isFileLike(object) {
    return object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
  }
  file = { FileLike, isFileLike };
  return file;
}
var formdata;
var hasRequiredFormdata;
function requireFormdata() {
  if (hasRequiredFormdata) return formdata;
  hasRequiredFormdata = 1;
  const { isBlobLike, iteratorMixin } = requireUtil$6();
  const { kState } = requireSymbols$3();
  const { kEnumerableProperty } = requireUtil$7();
  const { FileLike, isFileLike } = requireFile();
  const { webidl } = requireWebidl();
  const { File: NativeFile } = require$$0$2;
  const nodeUtil = require$$0$5;
  const File = globalThis.File ?? NativeFile;
  class FormData {
    constructor(form) {
      if (form !== void 0) {
        throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      }
      this[kState] = [];
    }
    append(name, value, filename = void 0) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.append";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError(
          "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
        );
      }
      name = webidl.converters.USVString(name, prefix, "name");
      value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, "value", { strict: false }) : webidl.converters.USVString(value, prefix, "value");
      filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, "filename") : void 0;
      const entry2 = makeEntry(name, value, filename);
      this[kState].push(entry2);
    }
    delete(name) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      this[kState] = this[kState].filter((entry2) => entry2.name !== name);
    }
    get(name) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.get";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      const idx = this[kState].findIndex((entry2) => entry2.name === name);
      if (idx === -1) {
        return null;
      }
      return this[kState][idx].value;
    }
    getAll(name) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.getAll";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      return this[kState].filter((entry2) => entry2.name === name).map((entry2) => entry2.value);
    }
    has(name) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.has";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      return this[kState].findIndex((entry2) => entry2.name === name) !== -1;
    }
    set(name, value, filename = void 0) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.set";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError(
          "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
        );
      }
      name = webidl.converters.USVString(name, prefix, "name");
      value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, "name", { strict: false }) : webidl.converters.USVString(value, prefix, "name");
      filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, "name") : void 0;
      const entry2 = makeEntry(name, value, filename);
      const idx = this[kState].findIndex((entry3) => entry3.name === name);
      if (idx !== -1) {
        this[kState] = [
          ...this[kState].slice(0, idx),
          entry2,
          ...this[kState].slice(idx + 1).filter((entry3) => entry3.name !== name)
        ];
      } else {
        this[kState].push(entry2);
      }
    }
    [nodeUtil.inspect.custom](depth, options) {
      const state = this[kState].reduce((a, b) => {
        if (a[b.name]) {
          if (Array.isArray(a[b.name])) {
            a[b.name].push(b.value);
          } else {
            a[b.name] = [a[b.name], b.value];
          }
        } else {
          a[b.name] = b.value;
        }
        return a;
      }, { __proto__: null });
      options.depth ??= depth;
      options.colors ??= true;
      const output = nodeUtil.formatWithOptions(options, state);
      return `FormData ${output.slice(output.indexOf("]") + 2)}`;
    }
  }
  iteratorMixin("FormData", FormData, kState, "name", "value");
  Object.defineProperties(FormData.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    getAll: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: true
    }
  });
  function makeEntry(name, value, filename) {
    if (typeof value === "string") ;
    else {
      if (!isFileLike(value)) {
        value = value instanceof Blob ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
      }
      if (filename !== void 0) {
        const options = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = value instanceof NativeFile ? new File([value], filename, options) : new FileLike(value, filename, options);
      }
    }
    return { name, value };
  }
  formdata = { FormData, makeEntry };
  return formdata;
}
var formdataParser;
var hasRequiredFormdataParser;
function requireFormdataParser() {
  if (hasRequiredFormdataParser) return formdataParser;
  hasRequiredFormdataParser = 1;
  const { isUSVString, bufferToLowerCasedHeaderName } = requireUtil$7();
  const { utf8DecodeBytes } = requireUtil$6();
  const { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = requireDataUrl();
  const { isFileLike } = requireFile();
  const { makeEntry } = requireFormdata();
  const assert = require$$0$3;
  const { File: NodeFile } = require$$0$2;
  const File = globalThis.File ?? NodeFile;
  const formDataNameBuffer = Buffer.from('form-data; name="');
  const filenameBuffer = Buffer.from("; filename");
  const dd = Buffer.from("--");
  const ddcrlf = Buffer.from("--\r\n");
  function isAsciiString(chars2) {
    for (let i = 0; i < chars2.length; ++i) {
      if ((chars2.charCodeAt(i) & -128) !== 0) {
        return false;
      }
    }
    return true;
  }
  function validateBoundary(boundary) {
    const length = boundary.length;
    if (length < 27 || length > 70) {
      return false;
    }
    for (let i = 0; i < length; ++i) {
      const cp = boundary.charCodeAt(i);
      if (!(cp >= 48 && cp <= 57 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 39 || cp === 45 || cp === 95)) {
        return false;
      }
    }
    return true;
  }
  function multipartFormDataParser(input, mimeType) {
    assert(mimeType !== "failure" && mimeType.essence === "multipart/form-data");
    const boundaryString = mimeType.parameters.get("boundary");
    if (boundaryString === void 0) {
      return "failure";
    }
    const boundary = Buffer.from(`--${boundaryString}`, "utf8");
    const entryList = [];
    const position = { position: 0 };
    if (input[0] === 13 && input[1] === 10) {
      position.position += 2;
    }
    while (true) {
      if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {
        position.position += boundary.length;
      } else {
        return "failure";
      }
      if (position.position === input.length - 2 && bufferStartsWith(input, dd, position) || position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position)) {
        return entryList;
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
        return "failure";
      }
      position.position += 2;
      const result = parseMultipartFormDataHeaders(input, position);
      if (result === "failure") {
        return "failure";
      }
      let { name, filename, contentType, encoding: encoding2 } = result;
      position.position += 2;
      let body2;
      {
        const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);
        if (boundaryIndex === -1) {
          return "failure";
        }
        body2 = input.subarray(position.position, boundaryIndex - 4);
        position.position += body2.length;
        if (encoding2 === "base64") {
          body2 = Buffer.from(body2.toString(), "base64");
        }
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
        return "failure";
      } else {
        position.position += 2;
      }
      let value;
      if (filename !== null) {
        contentType ??= "text/plain";
        if (!isAsciiString(contentType)) {
          contentType = "";
        }
        value = new File([body2], filename, { type: contentType });
      } else {
        value = utf8DecodeBytes(Buffer.from(body2));
      }
      assert(isUSVString(name));
      assert(typeof value === "string" && isUSVString(value) || isFileLike(value));
      entryList.push(makeEntry(name, value, filename));
    }
  }
  function parseMultipartFormDataHeaders(input, position) {
    let name = null;
    let filename = null;
    let contentType = null;
    let encoding2 = null;
    while (true) {
      if (input[position.position] === 13 && input[position.position + 1] === 10) {
        if (name === null) {
          return "failure";
        }
        return { name, filename, contentType, encoding: encoding2 };
      }
      let headerName = collectASequenceOfBytes(
        (char) => char !== 10 && char !== 13 && char !== 58,
        input,
        position
      );
      headerName = removeChars(headerName, true, true, (char) => char === 9 || char === 32);
      if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {
        return "failure";
      }
      if (input[position.position] !== 58) {
        return "failure";
      }
      position.position++;
      collectASequenceOfBytes(
        (char) => char === 32 || char === 9,
        input,
        position
      );
      switch (bufferToLowerCasedHeaderName(headerName)) {
        case "content-disposition": {
          name = filename = null;
          if (!bufferStartsWith(input, formDataNameBuffer, position)) {
            return "failure";
          }
          position.position += 17;
          name = parseMultipartFormDataName(input, position);
          if (name === null) {
            return "failure";
          }
          if (bufferStartsWith(input, filenameBuffer, position)) {
            let check = position.position + filenameBuffer.length;
            if (input[check] === 42) {
              position.position += 1;
              check += 1;
            }
            if (input[check] !== 61 || input[check + 1] !== 34) {
              return "failure";
            }
            position.position += 12;
            filename = parseMultipartFormDataName(input, position);
            if (filename === null) {
              return "failure";
            }
          }
          break;
        }
        case "content-type": {
          let headerValue = collectASequenceOfBytes(
            (char) => char !== 10 && char !== 13,
            input,
            position
          );
          headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
          contentType = isomorphicDecode(headerValue);
          break;
        }
        case "content-transfer-encoding": {
          let headerValue = collectASequenceOfBytes(
            (char) => char !== 10 && char !== 13,
            input,
            position
          );
          headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
          encoding2 = isomorphicDecode(headerValue);
          break;
        }
        default: {
          collectASequenceOfBytes(
            (char) => char !== 10 && char !== 13,
            input,
            position
          );
        }
      }
      if (input[position.position] !== 13 && input[position.position + 1] !== 10) {
        return "failure";
      } else {
        position.position += 2;
      }
    }
  }
  function parseMultipartFormDataName(input, position) {
    assert(input[position.position - 1] === 34);
    let name = collectASequenceOfBytes(
      (char) => char !== 10 && char !== 13 && char !== 34,
      input,
      position
    );
    if (input[position.position] !== 34) {
      return null;
    } else {
      position.position++;
    }
    name = new TextDecoder().decode(name).replace(/%0A/ig, "\n").replace(/%0D/ig, "\r").replace(/%22/g, '"');
    return name;
  }
  function collectASequenceOfBytes(condition, input, position) {
    let start2 = position.position;
    while (start2 < input.length && condition(input[start2])) {
      ++start2;
    }
    return input.subarray(position.position, position.position = start2);
  }
  function removeChars(buf, leading, trailing, predicate) {
    let lead = 0;
    let trail = buf.length - 1;
    if (leading) {
      while (lead < buf.length && predicate(buf[lead])) lead++;
    }
    {
      while (trail > 0 && predicate(buf[trail])) trail--;
    }
    return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);
  }
  function bufferStartsWith(buffer, start2, position) {
    if (buffer.length < start2.length) {
      return false;
    }
    for (let i = 0; i < start2.length; i++) {
      if (start2[i] !== buffer[position.position + i]) {
        return false;
      }
    }
    return true;
  }
  formdataParser = {
    multipartFormDataParser,
    validateBoundary
  };
  return formdataParser;
}
var body;
var hasRequiredBody;
function requireBody() {
  if (hasRequiredBody) return body;
  hasRequiredBody = 1;
  const util2 = requireUtil$7();
  const {
    ReadableStreamFrom,
    isBlobLike,
    isReadableStreamLike,
    readableStreamClose,
    createDeferredPromise,
    fullyReadBody,
    extractMimeType,
    utf8DecodeBytes
  } = requireUtil$6();
  const { FormData } = requireFormdata();
  const { kState } = requireSymbols$3();
  const { webidl } = requireWebidl();
  const { Blob: Blob2 } = require$$0$2;
  const assert = require$$0$3;
  const { isErrored } = requireUtil$7();
  const { isArrayBuffer } = require$$8$1;
  const { serializeAMimeType } = requireDataUrl();
  const { multipartFormDataParser } = requireFormdataParser();
  const textEncoder = new TextEncoder();
  function extractBody(object, keepalive = false) {
    let stream = null;
    if (object instanceof ReadableStream) {
      stream = object;
    } else if (isBlobLike(object)) {
      stream = object.stream();
    } else {
      stream = new ReadableStream({
        async pull(controller) {
          const buffer = typeof source === "string" ? textEncoder.encode(source) : source;
          if (buffer.byteLength) {
            controller.enqueue(buffer);
          }
          queueMicrotask(() => readableStreamClose(controller));
        },
        start() {
        },
        type: "bytes"
      });
    }
    assert(isReadableStreamLike(stream));
    let action2 = null;
    let source = null;
    let length = null;
    let type = null;
    if (typeof object === "string") {
      source = object;
      type = "text/plain;charset=UTF-8";
    } else if (object instanceof URLSearchParams) {
      source = object.toString();
      type = "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isArrayBuffer(object)) {
      source = new Uint8Array(object.slice());
    } else if (ArrayBuffer.isView(object)) {
      source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
    } else if (util2.isFormDataLike(object)) {
      const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, "0")}`;
      const prefix = `--${boundary}\r
Content-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */
      const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
      const blobParts = [];
      const rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = false;
      for (const [name, value] of object) {
        if (typeof value === "string") {
          const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
          blobParts.push(chunk2);
          length += chunk2.byteLength;
        } else {
          const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
          blobParts.push(chunk2, value, rn);
          if (typeof value.size === "number") {
            length += chunk2.byteLength + value.size + rn.byteLength;
          } else {
            hasUnknownSizeValue = true;
          }
        }
      }
      const chunk = textEncoder.encode(`--${boundary}--`);
      blobParts.push(chunk);
      length += chunk.byteLength;
      if (hasUnknownSizeValue) {
        length = null;
      }
      source = object;
      action2 = async function* () {
        for (const part of blobParts) {
          if (part.stream) {
            yield* part.stream();
          } else {
            yield part;
          }
        }
      };
      type = `multipart/form-data; boundary=${boundary}`;
    } else if (isBlobLike(object)) {
      source = object;
      length = object.size;
      if (object.type) {
        type = object.type;
      }
    } else if (typeof object[Symbol.asyncIterator] === "function") {
      if (keepalive) {
        throw new TypeError("keepalive");
      }
      if (util2.isDisturbed(object) || object.locked) {
        throw new TypeError(
          "Response body object should not be disturbed or locked"
        );
      }
      stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
    }
    if (typeof source === "string" || util2.isBuffer(source)) {
      length = Buffer.byteLength(source);
    }
    if (action2 != null) {
      let iterator;
      stream = new ReadableStream({
        async start() {
          iterator = action2(object)[Symbol.asyncIterator]();
        },
        async pull(controller) {
          const { value, done } = await iterator.next();
          if (done) {
            queueMicrotask(() => {
              controller.close();
              controller.byobRequest?.respond(0);
            });
          } else {
            if (!isErrored(stream)) {
              const buffer = new Uint8Array(value);
              if (buffer.byteLength) {
                controller.enqueue(buffer);
              }
            }
          }
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        },
        type: "bytes"
      });
    }
    const body2 = { stream, source, length };
    return [body2, type];
  }
  function safelyExtractBody(object, keepalive = false) {
    if (object instanceof ReadableStream) {
      assert(!util2.isDisturbed(object), "The body has already been consumed.");
      assert(!object.locked, "The stream is locked.");
    }
    return extractBody(object, keepalive);
  }
  function cloneBody(body2) {
    const [out1, out2] = body2.stream.tee();
    body2.stream = out1;
    return {
      stream: out2,
      length: body2.length,
      source: body2.source
    };
  }
  function throwIfAborted(state) {
    if (state.aborted) {
      throw new DOMException("The operation was aborted.", "AbortError");
    }
  }
  function bodyMixinMethods(instance) {
    const methods = {
      blob() {
        return consumeBody(this, (bytes) => {
          let mimeType = bodyMimeType(this);
          if (mimeType === null) {
            mimeType = "";
          } else if (mimeType) {
            mimeType = serializeAMimeType(mimeType);
          }
          return new Blob2([bytes], { type: mimeType });
        }, instance, false);
      },
      arrayBuffer() {
        return consumeBody(this, (bytes) => {
          return bytes.buffer;
        }, instance, true);
      },
      text() {
        return consumeBody(this, utf8DecodeBytes, instance, false);
      },
      json() {
        return consumeBody(this, parseJSONFromBytes, instance, false);
      },
      formData() {
        return consumeBody(this, (value) => {
          const mimeType = bodyMimeType(this);
          if (mimeType !== null) {
            switch (mimeType.essence) {
              case "multipart/form-data": {
                const parsed = multipartFormDataParser(value, mimeType);
                if (parsed === "failure") {
                  throw new TypeError("Failed to parse body as FormData.");
                }
                const fd = new FormData();
                fd[kState] = parsed;
                return fd;
              }
              case "application/x-www-form-urlencoded": {
                const entries = new URLSearchParams(value.toString());
                const fd = new FormData();
                for (const [name, value2] of entries) {
                  fd.append(name, value2);
                }
                return fd;
              }
            }
          }
          throw new TypeError(
            'Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".'
          );
        }, instance, false);
      },
      bytes() {
        return consumeBody(this, (bytes) => {
          return new Uint8Array(bytes.buffer, 0, bytes.byteLength);
        }, instance, true);
      }
    };
    return methods;
  }
  function mixinBody(prototype) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype));
  }
  async function consumeBody(object, convertBytesToJSValue, instance, shouldClone) {
    webidl.brandCheck(object, instance);
    if (bodyUnusable(object[kState].body)) {
      throw new TypeError("Body is unusable: Body has already been read");
    }
    throwIfAborted(object[kState]);
    const promise = createDeferredPromise();
    const errorSteps = (error) => promise.reject(error);
    const successSteps = (data) => {
      try {
        promise.resolve(convertBytesToJSValue(data));
      } catch (e) {
        errorSteps(e);
      }
    };
    if (object[kState].body == null) {
      successSteps(Buffer.allocUnsafe(0));
      return promise.promise;
    }
    await fullyReadBody(object[kState].body, successSteps, errorSteps, shouldClone);
    return promise.promise;
  }
  function bodyUnusable(body2) {
    return body2 != null && (body2.stream.locked || util2.isDisturbed(body2.stream));
  }
  function parseJSONFromBytes(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  }
  function bodyMimeType(requestOrResponse) {
    const headers2 = requestOrResponse[kState].headersList;
    const mimeType = extractMimeType(headers2);
    if (mimeType === "failure") {
      return null;
    }
    return mimeType;
  }
  body = {
    extractBody,
    safelyExtractBody,
    cloneBody,
    mixinBody
  };
  return body;
}
var clientH1;
var hasRequiredClientH1;
function requireClientH1() {
  if (hasRequiredClientH1) return clientH1;
  hasRequiredClientH1 = 1;
  const assert = require$$0$3;
  const util2 = requireUtil$7();
  const { channels } = requireDiagnostics();
  const timers2 = requireTimers();
  const {
    RequestContentLengthMismatchError,
    ResponseContentLengthMismatchError,
    RequestAbortedError,
    HeadersTimeoutError,
    HeadersOverflowError,
    SocketError,
    InformationalError,
    BodyTimeoutError,
    HTTPParserError,
    ResponseExceededMaxSizeError
  } = requireErrors();
  const {
    kUrl,
    kReset,
    kClient,
    kParser,
    kBlocking,
    kRunning,
    kPending,
    kSize,
    kWriting,
    kQueue,
    kNoRef,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kSocket,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kMaxRequests,
    kCounter,
    kMaxResponseSize,
    kOnError,
    kResume,
    kHTTPContext
  } = requireSymbols$4();
  const constants2 = requireConstants$3();
  const EMPTY_BUF = Buffer.alloc(0);
  const FastBuffer = Buffer[Symbol.species];
  const addListener = util2.addListener;
  const removeAllListeners = util2.removeAllListeners;
  let extractBody;
  async function lazyllhttp() {
    const llhttpWasmData = process.env.JEST_WORKER_ID ? requireLlhttpWasm() : void 0;
    let mod;
    try {
      mod = await WebAssembly.compile(requireLlhttp_simdWasm());
    } catch (e) {
      mod = await WebAssembly.compile(llhttpWasmData || requireLlhttpWasm());
    }
    return await WebAssembly.instantiate(mod, {
      env: {
        /* eslint-disable camelcase */
        wasm_on_url: (p, at, len) => {
          return 0;
        },
        wasm_on_status: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start2 = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start2, len)) || 0;
        },
        wasm_on_message_begin: (p) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onMessageBegin() || 0;
        },
        wasm_on_header_field: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start2 = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start2, len)) || 0;
        },
        wasm_on_header_value: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start2 = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start2, len)) || 0;
        },
        wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
        },
        wasm_on_body: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start2 = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start2, len)) || 0;
        },
        wasm_on_message_complete: (p) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onMessageComplete() || 0;
        }
        /* eslint-enable camelcase */
      }
    });
  }
  let llhttpInstance = null;
  let llhttpPromise = lazyllhttp();
  llhttpPromise.catch();
  let currentParser = null;
  let currentBufferRef = null;
  let currentBufferSize = 0;
  let currentBufferPtr = null;
  const TIMEOUT_HEADERS = 1;
  const TIMEOUT_BODY = 2;
  const TIMEOUT_IDLE = 3;
  class Parser {
    constructor(client2, socket, { exports: exports$1 }) {
      assert(Number.isFinite(client2[kMaxHeadersSize]) && client2[kMaxHeadersSize] > 0);
      this.llhttp = exports$1;
      this.ptr = this.llhttp.llhttp_alloc(constants2.TYPE.RESPONSE);
      this.client = client2;
      this.socket = socket;
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.statusCode = null;
      this.statusText = "";
      this.upgrade = false;
      this.headers = [];
      this.headersSize = 0;
      this.headersMaxSize = client2[kMaxHeadersSize];
      this.shouldKeepAlive = false;
      this.paused = false;
      this.resume = this.resume.bind(this);
      this.bytesRead = 0;
      this.keepAlive = "";
      this.contentLength = "";
      this.connection = "";
      this.maxResponseSize = client2[kMaxResponseSize];
    }
    setTimeout(value, type) {
      this.timeoutType = type;
      if (value !== this.timeoutValue) {
        timers2.clearTimeout(this.timeout);
        if (value) {
          this.timeout = timers2.setTimeout(onParserTimeout, value, this);
          if (this.timeout.unref) {
            this.timeout.unref();
          }
        } else {
          this.timeout = null;
        }
        this.timeoutValue = value;
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
    }
    resume() {
      if (this.socket.destroyed || !this.paused) {
        return;
      }
      assert(this.ptr != null);
      assert(currentParser == null);
      this.llhttp.llhttp_resume(this.ptr);
      assert(this.timeoutType === TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      this.paused = false;
      this.execute(this.socket.read() || EMPTY_BUF);
      this.readMore();
    }
    readMore() {
      while (!this.paused && this.ptr) {
        const chunk = this.socket.read();
        if (chunk === null) {
          break;
        }
        this.execute(chunk);
      }
    }
    execute(data) {
      assert(this.ptr != null);
      assert(currentParser == null);
      assert(!this.paused);
      const { socket, llhttp } = this;
      if (data.length > currentBufferSize) {
        if (currentBufferPtr) {
          llhttp.free(currentBufferPtr);
        }
        currentBufferSize = Math.ceil(data.length / 4096) * 4096;
        currentBufferPtr = llhttp.malloc(currentBufferSize);
      }
      new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
      try {
        let ret;
        try {
          currentBufferRef = data;
          currentParser = this;
          ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
        } catch (err) {
          throw err;
        } finally {
          currentParser = null;
          currentBufferRef = null;
        }
        const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
        if (ret === constants2.ERROR.PAUSED_UPGRADE) {
          this.onUpgrade(data.slice(offset));
        } else if (ret === constants2.ERROR.PAUSED) {
          this.paused = true;
          socket.unshift(data.slice(offset));
        } else if (ret !== constants2.ERROR.OK) {
          const ptr = llhttp.llhttp_get_error_reason(this.ptr);
          let message = "";
          if (ptr) {
            const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
            message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
          }
          throw new HTTPParserError(message, constants2.ERROR[ret], data.slice(offset));
        }
      } catch (err) {
        util2.destroy(socket, err);
      }
    }
    destroy() {
      assert(this.ptr != null);
      assert(currentParser == null);
      this.llhttp.llhttp_free(this.ptr);
      this.ptr = null;
      timers2.clearTimeout(this.timeout);
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.paused = false;
    }
    onStatus(buf) {
      this.statusText = buf.toString();
    }
    onMessageBegin() {
      const { socket, client: client2 } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request2 = client2[kQueue][client2[kRunningIdx]];
      if (!request2) {
        return -1;
      }
      request2.onResponseStarted();
    }
    onHeaderField(buf) {
      const len = this.headers.length;
      if ((len & 1) === 0) {
        this.headers.push(buf);
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      this.trackHeader(buf.length);
    }
    onHeaderValue(buf) {
      let len = this.headers.length;
      if ((len & 1) === 1) {
        this.headers.push(buf);
        len += 1;
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      const key = this.headers[len - 2];
      if (key.length === 10) {
        const headerName = util2.bufferToLowerCasedHeaderName(key);
        if (headerName === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (headerName === "connection") {
          this.connection += buf.toString();
        }
      } else if (key.length === 14 && util2.bufferToLowerCasedHeaderName(key) === "content-length") {
        this.contentLength += buf.toString();
      }
      this.trackHeader(buf.length);
    }
    trackHeader(len) {
      this.headersSize += len;
      if (this.headersSize >= this.headersMaxSize) {
        util2.destroy(this.socket, new HeadersOverflowError());
      }
    }
    onUpgrade(head) {
      const { upgrade, client: client2, socket, headers: headers2, statusCode } = this;
      assert(upgrade);
      const request2 = client2[kQueue][client2[kRunningIdx]];
      assert(request2);
      assert(!socket.destroyed);
      assert(socket === client2[kSocket]);
      assert(!this.paused);
      assert(request2.upgrade || request2.method === "CONNECT");
      this.statusCode = null;
      this.statusText = "";
      this.shouldKeepAlive = null;
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      socket.unshift(head);
      socket[kParser].destroy();
      socket[kParser] = null;
      socket[kClient] = null;
      socket[kError] = null;
      removeAllListeners(socket);
      client2[kSocket] = null;
      client2[kHTTPContext] = null;
      client2[kQueue][client2[kRunningIdx]++] = null;
      client2.emit("disconnect", client2[kUrl], [client2], new InformationalError("upgrade"));
      try {
        request2.onUpgrade(statusCode, headers2, socket);
      } catch (err) {
        util2.destroy(socket, err);
      }
      client2[kResume]();
    }
    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
      const { client: client2, socket, headers: headers2, statusText } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request2 = client2[kQueue][client2[kRunningIdx]];
      if (!request2) {
        return -1;
      }
      assert(!this.upgrade);
      assert(this.statusCode < 200);
      if (statusCode === 100) {
        util2.destroy(socket, new SocketError("bad response", util2.getSocketInfo(socket)));
        return -1;
      }
      if (upgrade && !request2.upgrade) {
        util2.destroy(socket, new SocketError("bad upgrade", util2.getSocketInfo(socket)));
        return -1;
      }
      assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
      this.statusCode = statusCode;
      this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
      request2.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
      if (this.statusCode >= 200) {
        const bodyTimeout = request2.bodyTimeout != null ? request2.bodyTimeout : client2[kBodyTimeout];
        this.setTimeout(bodyTimeout, TIMEOUT_BODY);
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      if (request2.method === "CONNECT") {
        assert(client2[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      if (upgrade) {
        assert(client2[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      if (this.shouldKeepAlive && client2[kPipelining]) {
        const keepAliveTimeout = this.keepAlive ? util2.parseKeepAliveTimeout(this.keepAlive) : null;
        if (keepAliveTimeout != null) {
          const timeout = Math.min(
            keepAliveTimeout - client2[kKeepAliveTimeoutThreshold],
            client2[kKeepAliveMaxTimeout]
          );
          if (timeout <= 0) {
            socket[kReset] = true;
          } else {
            client2[kKeepAliveTimeoutValue] = timeout;
          }
        } else {
          client2[kKeepAliveTimeoutValue] = client2[kKeepAliveDefaultTimeout];
        }
      } else {
        socket[kReset] = true;
      }
      const pause = request2.onHeaders(statusCode, headers2, this.resume, statusText) === false;
      if (request2.aborted) {
        return -1;
      }
      if (request2.method === "HEAD") {
        return 1;
      }
      if (statusCode < 200) {
        return 1;
      }
      if (socket[kBlocking]) {
        socket[kBlocking] = false;
        client2[kResume]();
      }
      return pause ? constants2.ERROR.PAUSED : 0;
    }
    onBody(buf) {
      const { client: client2, socket, statusCode, maxResponseSize } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request2 = client2[kQueue][client2[kRunningIdx]];
      assert(request2);
      assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      assert(statusCode >= 200);
      if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
        util2.destroy(socket, new ResponseExceededMaxSizeError());
        return -1;
      }
      this.bytesRead += buf.length;
      if (request2.onData(buf) === false) {
        return constants2.ERROR.PAUSED;
      }
    }
    onMessageComplete() {
      const { client: client2, socket, statusCode, upgrade, headers: headers2, contentLength, bytesRead, shouldKeepAlive } = this;
      if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
        return -1;
      }
      if (upgrade) {
        return;
      }
      const request2 = client2[kQueue][client2[kRunningIdx]];
      assert(request2);
      assert(statusCode >= 100);
      this.statusCode = null;
      this.statusText = "";
      this.bytesRead = 0;
      this.contentLength = "";
      this.keepAlive = "";
      this.connection = "";
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      if (statusCode < 200) {
        return;
      }
      if (request2.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
        util2.destroy(socket, new ResponseContentLengthMismatchError());
        return -1;
      }
      request2.onComplete(headers2);
      client2[kQueue][client2[kRunningIdx]++] = null;
      if (socket[kWriting]) {
        assert.strictEqual(client2[kRunning], 0);
        util2.destroy(socket, new InformationalError("reset"));
        return constants2.ERROR.PAUSED;
      } else if (!shouldKeepAlive) {
        util2.destroy(socket, new InformationalError("reset"));
        return constants2.ERROR.PAUSED;
      } else if (socket[kReset] && client2[kRunning] === 0) {
        util2.destroy(socket, new InformationalError("reset"));
        return constants2.ERROR.PAUSED;
      } else if (client2[kPipelining] == null || client2[kPipelining] === 1) {
        setImmediate(() => client2[kResume]());
      } else {
        client2[kResume]();
      }
    }
  }
  function onParserTimeout(parser) {
    const { socket, timeoutType, client: client2 } = parser;
    if (timeoutType === TIMEOUT_HEADERS) {
      if (!socket[kWriting] || socket.writableNeedDrain || client2[kRunning] > 1) {
        assert(!parser.paused, "cannot be paused while waiting for headers");
        util2.destroy(socket, new HeadersTimeoutError());
      }
    } else if (timeoutType === TIMEOUT_BODY) {
      if (!parser.paused) {
        util2.destroy(socket, new BodyTimeoutError());
      }
    } else if (timeoutType === TIMEOUT_IDLE) {
      assert(client2[kRunning] === 0 && client2[kKeepAliveTimeoutValue]);
      util2.destroy(socket, new InformationalError("socket idle timeout"));
    }
  }
  async function connectH1(client2, socket) {
    client2[kSocket] = socket;
    if (!llhttpInstance) {
      llhttpInstance = await llhttpPromise;
      llhttpPromise = null;
    }
    socket[kNoRef] = false;
    socket[kWriting] = false;
    socket[kReset] = false;
    socket[kBlocking] = false;
    socket[kParser] = new Parser(client2, socket, llhttpInstance);
    addListener(socket, "error", function(err) {
      const parser = this[kParser];
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      this[kError] = err;
      this[kClient][kOnError](err);
    });
    addListener(socket, "readable", function() {
      const parser = this[kParser];
      if (parser) {
        parser.readMore();
      }
    });
    addListener(socket, "end", function() {
      const parser = this[kParser];
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      util2.destroy(this, new SocketError("other side closed", util2.getSocketInfo(this)));
    });
    addListener(socket, "close", function() {
      const client3 = this[kClient];
      const parser = this[kParser];
      if (parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util2.getSocketInfo(this));
      client3[kSocket] = null;
      client3[kHTTPContext] = null;
      if (client3.destroyed) {
        assert(client3[kPending] === 0);
        const requests = client3[kQueue].splice(client3[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request2 = requests[i];
          util2.errorRequest(client3, request2, err);
        }
      } else if (client3[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request2 = client3[kQueue][client3[kRunningIdx]];
        client3[kQueue][client3[kRunningIdx]++] = null;
        util2.errorRequest(client3, request2, err);
      }
      client3[kPendingIdx] = client3[kRunningIdx];
      assert(client3[kRunning] === 0);
      client3.emit("disconnect", client3[kUrl], [client3], err);
      client3[kResume]();
    });
    let closed = false;
    socket.on("close", () => {
      closed = true;
    });
    return {
      version: "h1",
      defaultPipelining: 1,
      write(...args) {
        return writeH1(client2, ...args);
      },
      resume() {
        resumeH1(client2);
      },
      destroy(err, callback) {
        if (closed) {
          queueMicrotask(callback);
        } else {
          socket.destroy(err).on("close", callback);
        }
      },
      get destroyed() {
        return socket.destroyed;
      },
      busy(request2) {
        if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return true;
        }
        if (request2) {
          if (client2[kRunning] > 0 && !request2.idempotent) {
            return true;
          }
          if (client2[kRunning] > 0 && (request2.upgrade || request2.method === "CONNECT")) {
            return true;
          }
          if (client2[kRunning] > 0 && util2.bodyLength(request2.body) !== 0 && (util2.isStream(request2.body) || util2.isAsyncIterable(request2.body) || util2.isFormDataLike(request2.body))) {
            return true;
          }
        }
        return false;
      }
    };
  }
  function resumeH1(client2) {
    const socket = client2[kSocket];
    if (socket && !socket.destroyed) {
      if (client2[kSize] === 0) {
        if (!socket[kNoRef] && socket.unref) {
          socket.unref();
          socket[kNoRef] = true;
        }
      } else if (socket[kNoRef] && socket.ref) {
        socket.ref();
        socket[kNoRef] = false;
      }
      if (client2[kSize] === 0) {
        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
          socket[kParser].setTimeout(client2[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
        }
      } else if (client2[kRunning] > 0 && socket[kParser].statusCode < 200) {
        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
          const request2 = client2[kQueue][client2[kRunningIdx]];
          const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client2[kHeadersTimeout];
          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
        }
      }
    }
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function writeH1(client2, request2) {
    const { method, path: path2, host, upgrade, blocking, reset } = request2;
    let { body: body2, headers: headers2, contentLength } = request2;
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (util2.isFormDataLike(body2)) {
      if (!extractBody) {
        extractBody = requireBody().extractBody;
      }
      const [bodyStream, contentType] = extractBody(body2);
      if (request2.contentType == null) {
        headers2.push("content-type", contentType);
      }
      body2 = bodyStream.stream;
      contentLength = bodyStream.length;
    } else if (util2.isBlobLike(body2) && request2.contentType == null && body2.type) {
      headers2.push("content-type", body2.type);
    }
    if (body2 && typeof body2.read === "function") {
      body2.read(0);
    }
    const bodyLength = util2.bodyLength(body2);
    contentLength = bodyLength ?? contentLength;
    if (contentLength === null) {
      contentLength = request2.contentLength;
    }
    if (contentLength === 0 && !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request2.contentLength !== null && request2.contentLength !== contentLength) {
      if (client2[kStrictContentLength]) {
        util2.errorRequest(client2, request2, new RequestContentLengthMismatchError());
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError());
    }
    const socket = client2[kSocket];
    const abort = (err) => {
      if (request2.aborted || request2.completed) {
        return;
      }
      util2.errorRequest(client2, request2, err || new RequestAbortedError());
      util2.destroy(body2);
      util2.destroy(socket, new InformationalError("aborted"));
    };
    try {
      request2.onConnect(abort);
    } catch (err) {
      util2.errorRequest(client2, request2, err);
    }
    if (request2.aborted) {
      return false;
    }
    if (method === "HEAD") {
      socket[kReset] = true;
    }
    if (upgrade || method === "CONNECT") {
      socket[kReset] = true;
    }
    if (reset != null) {
      socket[kReset] = reset;
    }
    if (client2[kMaxRequests] && socket[kCounter]++ >= client2[kMaxRequests]) {
      socket[kReset] = true;
    }
    if (blocking) {
      socket[kBlocking] = true;
    }
    let header = `${method} ${path2} HTTP/1.1\r
`;
    if (typeof host === "string") {
      header += `host: ${host}\r
`;
    } else {
      header += client2[kHostHeader];
    }
    if (upgrade) {
      header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
    } else if (client2[kPipelining] && !socket[kReset]) {
      header += "connection: keep-alive\r\n";
    } else {
      header += "connection: close\r\n";
    }
    if (Array.isArray(headers2)) {
      for (let n = 0; n < headers2.length; n += 2) {
        const key = headers2[n + 0];
        const val = headers2[n + 1];
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            header += `${key}: ${val[i]}\r
`;
          }
        } else {
          header += `${key}: ${val}\r
`;
        }
      }
    }
    if (channels.sendHeaders.hasSubscribers) {
      channels.sendHeaders.publish({ request: request2, headers: header, socket });
    }
    if (!body2 || bodyLength === 0) {
      writeBuffer(abort, null, client2, request2, socket, contentLength, header, expectsPayload);
    } else if (util2.isBuffer(body2)) {
      writeBuffer(abort, body2, client2, request2, socket, contentLength, header, expectsPayload);
    } else if (util2.isBlobLike(body2)) {
      if (typeof body2.stream === "function") {
        writeIterable(abort, body2.stream(), client2, request2, socket, contentLength, header, expectsPayload);
      } else {
        writeBlob(abort, body2, client2, request2, socket, contentLength, header, expectsPayload);
      }
    } else if (util2.isStream(body2)) {
      writeStream(abort, body2, client2, request2, socket, contentLength, header, expectsPayload);
    } else if (util2.isIterable(body2)) {
      writeIterable(abort, body2, client2, request2, socket, contentLength, header, expectsPayload);
    } else {
      assert(false);
    }
    return true;
  }
  function writeStream(abort, body2, client2, request2, socket, contentLength, header, expectsPayload) {
    assert(contentLength !== 0 || client2[kRunning] === 0, "stream body cannot be pipelined");
    let finished = false;
    const writer = new AsyncWriter({ abort, socket, request: request2, contentLength, client: client2, expectsPayload, header });
    const onData = function(chunk) {
      if (finished) {
        return;
      }
      try {
        if (!writer.write(chunk) && this.pause) {
          this.pause();
        }
      } catch (err) {
        util2.destroy(this, err);
      }
    };
    const onDrain = function() {
      if (finished) {
        return;
      }
      if (body2.resume) {
        body2.resume();
      }
    };
    const onClose = function() {
      queueMicrotask(() => {
        body2.removeListener("error", onFinished);
      });
      if (!finished) {
        const err = new RequestAbortedError();
        queueMicrotask(() => onFinished(err));
      }
    };
    const onFinished = function(err) {
      if (finished) {
        return;
      }
      finished = true;
      assert(socket.destroyed || socket[kWriting] && client2[kRunning] <= 1);
      socket.off("drain", onDrain).off("error", onFinished);
      body2.removeListener("data", onData).removeListener("end", onFinished).removeListener("close", onClose);
      if (!err) {
        try {
          writer.end();
        } catch (er) {
          err = er;
        }
      }
      writer.destroy(err);
      if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
        util2.destroy(body2, err);
      } else {
        util2.destroy(body2);
      }
    };
    body2.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onClose);
    if (body2.resume) {
      body2.resume();
    }
    socket.on("drain", onDrain).on("error", onFinished);
    if (body2.errorEmitted ?? body2.errored) {
      setImmediate(() => onFinished(body2.errored));
    } else if (body2.endEmitted ?? body2.readableEnded) {
      setImmediate(() => onFinished(null));
    }
    if (body2.closeEmitted ?? body2.closed) {
      setImmediate(onClose);
    }
  }
  function writeBuffer(abort, body2, client2, request2, socket, contentLength, header, expectsPayload) {
    try {
      if (!body2) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "latin1");
        }
      } else if (util2.isBuffer(body2)) {
        assert(contentLength === body2.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(body2);
        socket.uncork();
        request2.onBodySent(body2);
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      }
      request2.onRequestSent();
      client2[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeBlob(abort, body2, client2, request2, socket, contentLength, header, expectsPayload) {
    assert(contentLength === body2.size, "blob body must have content length");
    try {
      if (contentLength != null && contentLength !== body2.size) {
        throw new RequestContentLengthMismatchError();
      }
      const buffer = Buffer.from(await body2.arrayBuffer());
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
      socket.write(buffer);
      socket.uncork();
      request2.onBodySent(buffer);
      request2.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      client2[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeIterable(abort, body2, client2, request2, socket, contentLength, header, expectsPayload) {
    assert(contentLength !== 0 || client2[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve2, reject) => {
      assert(callback === null);
      if (socket[kError]) {
        reject(socket[kError]);
      } else {
        callback = resolve2;
      }
    });
    socket.on("close", onDrain).on("drain", onDrain);
    const writer = new AsyncWriter({ abort, socket, request: request2, contentLength, client: client2, expectsPayload, header });
    try {
      for await (const chunk of body2) {
        if (socket[kError]) {
          throw socket[kError];
        }
        if (!writer.write(chunk)) {
          await waitForDrain();
        }
      }
      writer.end();
    } catch (err) {
      writer.destroy(err);
    } finally {
      socket.off("close", onDrain).off("drain", onDrain);
    }
  }
  class AsyncWriter {
    constructor({ abort, socket, request: request2, contentLength, client: client2, expectsPayload, header }) {
      this.socket = socket;
      this.request = request2;
      this.contentLength = contentLength;
      this.client = client2;
      this.bytesWritten = 0;
      this.expectsPayload = expectsPayload;
      this.header = header;
      this.abort = abort;
      socket[kWriting] = true;
    }
    write(chunk) {
      const { socket, request: request2, contentLength, client: client2, bytesWritten, expectsPayload, header } = this;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return false;
      }
      const len = Buffer.byteLength(chunk);
      if (!len) {
        return true;
      }
      if (contentLength !== null && bytesWritten + len > contentLength) {
        if (client2[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError();
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      socket.cork();
      if (bytesWritten === 0) {
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        if (contentLength === null) {
          socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
        } else {
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        }
      }
      if (contentLength === null) {
        socket.write(`\r
${len.toString(16)}\r
`, "latin1");
      }
      this.bytesWritten += len;
      const ret = socket.write(chunk);
      socket.uncork();
      request2.onBodySent(chunk);
      if (!ret) {
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
      }
      return ret;
    }
    end() {
      const { socket, contentLength, client: client2, bytesWritten, expectsPayload, header, request: request2 } = this;
      request2.onRequestSent();
      socket[kWriting] = false;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return;
      }
      if (bytesWritten === 0) {
        if (expectsPayload) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          socket.write(`${header}\r
`, "latin1");
        }
      } else if (contentLength === null) {
        socket.write("\r\n0\r\n\r\n", "latin1");
      }
      if (contentLength !== null && bytesWritten !== contentLength) {
        if (client2[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError();
        } else {
          process.emitWarning(new RequestContentLengthMismatchError());
        }
      }
      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
        if (socket[kParser].timeout.refresh) {
          socket[kParser].timeout.refresh();
        }
      }
      client2[kResume]();
    }
    destroy(err) {
      const { socket, client: client2, abort } = this;
      socket[kWriting] = false;
      if (err) {
        assert(client2[kRunning] <= 1, "pipeline should only contain this request");
        abort(err);
      }
    }
  }
  clientH1 = connectH1;
  return clientH1;
}
var clientH2;
var hasRequiredClientH2;
function requireClientH2() {
  if (hasRequiredClientH2) return clientH2;
  hasRequiredClientH2 = 1;
  const assert = require$$0$3;
  const { pipeline } = require$$0$4;
  const util2 = requireUtil$7();
  const {
    RequestContentLengthMismatchError,
    RequestAbortedError,
    SocketError,
    InformationalError
  } = requireErrors();
  const {
    kUrl,
    kReset,
    kClient,
    kRunning,
    kPending,
    kQueue,
    kPendingIdx,
    kRunningIdx,
    kError,
    kSocket,
    kStrictContentLength,
    kOnError,
    kMaxConcurrentStreams,
    kHTTP2Session,
    kResume
  } = requireSymbols$4();
  const kOpenStreams = Symbol("open streams");
  let h2ExperimentalWarned = false;
  let http2;
  try {
    http2 = require("node:http2");
  } catch {
    http2 = { constants: {} };
  }
  const {
    constants: {
      HTTP2_HEADER_AUTHORITY,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_SCHEME,
      HTTP2_HEADER_CONTENT_LENGTH,
      HTTP2_HEADER_EXPECT,
      HTTP2_HEADER_STATUS
    }
  } = http2;
  function parseH2Headers(headers2) {
    const result = [];
    for (const [name, value] of Object.entries(headers2)) {
      if (Array.isArray(value)) {
        for (const subvalue of value) {
          result.push(Buffer.from(name), Buffer.from(subvalue));
        }
      } else {
        result.push(Buffer.from(name), Buffer.from(value));
      }
    }
    return result;
  }
  async function connectH2(client2, socket) {
    client2[kSocket] = socket;
    if (!h2ExperimentalWarned) {
      h2ExperimentalWarned = true;
      process.emitWarning("H2 support is experimental, expect them to change at any time.", {
        code: "UNDICI-H2"
      });
    }
    const session = http2.connect(client2[kUrl], {
      createConnection: () => socket,
      peerMaxConcurrentStreams: client2[kMaxConcurrentStreams]
    });
    session[kOpenStreams] = 0;
    session[kClient] = client2;
    session[kSocket] = socket;
    util2.addListener(session, "error", onHttp2SessionError);
    util2.addListener(session, "frameError", onHttp2FrameError);
    util2.addListener(session, "end", onHttp2SessionEnd);
    util2.addListener(session, "goaway", onHTTP2GoAway);
    util2.addListener(session, "close", function() {
      const { [kClient]: client3 } = this;
      const { [kSocket]: socket2 } = client3;
      const err = this[kSocket][kError] || this[kError] || new SocketError("closed", util2.getSocketInfo(socket2));
      client3[kHTTP2Session] = null;
      if (client3.destroyed) {
        assert(client3[kPending] === 0);
        const requests = client3[kQueue].splice(client3[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request2 = requests[i];
          util2.errorRequest(client3, request2, err);
        }
      }
    });
    session.unref();
    client2[kHTTP2Session] = session;
    socket[kHTTP2Session] = session;
    util2.addListener(socket, "error", function(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kError] = err;
      this[kClient][kOnError](err);
    });
    util2.addListener(socket, "end", function() {
      util2.destroy(this, new SocketError("other side closed", util2.getSocketInfo(this)));
    });
    util2.addListener(socket, "close", function() {
      const err = this[kError] || new SocketError("closed", util2.getSocketInfo(this));
      client2[kSocket] = null;
      if (this[kHTTP2Session] != null) {
        this[kHTTP2Session].destroy(err);
      }
      client2[kPendingIdx] = client2[kRunningIdx];
      assert(client2[kRunning] === 0);
      client2.emit("disconnect", client2[kUrl], [client2], err);
      client2[kResume]();
    });
    let closed = false;
    socket.on("close", () => {
      closed = true;
    });
    return {
      version: "h2",
      defaultPipelining: Infinity,
      write(...args) {
        writeH2(client2, ...args);
      },
      resume() {
      },
      destroy(err, callback) {
        if (closed) {
          queueMicrotask(callback);
        } else {
          socket.destroy(err).on("close", callback);
        }
      },
      get destroyed() {
        return socket.destroyed;
      },
      busy() {
        return false;
      }
    };
  }
  function onHttp2SessionError(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    this[kSocket][kError] = err;
    this[kClient][kOnError](err);
  }
  function onHttp2FrameError(type, code, id) {
    if (id === 0) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      this[kSocket][kError] = err;
      this[kClient][kOnError](err);
    }
  }
  function onHttp2SessionEnd() {
    const err = new SocketError("other side closed", util2.getSocketInfo(this[kSocket]));
    this.destroy(err);
    util2.destroy(this[kSocket], err);
  }
  function onHTTP2GoAway(code) {
    const err = new RequestAbortedError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
    this[kSocket][kError] = err;
    this[kClient][kOnError](err);
    this.unref();
    util2.destroy(this[kSocket], err);
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function writeH2(client2, request2) {
    const session = client2[kHTTP2Session];
    const { body: body2, method, path: path2, host, upgrade, expectContinue, signal, headers: reqHeaders } = request2;
    if (upgrade) {
      util2.errorRequest(client2, request2, new Error("Upgrade not supported for H2"));
      return false;
    }
    if (request2.aborted) {
      return false;
    }
    const headers2 = {};
    for (let n = 0; n < reqHeaders.length; n += 2) {
      const key = reqHeaders[n + 0];
      const val = reqHeaders[n + 1];
      if (Array.isArray(val)) {
        for (let i = 0; i < val.length; i++) {
          if (headers2[key]) {
            headers2[key] += `,${val[i]}`;
          } else {
            headers2[key] = val[i];
          }
        }
      } else {
        headers2[key] = val;
      }
    }
    let stream;
    const { hostname, port } = client2[kUrl];
    headers2[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ""}`;
    headers2[HTTP2_HEADER_METHOD] = method;
    const abort = (err) => {
      if (request2.aborted || request2.completed) {
        return;
      }
      err = err || new RequestAbortedError();
      util2.errorRequest(client2, request2, err);
      if (stream != null) {
        util2.destroy(stream, err);
      }
      util2.destroy(body2, err);
    };
    try {
      request2.onConnect(abort);
    } catch (err) {
      util2.errorRequest(client2, request2, err);
    }
    if (method === "CONNECT") {
      session.ref();
      stream = session.request(headers2, { endStream: false, signal });
      if (stream.id && !stream.pending) {
        request2.onUpgrade(null, null, stream);
        ++session[kOpenStreams];
      } else {
        stream.once("ready", () => {
          request2.onUpgrade(null, null, stream);
          ++session[kOpenStreams];
        });
      }
      stream.once("close", () => {
        session[kOpenStreams] -= 1;
        if (session[kOpenStreams] === 0) session.unref();
      });
      return true;
    }
    headers2[HTTP2_HEADER_PATH] = path2;
    headers2[HTTP2_HEADER_SCHEME] = "https";
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body2 && typeof body2.read === "function") {
      body2.read(0);
    }
    let contentLength = util2.bodyLength(body2);
    if (contentLength == null) {
      contentLength = request2.contentLength;
    }
    if (contentLength === 0 || !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request2.contentLength != null && request2.contentLength !== contentLength) {
      if (client2[kStrictContentLength]) {
        util2.errorRequest(client2, request2, new RequestContentLengthMismatchError());
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError());
    }
    if (contentLength != null) {
      assert(body2, "no body must not have content length");
      headers2[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
    }
    session.ref();
    const shouldEndStream = method === "GET" || method === "HEAD" || body2 === null;
    if (expectContinue) {
      headers2[HTTP2_HEADER_EXPECT] = "100-continue";
      stream = session.request(headers2, { endStream: shouldEndStream, signal });
      stream.once("continue", writeBodyH2);
    } else {
      stream = session.request(headers2, {
        endStream: shouldEndStream,
        signal
      });
      writeBodyH2();
    }
    ++session[kOpenStreams];
    stream.once("response", (headers3) => {
      const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers3;
      request2.onResponseStarted();
      if (request2.aborted) {
        const err = new RequestAbortedError();
        util2.errorRequest(client2, request2, err);
        util2.destroy(stream, err);
        return;
      }
      if (request2.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), "") === false) {
        stream.pause();
      }
      stream.on("data", (chunk) => {
        if (request2.onData(chunk) === false) {
          stream.pause();
        }
      });
    });
    stream.once("end", () => {
      if (stream.state?.state == null || stream.state.state < 6) {
        request2.onComplete([]);
        return;
      }
      if (session[kOpenStreams] === 0) {
        session.unref();
      }
      abort(new InformationalError("HTTP/2: stream half-closed (remote)"));
    });
    stream.once("close", () => {
      session[kOpenStreams] -= 1;
      if (session[kOpenStreams] === 0) {
        session.unref();
      }
    });
    stream.once("error", function(err) {
      abort(err);
    });
    stream.once("frameError", (type, code) => {
      abort(new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`));
    });
    return true;
    function writeBodyH2() {
      if (!body2 || contentLength === 0) {
        writeBuffer(
          abort,
          stream,
          null,
          client2,
          request2,
          client2[kSocket],
          contentLength,
          expectsPayload
        );
      } else if (util2.isBuffer(body2)) {
        writeBuffer(
          abort,
          stream,
          body2,
          client2,
          request2,
          client2[kSocket],
          contentLength,
          expectsPayload
        );
      } else if (util2.isBlobLike(body2)) {
        if (typeof body2.stream === "function") {
          writeIterable(
            abort,
            stream,
            body2.stream(),
            client2,
            request2,
            client2[kSocket],
            contentLength,
            expectsPayload
          );
        } else {
          writeBlob(
            abort,
            stream,
            body2,
            client2,
            request2,
            client2[kSocket],
            contentLength,
            expectsPayload
          );
        }
      } else if (util2.isStream(body2)) {
        writeStream(
          abort,
          client2[kSocket],
          expectsPayload,
          stream,
          body2,
          client2,
          request2,
          contentLength
        );
      } else if (util2.isIterable(body2)) {
        writeIterable(
          abort,
          stream,
          body2,
          client2,
          request2,
          client2[kSocket],
          contentLength,
          expectsPayload
        );
      } else {
        assert(false);
      }
    }
  }
  function writeBuffer(abort, h2stream, body2, client2, request2, socket, contentLength, expectsPayload) {
    try {
      if (body2 != null && util2.isBuffer(body2)) {
        assert(contentLength === body2.byteLength, "buffer body must have content length");
        h2stream.cork();
        h2stream.write(body2);
        h2stream.uncork();
        h2stream.end();
        request2.onBodySent(body2);
      }
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      request2.onRequestSent();
      client2[kResume]();
    } catch (error) {
      abort(error);
    }
  }
  function writeStream(abort, socket, expectsPayload, h2stream, body2, client2, request2, contentLength) {
    assert(contentLength !== 0 || client2[kRunning] === 0, "stream body cannot be pipelined");
    const pipe = pipeline(
      body2,
      h2stream,
      (err) => {
        if (err) {
          util2.destroy(pipe, err);
          abort(err);
        } else {
          util2.removeAllListeners(pipe);
          request2.onRequestSent();
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          client2[kResume]();
        }
      }
    );
    util2.addListener(pipe, "data", onPipeData);
    function onPipeData(chunk) {
      request2.onBodySent(chunk);
    }
  }
  async function writeBlob(abort, h2stream, body2, client2, request2, socket, contentLength, expectsPayload) {
    assert(contentLength === body2.size, "blob body must have content length");
    try {
      if (contentLength != null && contentLength !== body2.size) {
        throw new RequestContentLengthMismatchError();
      }
      const buffer = Buffer.from(await body2.arrayBuffer());
      h2stream.cork();
      h2stream.write(buffer);
      h2stream.uncork();
      h2stream.end();
      request2.onBodySent(buffer);
      request2.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      client2[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeIterable(abort, h2stream, body2, client2, request2, socket, contentLength, expectsPayload) {
    assert(contentLength !== 0 || client2[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve2, reject) => {
      assert(callback === null);
      if (socket[kError]) {
        reject(socket[kError]);
      } else {
        callback = resolve2;
      }
    });
    h2stream.on("close", onDrain).on("drain", onDrain);
    try {
      for await (const chunk of body2) {
        if (socket[kError]) {
          throw socket[kError];
        }
        const res = h2stream.write(chunk);
        request2.onBodySent(chunk);
        if (!res) {
          await waitForDrain();
        }
      }
      h2stream.end();
      request2.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      client2[kResume]();
    } catch (err) {
      abort(err);
    } finally {
      h2stream.off("close", onDrain).off("drain", onDrain);
    }
  }
  clientH2 = connectH2;
  return clientH2;
}
var redirectHandler;
var hasRequiredRedirectHandler;
function requireRedirectHandler() {
  if (hasRequiredRedirectHandler) return redirectHandler;
  hasRequiredRedirectHandler = 1;
  const util2 = requireUtil$7();
  const { kBodyUsed } = requireSymbols$4();
  const assert = require$$0$3;
  const { InvalidArgumentError } = requireErrors();
  const EE = require$$8;
  const redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
  const kBody = Symbol("body");
  class BodyAsyncIterable {
    constructor(body2) {
      this[kBody] = body2;
      this[kBodyUsed] = false;
    }
    async *[Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }
  class RedirectHandler {
    constructor(dispatch, maxRedirections, opts, handler2) {
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      util2.validateHandler(handler2, opts.method, opts.upgrade);
      this.dispatch = dispatch;
      this.location = null;
      this.abort = null;
      this.opts = { ...opts, maxRedirections: 0 };
      this.maxRedirections = maxRedirections;
      this.handler = handler2;
      this.history = [];
      this.redirectionLimitReached = false;
      if (util2.isStream(this.opts.body)) {
        if (util2.bodyLength(this.opts.body) === 0) {
          this.opts.body.on("data", function() {
            assert(false);
          });
        }
        if (typeof this.opts.body.readableDidRead !== "boolean") {
          this.opts.body[kBodyUsed] = false;
          EE.prototype.on.call(this.opts.body, "data", function() {
            this[kBodyUsed] = true;
          });
        }
      } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util2.isIterable(this.opts.body)) {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      }
    }
    onConnect(abort) {
      this.abort = abort;
      this.handler.onConnect(abort, { history: this.history });
    }
    onUpgrade(statusCode, headers2, socket) {
      this.handler.onUpgrade(statusCode, headers2, socket);
    }
    onError(error) {
      this.handler.onError(error);
    }
    onHeaders(statusCode, headers2, resume, statusText) {
      this.location = this.history.length >= this.maxRedirections || util2.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers2);
      if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
        if (this.request) {
          this.request.abort(new Error("max redirects"));
        }
        this.redirectionLimitReached = true;
        this.abort(new Error("max redirects"));
        return;
      }
      if (this.opts.origin) {
        this.history.push(new URL(this.opts.path, this.opts.origin));
      }
      if (!this.location) {
        return this.handler.onHeaders(statusCode, headers2, resume, statusText);
      }
      const { origin, pathname, search } = util2.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
      const path2 = search ? `${pathname}${search}` : pathname;
      this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
      this.opts.path = path2;
      this.opts.origin = origin;
      this.opts.maxRedirections = 0;
      this.opts.query = null;
      if (statusCode === 303 && this.opts.method !== "HEAD") {
        this.opts.method = "GET";
        this.opts.body = null;
      }
    }
    onData(chunk) {
      if (this.location) ;
      else {
        return this.handler.onData(chunk);
      }
    }
    onComplete(trailers) {
      if (this.location) {
        this.location = null;
        this.abort = null;
        this.dispatch(this.opts, this);
      } else {
        this.handler.onComplete(trailers);
      }
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent) {
        this.handler.onBodySent(chunk);
      }
    }
  }
  function parseLocation(statusCode, headers2) {
    if (redirectableStatusCodes.indexOf(statusCode) === -1) {
      return null;
    }
    for (let i = 0; i < headers2.length; i += 2) {
      if (headers2[i].length === 8 && util2.headerNameToString(headers2[i]) === "location") {
        return headers2[i + 1];
      }
    }
  }
  function shouldRemoveHeader(header, removeContent, unknownOrigin) {
    if (header.length === 4) {
      return util2.headerNameToString(header) === "host";
    }
    if (removeContent && util2.headerNameToString(header).startsWith("content-")) {
      return true;
    }
    if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
      const name = util2.headerNameToString(header);
      return name === "authorization" || name === "cookie" || name === "proxy-authorization";
    }
    return false;
  }
  function cleanRequestHeaders(headers2, removeContent, unknownOrigin) {
    const ret = [];
    if (Array.isArray(headers2)) {
      for (let i = 0; i < headers2.length; i += 2) {
        if (!shouldRemoveHeader(headers2[i], removeContent, unknownOrigin)) {
          ret.push(headers2[i], headers2[i + 1]);
        }
      }
    } else if (headers2 && typeof headers2 === "object") {
      for (const key of Object.keys(headers2)) {
        if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
          ret.push(key, headers2[key]);
        }
      }
    } else {
      assert(headers2 == null, "headers must be an object or an array");
    }
    return ret;
  }
  redirectHandler = RedirectHandler;
  return redirectHandler;
}
var redirectInterceptor;
var hasRequiredRedirectInterceptor;
function requireRedirectInterceptor() {
  if (hasRequiredRedirectInterceptor) return redirectInterceptor;
  hasRequiredRedirectInterceptor = 1;
  const RedirectHandler = requireRedirectHandler();
  function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
    return (dispatch) => {
      return function Intercept(opts, handler2) {
        const { maxRedirections = defaultMaxRedirections } = opts;
        if (!maxRedirections) {
          return dispatch(opts, handler2);
        }
        const redirectHandler2 = new RedirectHandler(dispatch, maxRedirections, opts, handler2);
        opts = { ...opts, maxRedirections: 0 };
        return dispatch(opts, redirectHandler2);
      };
    };
  }
  redirectInterceptor = createRedirectInterceptor;
  return redirectInterceptor;
}
var client;
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  const assert = require$$0$3;
  const net = require$$4;
  const http = require$$2;
  const util2 = requireUtil$7();
  const { channels } = requireDiagnostics();
  const Request2 = requireRequest$1();
  const DispatcherBase = requireDispatcherBase();
  const {
    InvalidArgumentError,
    InformationalError,
    ClientDestroyedError
  } = requireErrors();
  const buildConnector = requireConnect();
  const {
    kUrl,
    kServerName,
    kClient,
    kBusy,
    kConnect,
    kResuming,
    kRunning,
    kPending,
    kSize,
    kQueue,
    kConnected,
    kConnecting,
    kNeedDrain,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kConnector,
    kMaxRedirections,
    kMaxRequests,
    kCounter,
    kClose,
    kDestroy,
    kDispatch,
    kInterceptors,
    kLocalAddress,
    kMaxResponseSize,
    kOnError,
    kHTTPContext,
    kMaxConcurrentStreams,
    kResume
  } = requireSymbols$4();
  const connectH1 = requireClientH1();
  const connectH2 = requireClientH2();
  let deprecatedInterceptorWarned = false;
  const kClosedResolve = Symbol("kClosedResolve");
  function getPipelining(client2) {
    return client2[kPipelining] ?? client2[kHTTPContext]?.defaultPipelining ?? 1;
  }
  class Client2 extends DispatcherBase {
    /**
     *
     * @param {string|URL} url
     * @param {import('../../types/client.js').Client.Options} options
     */
    constructor(url, {
      interceptors,
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      connectTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls,
      strictContentLength,
      maxCachedSessions,
      maxRedirections,
      connect: connect3,
      maxRequestsPerClient,
      localAddress,
      maxResponseSize,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      // h2
      maxConcurrentStreams,
      allowH2
    } = {}) {
      super();
      if (keepAlive !== void 0) {
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      }
      if (socketTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (requestTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (idleTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      }
      if (maxKeepAliveTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      }
      if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
        throw new InvalidArgumentError("invalid maxHeaderSize");
      }
      if (socketPath != null && typeof socketPath !== "string") {
        throw new InvalidArgumentError("invalid socketPath");
      }
      if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
        throw new InvalidArgumentError("invalid connectTimeout");
      }
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      }
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      }
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      }
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      }
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      }
      if (connect3 != null && typeof connect3 !== "function" && typeof connect3 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
        throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
      }
      if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
        throw new InvalidArgumentError("localAddress must be valid string IP address");
      }
      if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
        throw new InvalidArgumentError("maxResponseSize must be a positive number");
      }
      if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
        throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
      }
      if (allowH2 != null && typeof allowH2 !== "boolean") {
        throw new InvalidArgumentError("allowH2 must be a valid boolean value");
      }
      if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
        throw new InvalidArgumentError("maxConcurrentStreams must be a positive integer, greater than 0");
      }
      if (typeof connect3 !== "function") {
        connect3 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
          ...connect3
        });
      }
      if (interceptors?.Client && Array.isArray(interceptors.Client)) {
        this[kInterceptors] = interceptors.Client;
        if (!deprecatedInterceptorWarned) {
          deprecatedInterceptorWarned = true;
          process.emitWarning("Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.", {
            code: "UNDICI-CLIENT-INTERCEPTOR-DEPRECATED"
          });
        }
      } else {
        this[kInterceptors] = [createRedirectInterceptor({ maxRedirections })];
      }
      this[kUrl] = util2.parseOrigin(url);
      this[kConnector] = connect3;
      this[kPipelining] = pipelining != null ? pipelining : 1;
      this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
      this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
      this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
      this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold;
      this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
      this[kServerName] = null;
      this[kLocalAddress] = localAddress != null ? localAddress : null;
      this[kResuming] = 0;
      this[kNeedDrain] = 0;
      this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
      this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
      this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
      this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
      this[kMaxRedirections] = maxRedirections;
      this[kMaxRequests] = maxRequestsPerClient;
      this[kClosedResolve] = null;
      this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
      this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100;
      this[kHTTPContext] = null;
      this[kQueue] = [];
      this[kRunningIdx] = 0;
      this[kPendingIdx] = 0;
      this[kResume] = (sync) => resume(this, sync);
      this[kOnError] = (err) => onError(this, err);
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value;
      this[kResume](true);
    }
    get [kPending]() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get [kRunning]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize]() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get [kConnected]() {
      return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
    }
    get [kBusy]() {
      return Boolean(
        this[kHTTPContext]?.busy(null) || this[kSize] >= (getPipelining(this) || 1) || this[kPending] > 0
      );
    }
    /* istanbul ignore: only used for test */
    [kConnect](cb) {
      connect2(this);
      this.once("connect", cb);
    }
    [kDispatch](opts, handler2) {
      const origin = opts.origin || this[kUrl].origin;
      const request2 = new Request2(origin, opts, handler2);
      this[kQueue].push(request2);
      if (this[kResuming]) ;
      else if (util2.bodyLength(request2.body) == null && util2.isIterable(request2.body)) {
        this[kResuming] = 1;
        queueMicrotask(() => resume(this));
      } else {
        this[kResume](true);
      }
      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
        this[kNeedDrain] = 2;
      }
      return this[kNeedDrain] < 2;
    }
    async [kClose]() {
      return new Promise((resolve2) => {
        if (this[kSize]) {
          this[kClosedResolve] = resolve2;
        } else {
          resolve2(null);
        }
      });
    }
    async [kDestroy](err) {
      return new Promise((resolve2) => {
        const requests = this[kQueue].splice(this[kPendingIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request2 = requests[i];
          util2.errorRequest(this, request2, err);
        }
        const callback = () => {
          if (this[kClosedResolve]) {
            this[kClosedResolve]();
            this[kClosedResolve] = null;
          }
          resolve2(null);
        };
        if (this[kHTTPContext]) {
          this[kHTTPContext].destroy(err, callback);
          this[kHTTPContext] = null;
        } else {
          queueMicrotask(callback);
        }
        this[kResume]();
      });
    }
  }
  const createRedirectInterceptor = requireRedirectInterceptor();
  function onError(client2, err) {
    if (client2[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client2[kPendingIdx] === client2[kRunningIdx]);
      const requests = client2[kQueue].splice(client2[kRunningIdx]);
      for (let i = 0; i < requests.length; i++) {
        const request2 = requests[i];
        util2.errorRequest(client2, request2, err);
      }
      assert(client2[kSize] === 0);
    }
  }
  async function connect2(client2) {
    assert(!client2[kConnecting]);
    assert(!client2[kHTTPContext]);
    let { host, hostname, protocol, port } = client2[kUrl];
    if (hostname[0] === "[") {
      const idx = hostname.indexOf("]");
      assert(idx !== -1);
      const ip = hostname.substring(1, idx);
      assert(net.isIP(ip));
      hostname = ip;
    }
    client2[kConnecting] = true;
    if (channels.beforeConnect.hasSubscribers) {
      channels.beforeConnect.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          version: client2[kHTTPContext]?.version,
          servername: client2[kServerName],
          localAddress: client2[kLocalAddress]
        },
        connector: client2[kConnector]
      });
    }
    try {
      const socket = await new Promise((resolve2, reject) => {
        client2[kConnector]({
          host,
          hostname,
          protocol,
          port,
          servername: client2[kServerName],
          localAddress: client2[kLocalAddress]
        }, (err, socket2) => {
          if (err) {
            reject(err);
          } else {
            resolve2(socket2);
          }
        });
      });
      if (client2.destroyed) {
        util2.destroy(socket.on("error", () => {
        }), new ClientDestroyedError());
        return;
      }
      assert(socket);
      try {
        client2[kHTTPContext] = socket.alpnProtocol === "h2" ? await connectH2(client2, socket) : await connectH1(client2, socket);
      } catch (err) {
        socket.destroy().on("error", () => {
        });
        throw err;
      }
      client2[kConnecting] = false;
      socket[kCounter] = 0;
      socket[kMaxRequests] = client2[kMaxRequests];
      socket[kClient] = client2;
      socket[kError] = null;
      if (channels.connected.hasSubscribers) {
        channels.connected.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            version: client2[kHTTPContext]?.version,
            servername: client2[kServerName],
            localAddress: client2[kLocalAddress]
          },
          connector: client2[kConnector],
          socket
        });
      }
      client2.emit("connect", client2[kUrl], [client2]);
    } catch (err) {
      if (client2.destroyed) {
        return;
      }
      client2[kConnecting] = false;
      if (channels.connectError.hasSubscribers) {
        channels.connectError.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            version: client2[kHTTPContext]?.version,
            servername: client2[kServerName],
            localAddress: client2[kLocalAddress]
          },
          connector: client2[kConnector],
          error: err
        });
      }
      if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
        assert(client2[kRunning] === 0);
        while (client2[kPending] > 0 && client2[kQueue][client2[kPendingIdx]].servername === client2[kServerName]) {
          const request2 = client2[kQueue][client2[kPendingIdx]++];
          util2.errorRequest(client2, request2, err);
        }
      } else {
        onError(client2, err);
      }
      client2.emit("connectionError", client2[kUrl], [client2], err);
    }
    client2[kResume]();
  }
  function emitDrain(client2) {
    client2[kNeedDrain] = 0;
    client2.emit("drain", client2[kUrl], [client2]);
  }
  function resume(client2, sync) {
    if (client2[kResuming] === 2) {
      return;
    }
    client2[kResuming] = 2;
    _resume(client2, sync);
    client2[kResuming] = 0;
    if (client2[kRunningIdx] > 256) {
      client2[kQueue].splice(0, client2[kRunningIdx]);
      client2[kPendingIdx] -= client2[kRunningIdx];
      client2[kRunningIdx] = 0;
    }
  }
  function _resume(client2, sync) {
    while (true) {
      if (client2.destroyed) {
        assert(client2[kPending] === 0);
        return;
      }
      if (client2[kClosedResolve] && !client2[kSize]) {
        client2[kClosedResolve]();
        client2[kClosedResolve] = null;
        return;
      }
      if (client2[kHTTPContext]) {
        client2[kHTTPContext].resume();
      }
      if (client2[kBusy]) {
        client2[kNeedDrain] = 2;
      } else if (client2[kNeedDrain] === 2) {
        if (sync) {
          client2[kNeedDrain] = 1;
          queueMicrotask(() => emitDrain(client2));
        } else {
          emitDrain(client2);
        }
        continue;
      }
      if (client2[kPending] === 0) {
        return;
      }
      if (client2[kRunning] >= (getPipelining(client2) || 1)) {
        return;
      }
      const request2 = client2[kQueue][client2[kPendingIdx]];
      if (client2[kUrl].protocol === "https:" && client2[kServerName] !== request2.servername) {
        if (client2[kRunning] > 0) {
          return;
        }
        client2[kServerName] = request2.servername;
        client2[kHTTPContext]?.destroy(new InformationalError("servername changed"), () => {
          client2[kHTTPContext] = null;
          resume(client2);
        });
      }
      if (client2[kConnecting]) {
        return;
      }
      if (!client2[kHTTPContext]) {
        connect2(client2);
        return;
      }
      if (client2[kHTTPContext].destroyed) {
        return;
      }
      if (client2[kHTTPContext].busy(request2)) {
        return;
      }
      if (!request2.aborted && client2[kHTTPContext].write(request2)) {
        client2[kPendingIdx]++;
      } else {
        client2[kQueue].splice(client2[kPendingIdx], 1);
      }
    }
  }
  client = Client2;
  return client;
}
var fixedQueue;
var hasRequiredFixedQueue;
function requireFixedQueue() {
  if (hasRequiredFixedQueue) return fixedQueue;
  hasRequiredFixedQueue = 1;
  const kSize = 2048;
  const kMask = kSize - 1;
  class FixedCircularBuffer {
    constructor() {
      this.bottom = 0;
      this.top = 0;
      this.list = new Array(kSize);
      this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
      this.list[this.top] = data;
      this.top = this.top + 1 & kMask;
    }
    shift() {
      const nextItem = this.list[this.bottom];
      if (nextItem === void 0)
        return null;
      this.list[this.bottom] = void 0;
      this.bottom = this.bottom + 1 & kMask;
      return nextItem;
    }
  }
  fixedQueue = class FixedQueue {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(data) {
      if (this.head.isFull()) {
        this.head = this.head.next = new FixedCircularBuffer();
      }
      this.head.push(data);
    }
    shift() {
      const tail = this.tail;
      const next = tail.shift();
      if (tail.isEmpty() && tail.next !== null) {
        this.tail = tail.next;
      }
      return next;
    }
  };
  return fixedQueue;
}
var poolStats;
var hasRequiredPoolStats;
function requirePoolStats() {
  if (hasRequiredPoolStats) return poolStats;
  hasRequiredPoolStats = 1;
  const { kFree, kConnected, kPending, kQueued, kRunning, kSize } = requireSymbols$4();
  const kPool = Symbol("pool");
  class PoolStats {
    constructor(pool2) {
      this[kPool] = pool2;
    }
    get connected() {
      return this[kPool][kConnected];
    }
    get free() {
      return this[kPool][kFree];
    }
    get pending() {
      return this[kPool][kPending];
    }
    get queued() {
      return this[kPool][kQueued];
    }
    get running() {
      return this[kPool][kRunning];
    }
    get size() {
      return this[kPool][kSize];
    }
  }
  poolStats = PoolStats;
  return poolStats;
}
var poolBase;
var hasRequiredPoolBase;
function requirePoolBase() {
  if (hasRequiredPoolBase) return poolBase;
  hasRequiredPoolBase = 1;
  const DispatcherBase = requireDispatcherBase();
  const FixedQueue = requireFixedQueue();
  const { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = requireSymbols$4();
  const PoolStats = requirePoolStats();
  const kClients = Symbol("clients");
  const kNeedDrain = Symbol("needDrain");
  const kQueue = Symbol("queue");
  const kClosedResolve = Symbol("closed resolve");
  const kOnDrain = Symbol("onDrain");
  const kOnConnect = Symbol("onConnect");
  const kOnDisconnect = Symbol("onDisconnect");
  const kOnConnectionError = Symbol("onConnectionError");
  const kGetDispatcher = Symbol("get dispatcher");
  const kAddClient = Symbol("add client");
  const kRemoveClient = Symbol("remove client");
  const kStats = Symbol("stats");
  class PoolBase extends DispatcherBase {
    constructor() {
      super();
      this[kQueue] = new FixedQueue();
      this[kClients] = [];
      this[kQueued] = 0;
      const pool2 = this;
      this[kOnDrain] = function onDrain(origin, targets) {
        const queue = pool2[kQueue];
        let needDrain = false;
        while (!needDrain) {
          const item = queue.shift();
          if (!item) {
            break;
          }
          pool2[kQueued]--;
          needDrain = !this.dispatch(item.opts, item.handler);
        }
        this[kNeedDrain] = needDrain;
        if (!this[kNeedDrain] && pool2[kNeedDrain]) {
          pool2[kNeedDrain] = false;
          pool2.emit("drain", origin, [pool2, ...targets]);
        }
        if (pool2[kClosedResolve] && queue.isEmpty()) {
          Promise.all(pool2[kClients].map((c) => c.close())).then(pool2[kClosedResolve]);
        }
      };
      this[kOnConnect] = (origin, targets) => {
        pool2.emit("connect", origin, [pool2, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        pool2.emit("disconnect", origin, [pool2, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        pool2.emit("connectionError", origin, [pool2, ...targets], err);
      };
      this[kStats] = new PoolStats(this);
    }
    get [kBusy]() {
      return this[kNeedDrain];
    }
    get [kConnected]() {
      return this[kClients].filter((client2) => client2[kConnected]).length;
    }
    get [kFree]() {
      return this[kClients].filter((client2) => client2[kConnected] && !client2[kNeedDrain]).length;
    }
    get [kPending]() {
      let ret = this[kQueued];
      for (const { [kPending]: pending } of this[kClients]) {
        ret += pending;
      }
      return ret;
    }
    get [kRunning]() {
      let ret = 0;
      for (const { [kRunning]: running } of this[kClients]) {
        ret += running;
      }
      return ret;
    }
    get [kSize]() {
      let ret = this[kQueued];
      for (const { [kSize]: size } of this[kClients]) {
        ret += size;
      }
      return ret;
    }
    get stats() {
      return this[kStats];
    }
    async [kClose]() {
      if (this[kQueue].isEmpty()) {
        return Promise.all(this[kClients].map((c) => c.close()));
      } else {
        return new Promise((resolve2) => {
          this[kClosedResolve] = resolve2;
        });
      }
    }
    async [kDestroy](err) {
      while (true) {
        const item = this[kQueue].shift();
        if (!item) {
          break;
        }
        item.handler.onError(err);
      }
      return Promise.all(this[kClients].map((c) => c.destroy(err)));
    }
    [kDispatch](opts, handler2) {
      const dispatcher2 = this[kGetDispatcher]();
      if (!dispatcher2) {
        this[kNeedDrain] = true;
        this[kQueue].push({ opts, handler: handler2 });
        this[kQueued]++;
      } else if (!dispatcher2.dispatch(opts, handler2)) {
        dispatcher2[kNeedDrain] = true;
        this[kNeedDrain] = !this[kGetDispatcher]();
      }
      return !this[kNeedDrain];
    }
    [kAddClient](client2) {
      client2.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
      this[kClients].push(client2);
      if (this[kNeedDrain]) {
        queueMicrotask(() => {
          if (this[kNeedDrain]) {
            this[kOnDrain](client2[kUrl], [this, client2]);
          }
        });
      }
      return this;
    }
    [kRemoveClient](client2) {
      client2.close(() => {
        const idx = this[kClients].indexOf(client2);
        if (idx !== -1) {
          this[kClients].splice(idx, 1);
        }
      });
      this[kNeedDrain] = this[kClients].some((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
    }
  }
  poolBase = {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  };
  return poolBase;
}
var pool;
var hasRequiredPool;
function requirePool() {
  if (hasRequiredPool) return pool;
  hasRequiredPool = 1;
  const {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kGetDispatcher
  } = requirePoolBase();
  const Client2 = requireClient();
  const {
    InvalidArgumentError
  } = requireErrors();
  const util2 = requireUtil$7();
  const { kUrl, kInterceptors } = requireSymbols$4();
  const buildConnector = requireConnect();
  const kOptions = Symbol("options");
  const kConnections = Symbol("connections");
  const kFactory = Symbol("factory");
  function defaultFactory(origin, opts) {
    return new Client2(origin, opts);
  }
  class Pool extends PoolBase {
    constructor(origin, {
      connections,
      factory = defaultFactory,
      connect: connect2,
      connectTimeout,
      tls,
      maxCachedSessions,
      socketPath,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      ...options
    } = {}) {
      super();
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (typeof connect2 !== "function") {
        connect2 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
          ...connect2
        });
      }
      this[kInterceptors] = options.interceptors?.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
      this[kConnections] = connections || null;
      this[kUrl] = util2.parseOrigin(origin);
      this[kOptions] = { ...util2.deepClone(options), connect: connect2, allowH2 };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
      this[kFactory] = factory;
    }
    [kGetDispatcher]() {
      for (const client2 of this[kClients]) {
        if (!client2[kNeedDrain]) {
          return client2;
        }
      }
      if (!this[kConnections] || this[kClients].length < this[kConnections]) {
        const dispatcher2 = this[kFactory](this[kUrl], this[kOptions]);
        this[kAddClient](dispatcher2);
        return dispatcher2;
      }
    }
  }
  pool = Pool;
  return pool;
}
var balancedPool;
var hasRequiredBalancedPool;
function requireBalancedPool() {
  if (hasRequiredBalancedPool) return balancedPool;
  hasRequiredBalancedPool = 1;
  const {
    BalancedPoolMissingUpstreamError,
    InvalidArgumentError
  } = requireErrors();
  const {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  } = requirePoolBase();
  const Pool = requirePool();
  const { kUrl, kInterceptors } = requireSymbols$4();
  const { parseOrigin } = requireUtil$7();
  const kFactory = Symbol("factory");
  const kOptions = Symbol("options");
  const kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
  const kCurrentWeight = Symbol("kCurrentWeight");
  const kIndex = Symbol("kIndex");
  const kWeight = Symbol("kWeight");
  const kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
  const kErrorPenalty = Symbol("kErrorPenalty");
  function getGreatestCommonDivisor(a, b) {
    if (b === 0) return a;
    return getGreatestCommonDivisor(b, a % b);
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }
  class BalancedPool extends PoolBase {
    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
      super();
      this[kOptions] = opts;
      this[kIndex] = -1;
      this[kCurrentWeight] = 0;
      this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
      this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
      if (!Array.isArray(upstreams)) {
        upstreams = [upstreams];
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      this[kInterceptors] = opts.interceptors?.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
      this[kFactory] = factory;
      for (const upstream of upstreams) {
        this.addUpstream(upstream);
      }
      this._updateBalancedPoolStats();
    }
    addUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      if (this[kClients].find((pool3) => pool3[kUrl].origin === upstreamOrigin && pool3.closed !== true && pool3.destroyed !== true)) {
        return this;
      }
      const pool2 = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
      this[kAddClient](pool2);
      pool2.on("connect", () => {
        pool2[kWeight] = Math.min(this[kMaxWeightPerServer], pool2[kWeight] + this[kErrorPenalty]);
      });
      pool2.on("connectionError", () => {
        pool2[kWeight] = Math.max(1, pool2[kWeight] - this[kErrorPenalty]);
        this._updateBalancedPoolStats();
      });
      pool2.on("disconnect", (...args) => {
        const err = args[2];
        if (err && err.code === "UND_ERR_SOCKET") {
          pool2[kWeight] = Math.max(1, pool2[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        }
      });
      for (const client2 of this[kClients]) {
        client2[kWeight] = this[kMaxWeightPerServer];
      }
      this._updateBalancedPoolStats();
      return this;
    }
    _updateBalancedPoolStats() {
      this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
    }
    removeUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      const pool2 = this[kClients].find((pool3) => pool3[kUrl].origin === upstreamOrigin && pool3.closed !== true && pool3.destroyed !== true);
      if (pool2) {
        this[kRemoveClient](pool2);
      }
      return this;
    }
    get upstreams() {
      return this[kClients].filter((dispatcher2) => dispatcher2.closed !== true && dispatcher2.destroyed !== true).map((p) => p[kUrl].origin);
    }
    [kGetDispatcher]() {
      if (this[kClients].length === 0) {
        throw new BalancedPoolMissingUpstreamError();
      }
      const dispatcher2 = this[kClients].find((dispatcher3) => !dispatcher3[kNeedDrain] && dispatcher3.closed !== true && dispatcher3.destroyed !== true);
      if (!dispatcher2) {
        return;
      }
      const allClientsBusy = this[kClients].map((pool2) => pool2[kNeedDrain]).reduce((a, b) => a && b, true);
      if (allClientsBusy) {
        return;
      }
      let counter = 0;
      let maxWeightIndex = this[kClients].findIndex((pool2) => !pool2[kNeedDrain]);
      while (counter++ < this[kClients].length) {
        this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
        const pool2 = this[kClients][this[kIndex]];
        if (pool2[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool2[kNeedDrain]) {
          maxWeightIndex = this[kIndex];
        }
        if (this[kIndex] === 0) {
          this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
          if (this[kCurrentWeight] <= 0) {
            this[kCurrentWeight] = this[kMaxWeightPerServer];
          }
        }
        if (pool2[kWeight] >= this[kCurrentWeight] && !pool2[kNeedDrain]) {
          return pool2;
        }
      }
      this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
      this[kIndex] = maxWeightIndex;
      return this[kClients][maxWeightIndex];
    }
  }
  balancedPool = BalancedPool;
  return balancedPool;
}
var agent$1;
var hasRequiredAgent;
function requireAgent() {
  if (hasRequiredAgent) return agent$1;
  hasRequiredAgent = 1;
  const { InvalidArgumentError } = requireErrors();
  const { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = requireSymbols$4();
  const DispatcherBase = requireDispatcherBase();
  const Pool = requirePool();
  const Client2 = requireClient();
  const util2 = requireUtil$7();
  const createRedirectInterceptor = requireRedirectInterceptor();
  const kOnConnect = Symbol("onConnect");
  const kOnDisconnect = Symbol("onDisconnect");
  const kOnConnectionError = Symbol("onConnectionError");
  const kMaxRedirections = Symbol("maxRedirections");
  const kOnDrain = Symbol("onDrain");
  const kFactory = Symbol("factory");
  const kOptions = Symbol("options");
  function defaultFactory(origin, opts) {
    return opts && opts.connections === 1 ? new Client2(origin, opts) : new Pool(origin, opts);
  }
  class Agent extends DispatcherBase {
    constructor({ factory = defaultFactory, maxRedirections = 0, connect: connect2, ...options } = {}) {
      super();
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (connect2 && typeof connect2 !== "function") {
        connect2 = { ...connect2 };
      }
      this[kInterceptors] = options.interceptors?.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
      this[kOptions] = { ...util2.deepClone(options), connect: connect2 };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
      this[kMaxRedirections] = maxRedirections;
      this[kFactory] = factory;
      this[kClients] = /* @__PURE__ */ new Map();
      this[kOnDrain] = (origin, targets) => {
        this.emit("drain", origin, [this, ...targets]);
      };
      this[kOnConnect] = (origin, targets) => {
        this.emit("connect", origin, [this, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        this.emit("disconnect", origin, [this, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        this.emit("connectionError", origin, [this, ...targets], err);
      };
    }
    get [kRunning]() {
      let ret = 0;
      for (const client2 of this[kClients].values()) {
        ret += client2[kRunning];
      }
      return ret;
    }
    [kDispatch](opts, handler2) {
      let key;
      if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
        key = String(opts.origin);
      } else {
        throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
      }
      let dispatcher2 = this[kClients].get(key);
      if (!dispatcher2) {
        dispatcher2 = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].set(key, dispatcher2);
      }
      return dispatcher2.dispatch(opts, handler2);
    }
    async [kClose]() {
      const closePromises = [];
      for (const client2 of this[kClients].values()) {
        closePromises.push(client2.close());
      }
      this[kClients].clear();
      await Promise.all(closePromises);
    }
    async [kDestroy](err) {
      const destroyPromises = [];
      for (const client2 of this[kClients].values()) {
        destroyPromises.push(client2.destroy(err));
      }
      this[kClients].clear();
      await Promise.all(destroyPromises);
    }
  }
  agent$1 = Agent;
  return agent$1;
}
var proxyAgent;
var hasRequiredProxyAgent;
function requireProxyAgent() {
  if (hasRequiredProxyAgent) return proxyAgent;
  hasRequiredProxyAgent = 1;
  const { kProxy, kClose, kDestroy, kInterceptors } = requireSymbols$4();
  const { URL: URL2 } = require$$1$3;
  const Agent = requireAgent();
  const Pool = requirePool();
  const DispatcherBase = requireDispatcherBase();
  const { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = requireErrors();
  const buildConnector = requireConnect();
  const kAgent = Symbol("proxy agent");
  const kClient = Symbol("proxy client");
  const kProxyHeaders = Symbol("proxy headers");
  const kRequestTls = Symbol("request tls settings");
  const kProxyTls = Symbol("proxy tls settings");
  const kConnectEndpoint = Symbol("connect endpoint function");
  function defaultProtocolPort(protocol) {
    return protocol === "https:" ? 443 : 80;
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }
  class ProxyAgent extends DispatcherBase {
    constructor(opts) {
      super();
      if (!opts || typeof opts === "object" && !(opts instanceof URL2) && !opts.uri) {
        throw new InvalidArgumentError("Proxy uri is mandatory");
      }
      const { clientFactory = defaultFactory } = opts;
      if (typeof clientFactory !== "function") {
        throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
      }
      const url = this.#getUrl(opts);
      const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url;
      this[kProxy] = { uri: href, protocol };
      this[kInterceptors] = opts.interceptors?.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
      this[kRequestTls] = opts.requestTls;
      this[kProxyTls] = opts.proxyTls;
      this[kProxyHeaders] = opts.headers || {};
      if (opts.auth && opts.token) {
        throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
      } else if (opts.auth) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
      } else if (opts.token) {
        this[kProxyHeaders]["proxy-authorization"] = opts.token;
      } else if (username && password) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
      }
      const connect2 = buildConnector({ ...opts.proxyTls });
      this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
      this[kClient] = clientFactory(url, { connect: connect2 });
      this[kAgent] = new Agent({
        ...opts,
        connect: async (opts2, callback) => {
          let requestedPath = opts2.host;
          if (!opts2.port) {
            requestedPath += `:${defaultProtocolPort(opts2.protocol)}`;
          }
          try {
            const { socket, statusCode } = await this[kClient].connect({
              origin,
              port,
              path: requestedPath,
              signal: opts2.signal,
              headers: {
                ...this[kProxyHeaders],
                host: opts2.host
              },
              servername: this[kProxyTls]?.servername || proxyHostname
            });
            if (statusCode !== 200) {
              socket.on("error", () => {
              }).destroy();
              callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
            }
            if (opts2.protocol !== "https:") {
              callback(null, socket);
              return;
            }
            let servername;
            if (this[kRequestTls]) {
              servername = this[kRequestTls].servername;
            } else {
              servername = opts2.servername;
            }
            this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
          } catch (err) {
            if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
              callback(new SecureProxyConnectionError(err));
            } else {
              callback(err);
            }
          }
        }
      });
    }
    dispatch(opts, handler2) {
      const headers2 = buildHeaders(opts.headers);
      throwIfProxyAuthIsSent(headers2);
      if (headers2 && !("host" in headers2) && !("Host" in headers2)) {
        const { host } = new URL2(opts.origin);
        headers2.host = host;
      }
      return this[kAgent].dispatch(
        {
          ...opts,
          headers: headers2
        },
        handler2
      );
    }
    /**
     * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts
     * @returns {URL}
     */
    #getUrl(opts) {
      if (typeof opts === "string") {
        return new URL2(opts);
      } else if (opts instanceof URL2) {
        return opts;
      } else {
        return new URL2(opts.uri);
      }
    }
    async [kClose]() {
      await this[kAgent].close();
      await this[kClient].close();
    }
    async [kDestroy]() {
      await this[kAgent].destroy();
      await this[kClient].destroy();
    }
  }
  function buildHeaders(headers2) {
    if (Array.isArray(headers2)) {
      const headersPair = {};
      for (let i = 0; i < headers2.length; i += 2) {
        headersPair[headers2[i]] = headers2[i + 1];
      }
      return headersPair;
    }
    return headers2;
  }
  function throwIfProxyAuthIsSent(headers2) {
    const existProxyAuth = headers2 && Object.keys(headers2).find((key) => key.toLowerCase() === "proxy-authorization");
    if (existProxyAuth) {
      throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
    }
  }
  proxyAgent = ProxyAgent;
  return proxyAgent;
}
var envHttpProxyAgent;
var hasRequiredEnvHttpProxyAgent;
function requireEnvHttpProxyAgent() {
  if (hasRequiredEnvHttpProxyAgent) return envHttpProxyAgent;
  hasRequiredEnvHttpProxyAgent = 1;
  const DispatcherBase = requireDispatcherBase();
  const { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = requireSymbols$4();
  const ProxyAgent = requireProxyAgent();
  const Agent = requireAgent();
  const DEFAULT_PORTS = {
    "http:": 80,
    "https:": 443
  };
  let experimentalWarned = false;
  class EnvHttpProxyAgent extends DispatcherBase {
    #noProxyValue = null;
    #noProxyEntries = null;
    #opts = null;
    constructor(opts = {}) {
      super();
      this.#opts = opts;
      if (!experimentalWarned) {
        experimentalWarned = true;
        process.emitWarning("EnvHttpProxyAgent is experimental, expect them to change at any time.", {
          code: "UNDICI-EHPA"
        });
      }
      const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts;
      this[kNoProxyAgent] = new Agent(agentOpts);
      const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
      if (HTTP_PROXY) {
        this[kHttpProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTP_PROXY });
      } else {
        this[kHttpProxyAgent] = this[kNoProxyAgent];
      }
      const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
      if (HTTPS_PROXY) {
        this[kHttpsProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTPS_PROXY });
      } else {
        this[kHttpsProxyAgent] = this[kHttpProxyAgent];
      }
      this.#parseNoProxy();
    }
    [kDispatch](opts, handler2) {
      const url = new URL(opts.origin);
      const agent2 = this.#getProxyAgentForUrl(url);
      return agent2.dispatch(opts, handler2);
    }
    async [kClose]() {
      await this[kNoProxyAgent].close();
      if (!this[kHttpProxyAgent][kClosed]) {
        await this[kHttpProxyAgent].close();
      }
      if (!this[kHttpsProxyAgent][kClosed]) {
        await this[kHttpsProxyAgent].close();
      }
    }
    async [kDestroy](err) {
      await this[kNoProxyAgent].destroy(err);
      if (!this[kHttpProxyAgent][kDestroyed]) {
        await this[kHttpProxyAgent].destroy(err);
      }
      if (!this[kHttpsProxyAgent][kDestroyed]) {
        await this[kHttpsProxyAgent].destroy(err);
      }
    }
    #getProxyAgentForUrl(url) {
      let { protocol, host: hostname, port } = url;
      hostname = hostname.replace(/:\d*$/, "").toLowerCase();
      port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0;
      if (!this.#shouldProxy(hostname, port)) {
        return this[kNoProxyAgent];
      }
      if (protocol === "https:") {
        return this[kHttpsProxyAgent];
      }
      return this[kHttpProxyAgent];
    }
    #shouldProxy(hostname, port) {
      if (this.#noProxyChanged) {
        this.#parseNoProxy();
      }
      if (this.#noProxyEntries.length === 0) {
        return true;
      }
      if (this.#noProxyValue === "*") {
        return false;
      }
      for (let i = 0; i < this.#noProxyEntries.length; i++) {
        const entry2 = this.#noProxyEntries[i];
        if (entry2.port && entry2.port !== port) {
          continue;
        }
        if (!/^[.*]/.test(entry2.hostname)) {
          if (hostname === entry2.hostname) {
            return false;
          }
        } else {
          if (hostname.endsWith(entry2.hostname.replace(/^\*/, ""))) {
            return false;
          }
        }
      }
      return true;
    }
    #parseNoProxy() {
      const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv;
      const noProxySplit = noProxyValue.split(/[,\s]/);
      const noProxyEntries = [];
      for (let i = 0; i < noProxySplit.length; i++) {
        const entry2 = noProxySplit[i];
        if (!entry2) {
          continue;
        }
        const parsed = entry2.match(/^(.+):(\d+)$/);
        noProxyEntries.push({
          hostname: (parsed ? parsed[1] : entry2).toLowerCase(),
          port: parsed ? Number.parseInt(parsed[2], 10) : 0
        });
      }
      this.#noProxyValue = noProxyValue;
      this.#noProxyEntries = noProxyEntries;
    }
    get #noProxyChanged() {
      if (this.#opts.noProxy !== void 0) {
        return false;
      }
      return this.#noProxyValue !== this.#noProxyEnv;
    }
    get #noProxyEnv() {
      return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
    }
  }
  envHttpProxyAgent = EnvHttpProxyAgent;
  return envHttpProxyAgent;
}
var retryHandler;
var hasRequiredRetryHandler;
function requireRetryHandler() {
  if (hasRequiredRetryHandler) return retryHandler;
  hasRequiredRetryHandler = 1;
  const assert = require$$0$3;
  const { kRetryHandlerDefaultRetry } = requireSymbols$4();
  const { RequestRetryError } = requireErrors();
  const {
    isDisturbed,
    parseHeaders: parseHeaders2,
    parseRangeHeader,
    wrapRequestBody
  } = requireUtil$7();
  function calculateRetryAfterHeader(retryAfter) {
    const current = Date.now();
    return new Date(retryAfter).getTime() - current;
  }
  class RetryHandler {
    constructor(opts, handlers) {
      const { retryOptions, ...dispatchOpts } = opts;
      const {
        // Retry scoped
        retry: retryFn,
        maxRetries,
        maxTimeout,
        minTimeout,
        timeoutFactor,
        // Response scoped
        methods,
        errorCodes,
        retryAfter,
        statusCodes
      } = retryOptions ?? {};
      this.dispatch = handlers.dispatch;
      this.handler = handlers.handler;
      this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) };
      this.abort = null;
      this.aborted = false;
      this.retryOpts = {
        retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
        retryAfter: retryAfter ?? true,
        maxTimeout: maxTimeout ?? 30 * 1e3,
        // 30s,
        minTimeout: minTimeout ?? 500,
        // .5s
        timeoutFactor: timeoutFactor ?? 2,
        maxRetries: maxRetries ?? 5,
        // What errors we should retry
        methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
        // Indicates which errors to retry
        statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
        // List of errors to retry
        errorCodes: errorCodes ?? [
          "ECONNRESET",
          "ECONNREFUSED",
          "ENOTFOUND",
          "ENETDOWN",
          "ENETUNREACH",
          "EHOSTDOWN",
          "EHOSTUNREACH",
          "EPIPE",
          "UND_ERR_SOCKET"
        ]
      };
      this.retryCount = 0;
      this.retryCountCheckpoint = 0;
      this.start = 0;
      this.end = null;
      this.etag = null;
      this.resume = null;
      this.handler.onConnect((reason) => {
        this.aborted = true;
        if (this.abort) {
          this.abort(reason);
        } else {
          this.reason = reason;
        }
      });
    }
    onRequestSent() {
      if (this.handler.onRequestSent) {
        this.handler.onRequestSent();
      }
    }
    onUpgrade(statusCode, headers2, socket) {
      if (this.handler.onUpgrade) {
        this.handler.onUpgrade(statusCode, headers2, socket);
      }
    }
    onConnect(abort) {
      if (this.aborted) {
        abort(this.reason);
      } else {
        this.abort = abort;
      }
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
    }
    static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
      const { statusCode, code, headers: headers2 } = err;
      const { method, retryOptions } = opts;
      const {
        maxRetries,
        minTimeout,
        maxTimeout,
        timeoutFactor,
        statusCodes,
        errorCodes,
        methods
      } = retryOptions;
      const { counter } = state;
      if (code && code !== "UND_ERR_REQ_RETRY" && !errorCodes.includes(code)) {
        cb(err);
        return;
      }
      if (Array.isArray(methods) && !methods.includes(method)) {
        cb(err);
        return;
      }
      if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
        cb(err);
        return;
      }
      if (counter > maxRetries) {
        cb(err);
        return;
      }
      let retryAfterHeader = headers2?.["retry-after"];
      if (retryAfterHeader) {
        retryAfterHeader = Number(retryAfterHeader);
        retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
      }
      const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);
      setTimeout(() => cb(null), retryTimeout);
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const headers2 = parseHeaders2(rawHeaders);
      this.retryCount += 1;
      if (statusCode >= 300) {
        if (this.retryOpts.statusCodes.includes(statusCode) === false) {
          return this.handler.onHeaders(
            statusCode,
            rawHeaders,
            resume,
            statusMessage
          );
        } else {
          this.abort(
            new RequestRetryError("Request failed", statusCode, {
              headers: headers2,
              data: {
                count: this.retryCount
              }
            })
          );
          return false;
        }
      }
      if (this.resume != null) {
        this.resume = null;
        if (statusCode !== 206) {
          return true;
        }
        const contentRange = parseRangeHeader(headers2["content-range"]);
        if (!contentRange) {
          this.abort(
            new RequestRetryError("Content-Range mismatch", statusCode, {
              headers: headers2,
              data: { count: this.retryCount }
            })
          );
          return false;
        }
        if (this.etag != null && this.etag !== headers2.etag) {
          this.abort(
            new RequestRetryError("ETag mismatch", statusCode, {
              headers: headers2,
              data: { count: this.retryCount }
            })
          );
          return false;
        }
        const { start: start2, size, end = size } = contentRange;
        assert(this.start === start2, "content-range mismatch");
        assert(this.end == null || this.end === end, "content-range mismatch");
        this.resume = resume;
        return true;
      }
      if (this.end == null) {
        if (statusCode === 206) {
          const range = parseRangeHeader(headers2["content-range"]);
          if (range == null) {
            return this.handler.onHeaders(
              statusCode,
              rawHeaders,
              resume,
              statusMessage
            );
          }
          const { start: start2, size, end = size } = range;
          assert(
            start2 != null && Number.isFinite(start2),
            "content-range mismatch"
          );
          assert(end != null && Number.isFinite(end), "invalid content-length");
          this.start = start2;
          this.end = end;
        }
        if (this.end == null) {
          const contentLength = headers2["content-length"];
          this.end = contentLength != null ? Number(contentLength) : null;
        }
        assert(Number.isFinite(this.start));
        assert(
          this.end == null || Number.isFinite(this.end),
          "invalid content-length"
        );
        this.resume = resume;
        this.etag = headers2.etag != null ? headers2.etag : null;
        if (this.etag != null && this.etag.startsWith("W/")) {
          this.etag = null;
        }
        return this.handler.onHeaders(
          statusCode,
          rawHeaders,
          resume,
          statusMessage
        );
      }
      const err = new RequestRetryError("Request failed", statusCode, {
        headers: headers2,
        data: { count: this.retryCount }
      });
      this.abort(err);
      return false;
    }
    onData(chunk) {
      this.start += chunk.length;
      return this.handler.onData(chunk);
    }
    onComplete(rawTrailers) {
      this.retryCount = 0;
      return this.handler.onComplete(rawTrailers);
    }
    onError(err) {
      if (this.aborted || isDisturbed(this.opts.body)) {
        return this.handler.onError(err);
      }
      if (this.retryCount - this.retryCountCheckpoint > 0) {
        this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);
      } else {
        this.retryCount += 1;
      }
      this.retryOpts.retry(
        err,
        {
          state: { counter: this.retryCount },
          opts: { retryOptions: this.retryOpts, ...this.opts }
        },
        onRetry.bind(this)
      );
      function onRetry(err2) {
        if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err2);
        }
        if (this.start !== 0) {
          const headers2 = { range: `bytes=${this.start}-${this.end ?? ""}` };
          if (this.etag != null) {
            headers2["if-match"] = this.etag;
          }
          this.opts = {
            ...this.opts,
            headers: {
              ...this.opts.headers,
              ...headers2
            }
          };
        }
        try {
          this.retryCountCheckpoint = this.retryCount;
          this.dispatch(this.opts, this);
        } catch (err3) {
          this.handler.onError(err3);
        }
      }
    }
  }
  retryHandler = RetryHandler;
  return retryHandler;
}
var retryAgent;
var hasRequiredRetryAgent;
function requireRetryAgent() {
  if (hasRequiredRetryAgent) return retryAgent;
  hasRequiredRetryAgent = 1;
  const Dispatcher = requireDispatcher();
  const RetryHandler = requireRetryHandler();
  class RetryAgent extends Dispatcher {
    #agent = null;
    #options = null;
    constructor(agent2, options = {}) {
      super(options);
      this.#agent = agent2;
      this.#options = options;
    }
    dispatch(opts, handler2) {
      const retry2 = new RetryHandler({
        ...opts,
        retryOptions: this.#options
      }, {
        dispatch: this.#agent.dispatch.bind(this.#agent),
        handler: handler2
      });
      return this.#agent.dispatch(opts, retry2);
    }
    close() {
      return this.#agent.close();
    }
    destroy() {
      return this.#agent.destroy();
    }
  }
  retryAgent = RetryAgent;
  return retryAgent;
}
var api = {};
var apiRequest = { exports: {} };
var readable;
var hasRequiredReadable;
function requireReadable() {
  if (hasRequiredReadable) return readable;
  hasRequiredReadable = 1;
  const assert = require$$0$3;
  const { Readable } = require$$0$4;
  const { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = requireErrors();
  const util2 = requireUtil$7();
  const { ReadableStreamFrom } = requireUtil$7();
  const kConsume = Symbol("kConsume");
  const kReading = Symbol("kReading");
  const kBody = Symbol("kBody");
  const kAbort = Symbol("kAbort");
  const kContentType = Symbol("kContentType");
  const kContentLength = Symbol("kContentLength");
  const noop = () => {
  };
  class BodyReadable extends Readable {
    constructor({
      resume,
      abort,
      contentType = "",
      contentLength,
      highWaterMark = 64 * 1024
      // Same as nodejs fs streams.
    }) {
      super({
        autoDestroy: true,
        read: resume,
        highWaterMark
      });
      this._readableState.dataEmitted = false;
      this[kAbort] = abort;
      this[kConsume] = null;
      this[kBody] = null;
      this[kContentType] = contentType;
      this[kContentLength] = contentLength;
      this[kReading] = false;
    }
    destroy(err) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError();
      }
      if (err) {
        this[kAbort]();
      }
      return super.destroy(err);
    }
    _destroy(err, callback) {
      if (!this[kReading]) {
        setImmediate(() => {
          callback(err);
        });
      } else {
        callback(err);
      }
    }
    on(ev, ...args) {
      if (ev === "data" || ev === "readable") {
        this[kReading] = true;
      }
      return super.on(ev, ...args);
    }
    addListener(ev, ...args) {
      return this.on(ev, ...args);
    }
    off(ev, ...args) {
      const ret = super.off(ev, ...args);
      if (ev === "data" || ev === "readable") {
        this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
      }
      return ret;
    }
    removeListener(ev, ...args) {
      return this.off(ev, ...args);
    }
    push(chunk) {
      if (this[kConsume] && chunk !== null) {
        consumePush(this[kConsume], chunk);
        return this[kReading] ? super.push(chunk) : true;
      }
      return super.push(chunk);
    }
    // https://fetch.spec.whatwg.org/#dom-body-text
    async text() {
      return consume(this, "text");
    }
    // https://fetch.spec.whatwg.org/#dom-body-json
    async json() {
      return consume(this, "json");
    }
    // https://fetch.spec.whatwg.org/#dom-body-blob
    async blob() {
      return consume(this, "blob");
    }
    // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
    async arrayBuffer() {
      return consume(this, "arrayBuffer");
    }
    // https://fetch.spec.whatwg.org/#dom-body-formdata
    async formData() {
      throw new NotSupportedError();
    }
    // https://fetch.spec.whatwg.org/#dom-body-bodyused
    get bodyUsed() {
      return util2.isDisturbed(this);
    }
    // https://fetch.spec.whatwg.org/#dom-body-body
    get body() {
      if (!this[kBody]) {
        this[kBody] = ReadableStreamFrom(this);
        if (this[kConsume]) {
          this[kBody].getReader();
          assert(this[kBody].locked);
        }
      }
      return this[kBody];
    }
    async dump(opts) {
      let limit = Number.isFinite(opts?.limit) ? opts.limit : 128 * 1024;
      const signal = opts?.signal;
      if (signal != null && (typeof signal !== "object" || !("aborted" in signal))) {
        throw new InvalidArgumentError("signal must be an AbortSignal");
      }
      signal?.throwIfAborted();
      if (this._readableState.closeEmitted) {
        return null;
      }
      return await new Promise((resolve2, reject) => {
        if (this[kContentLength] > limit) {
          this.destroy(new AbortError());
        }
        const onAbort = () => {
          this.destroy(signal.reason ?? new AbortError());
        };
        signal?.addEventListener("abort", onAbort);
        this.on("close", function() {
          signal?.removeEventListener("abort", onAbort);
          if (signal?.aborted) {
            reject(signal.reason ?? new AbortError());
          } else {
            resolve2(null);
          }
        }).on("error", noop).on("data", function(chunk) {
          limit -= chunk.length;
          if (limit <= 0) {
            this.destroy();
          }
        }).resume();
      });
    }
  }
  function isLocked(self2) {
    return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
  }
  function isUnusable(self2) {
    return util2.isDisturbed(self2) || isLocked(self2);
  }
  async function consume(stream, type) {
    assert(!stream[kConsume]);
    return new Promise((resolve2, reject) => {
      if (isUnusable(stream)) {
        const rState = stream._readableState;
        if (rState.destroyed && rState.closeEmitted === false) {
          stream.on("error", (err) => {
            reject(err);
          }).on("close", () => {
            reject(new TypeError("unusable"));
          });
        } else {
          reject(rState.errored ?? new TypeError("unusable"));
        }
      } else {
        queueMicrotask(() => {
          stream[kConsume] = {
            type,
            stream,
            resolve: resolve2,
            reject,
            length: 0,
            body: []
          };
          stream.on("error", function(err) {
            consumeFinish(this[kConsume], err);
          }).on("close", function() {
            if (this[kConsume].body !== null) {
              consumeFinish(this[kConsume], new RequestAbortedError());
            }
          });
          consumeStart(stream[kConsume]);
        });
      }
    });
  }
  function consumeStart(consume2) {
    if (consume2.body === null) {
      return;
    }
    const { _readableState: state } = consume2.stream;
    if (state.bufferIndex) {
      const start2 = state.bufferIndex;
      const end = state.buffer.length;
      for (let n = start2; n < end; n++) {
        consumePush(consume2, state.buffer[n]);
      }
    } else {
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
    }
    if (state.endEmitted) {
      consumeEnd(this[kConsume]);
    } else {
      consume2.stream.on("end", function() {
        consumeEnd(this[kConsume]);
      });
    }
    consume2.stream.resume();
    while (consume2.stream.read() != null) {
    }
  }
  function chunksDecode(chunks, length) {
    if (chunks.length === 0 || length === 0) {
      return "";
    }
    const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length);
    const bufferLength = buffer.length;
    const start2 = bufferLength > 2 && buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191 ? 3 : 0;
    return buffer.utf8Slice(start2, bufferLength);
  }
  function consumeEnd(consume2) {
    const { type, body: body2, resolve: resolve2, stream, length } = consume2;
    try {
      if (type === "text") {
        resolve2(chunksDecode(body2, length));
      } else if (type === "json") {
        resolve2(JSON.parse(chunksDecode(body2, length)));
      } else if (type === "arrayBuffer") {
        const dst = new Uint8Array(length);
        let pos = 0;
        for (const buf of body2) {
          dst.set(buf, pos);
          pos += buf.byteLength;
        }
        resolve2(dst.buffer);
      } else if (type === "blob") {
        resolve2(new Blob(body2, { type: stream[kContentType] }));
      }
      consumeFinish(consume2);
    } catch (err) {
      stream.destroy(err);
    }
  }
  function consumePush(consume2, chunk) {
    consume2.length += chunk.length;
    consume2.body.push(chunk);
  }
  function consumeFinish(consume2, err) {
    if (consume2.body === null) {
      return;
    }
    if (err) {
      consume2.reject(err);
    } else {
      consume2.resolve();
    }
    consume2.type = null;
    consume2.stream = null;
    consume2.resolve = null;
    consume2.reject = null;
    consume2.length = 0;
    consume2.body = null;
  }
  readable = { Readable: BodyReadable, chunksDecode };
  return readable;
}
var util$5;
var hasRequiredUtil$5;
function requireUtil$5() {
  if (hasRequiredUtil$5) return util$5;
  hasRequiredUtil$5 = 1;
  const assert = require$$0$3;
  const {
    ResponseStatusCodeError
  } = requireErrors();
  const { chunksDecode } = requireReadable();
  const CHUNK_LIMIT = 128 * 1024;
  async function getResolveErrorBodyCallback({ callback, body: body2, contentType, statusCode, statusMessage, headers: headers2 }) {
    assert(body2);
    let chunks = [];
    let length = 0;
    try {
      for await (const chunk of body2) {
        chunks.push(chunk);
        length += chunk.length;
        if (length > CHUNK_LIMIT) {
          chunks = [];
          length = 0;
          break;
        }
      }
    } catch {
      chunks = [];
      length = 0;
    }
    const message = `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`;
    if (statusCode === 204 || !contentType || !length) {
      queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers2)));
      return;
    }
    const stackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    let payload;
    try {
      if (isContentTypeApplicationJson(contentType)) {
        payload = JSON.parse(chunksDecode(chunks, length));
      } else if (isContentTypeText(contentType)) {
        payload = chunksDecode(chunks, length);
      }
    } catch {
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
    queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers2, payload)));
  }
  const isContentTypeApplicationJson = (contentType) => {
    return contentType.length > 15 && contentType[11] === "/" && contentType[0] === "a" && contentType[1] === "p" && contentType[2] === "p" && contentType[3] === "l" && contentType[4] === "i" && contentType[5] === "c" && contentType[6] === "a" && contentType[7] === "t" && contentType[8] === "i" && contentType[9] === "o" && contentType[10] === "n" && contentType[12] === "j" && contentType[13] === "s" && contentType[14] === "o" && contentType[15] === "n";
  };
  const isContentTypeText = (contentType) => {
    return contentType.length > 4 && contentType[4] === "/" && contentType[0] === "t" && contentType[1] === "e" && contentType[2] === "x" && contentType[3] === "t";
  };
  util$5 = {
    getResolveErrorBodyCallback,
    isContentTypeApplicationJson,
    isContentTypeText
  };
  return util$5;
}
var hasRequiredApiRequest;
function requireApiRequest() {
  if (hasRequiredApiRequest) return apiRequest.exports;
  hasRequiredApiRequest = 1;
  const assert = require$$0$3;
  const { Readable } = requireReadable();
  const { InvalidArgumentError, RequestAbortedError } = requireErrors();
  const util2 = requireUtil$7();
  const { getResolveErrorBodyCallback } = requireUtil$5();
  const { AsyncResource } = require$$5$1;
  class RequestHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body: body2, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
          throw new InvalidArgumentError("invalid highWaterMark");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util2.isStream(body2)) {
          util2.destroy(body2.on("error", util2.nop), err);
        }
        throw err;
      }
      this.method = method;
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.body = body2;
      this.trailers = {};
      this.context = null;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError;
      this.highWaterMark = highWaterMark;
      this.signal = signal;
      this.reason = null;
      this.removeAbortListener = null;
      if (util2.isStream(body2)) {
        body2.on("error", (err) => {
          this.onError(err);
        });
      }
      if (this.signal) {
        if (this.signal.aborted) {
          this.reason = this.signal.reason ?? new RequestAbortedError();
        } else {
          this.removeAbortListener = util2.addAbortListener(this.signal, () => {
            this.reason = this.signal.reason ?? new RequestAbortedError();
            if (this.res) {
              util2.destroy(this.res, this.reason);
            } else if (this.abort) {
              this.abort(this.reason);
            }
            if (this.removeAbortListener) {
              this.res?.off("close", this.removeAbortListener);
              this.removeAbortListener();
              this.removeAbortListener = null;
            }
          });
        }
      }
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
      const headers2 = responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers: headers2 });
        }
        return;
      }
      const parsedHeaders = responseHeaders === "raw" ? util2.parseHeaders(rawHeaders) : headers2;
      const contentType = parsedHeaders["content-type"];
      const contentLength = parsedHeaders["content-length"];
      const res = new Readable({
        resume,
        abort,
        contentType,
        contentLength: this.method !== "HEAD" && contentLength ? Number(contentLength) : null,
        highWaterMark
      });
      if (this.removeAbortListener) {
        res.on("close", this.removeAbortListener);
      }
      this.callback = null;
      this.res = res;
      if (callback !== null) {
        if (this.throwOnError && statusCode >= 400) {
          this.runInAsyncScope(
            getResolveErrorBodyCallback,
            null,
            { callback, body: res, contentType, statusCode, statusMessage, headers: headers2 }
          );
        } else {
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers: headers2,
            trailers: this.trailers,
            opaque,
            body: res,
            context
          });
        }
      }
    }
    onData(chunk) {
      return this.res.push(chunk);
    }
    onComplete(trailers) {
      util2.parseHeaders(trailers, this.trailers);
      this.res.push(null);
    }
    onError(err) {
      const { res, callback, body: body2, opaque } = this;
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (res) {
        this.res = null;
        queueMicrotask(() => {
          util2.destroy(res, err);
        });
      }
      if (body2) {
        this.body = null;
        util2.destroy(body2, err);
      }
      if (this.removeAbortListener) {
        res?.off("close", this.removeAbortListener);
        this.removeAbortListener();
        this.removeAbortListener = null;
      }
    }
  }
  function request2(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve2, reject) => {
        request2.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve2(data);
        });
      });
    }
    try {
      this.dispatch(opts, new RequestHandler(opts, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  apiRequest.exports = request2;
  apiRequest.exports.RequestHandler = RequestHandler;
  return apiRequest.exports;
}
var abortSignal;
var hasRequiredAbortSignal;
function requireAbortSignal() {
  if (hasRequiredAbortSignal) return abortSignal;
  hasRequiredAbortSignal = 1;
  const { addAbortListener } = requireUtil$7();
  const { RequestAbortedError } = requireErrors();
  const kListener = Symbol("kListener");
  const kSignal = Symbol("kSignal");
  function abort(self2) {
    if (self2.abort) {
      self2.abort(self2[kSignal]?.reason);
    } else {
      self2.reason = self2[kSignal]?.reason ?? new RequestAbortedError();
    }
    removeSignal(self2);
  }
  function addSignal(self2, signal) {
    self2.reason = null;
    self2[kSignal] = null;
    self2[kListener] = null;
    if (!signal) {
      return;
    }
    if (signal.aborted) {
      abort(self2);
      return;
    }
    self2[kSignal] = signal;
    self2[kListener] = () => {
      abort(self2);
    };
    addAbortListener(self2[kSignal], self2[kListener]);
  }
  function removeSignal(self2) {
    if (!self2[kSignal]) {
      return;
    }
    if ("removeEventListener" in self2[kSignal]) {
      self2[kSignal].removeEventListener("abort", self2[kListener]);
    } else {
      self2[kSignal].removeListener("abort", self2[kListener]);
    }
    self2[kSignal] = null;
    self2[kListener] = null;
  }
  abortSignal = {
    addSignal,
    removeSignal
  };
  return abortSignal;
}
var apiStream;
var hasRequiredApiStream;
function requireApiStream() {
  if (hasRequiredApiStream) return apiStream;
  hasRequiredApiStream = 1;
  const assert = require$$0$3;
  const { finished, PassThrough: PassThrough2 } = require$$0$4;
  const { InvalidArgumentError, InvalidReturnValueError } = requireErrors();
  const util2 = requireUtil$7();
  const { getResolveErrorBodyCallback } = requireUtil$5();
  const { AsyncResource } = require$$5$1;
  const { addSignal, removeSignal } = requireAbortSignal();
  class StreamHandler extends AsyncResource {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body: body2, onInfo, responseHeaders, throwOnError } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("invalid factory");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_STREAM");
      } catch (err) {
        if (util2.isStream(body2)) {
          util2.destroy(body2.on("error", util2.nop), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.factory = factory;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.context = null;
      this.trailers = null;
      this.body = body2;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError || false;
      if (util2.isStream(body2)) {
        body2.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { factory, opaque, context, callback, responseHeaders } = this;
      const headers2 = responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers: headers2 });
        }
        return;
      }
      this.factory = null;
      let res;
      if (this.throwOnError && statusCode >= 400) {
        const parsedHeaders = responseHeaders === "raw" ? util2.parseHeaders(rawHeaders) : headers2;
        const contentType = parsedHeaders["content-type"];
        res = new PassThrough2();
        this.callback = null;
        this.runInAsyncScope(
          getResolveErrorBodyCallback,
          null,
          { callback, body: res, contentType, statusCode, statusMessage, headers: headers2 }
        );
      } else {
        if (factory === null) {
          return;
        }
        res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers: headers2,
          opaque,
          context
        });
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        finished(res, { readable: false }, (err) => {
          const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
          this.res = null;
          if (err || !res2.readable) {
            util2.destroy(res2, err);
          }
          this.callback = null;
          this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
          if (err) {
            abort();
          }
        });
      }
      res.on("drain", resume);
      this.res = res;
      const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState?.needDrain;
      return needDrain !== true;
    }
    onData(chunk) {
      const { res } = this;
      return res ? res.write(chunk) : true;
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      if (!res) {
        return;
      }
      this.trailers = util2.parseHeaders(trailers);
      res.end();
    }
    onError(err) {
      const { res, callback, opaque, body: body2 } = this;
      removeSignal(this);
      this.factory = null;
      if (res) {
        this.res = null;
        util2.destroy(res, err);
      } else if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (body2) {
        this.body = null;
        util2.destroy(body2, err);
      }
    }
  }
  function stream(opts, factory, callback) {
    if (callback === void 0) {
      return new Promise((resolve2, reject) => {
        stream.call(this, opts, factory, (err, data) => {
          return err ? reject(err) : resolve2(data);
        });
      });
    }
    try {
      this.dispatch(opts, new StreamHandler(opts, factory, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  apiStream = stream;
  return apiStream;
}
var apiPipeline;
var hasRequiredApiPipeline;
function requireApiPipeline() {
  if (hasRequiredApiPipeline) return apiPipeline;
  hasRequiredApiPipeline = 1;
  const {
    Readable,
    Duplex,
    PassThrough: PassThrough2
  } = require$$0$4;
  const {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = requireErrors();
  const util2 = requireUtil$7();
  const { AsyncResource } = require$$5$1;
  const { addSignal, removeSignal } = requireAbortSignal();
  const assert = require$$0$3;
  const kResume = Symbol("resume");
  class PipelineRequest extends Readable {
    constructor() {
      super({ autoDestroy: true });
      this[kResume] = null;
    }
    _read() {
      const { [kResume]: resume } = this;
      if (resume) {
        this[kResume] = null;
        resume();
      }
    }
    _destroy(err, callback) {
      this._read();
      callback(err);
    }
  }
  class PipelineResponse extends Readable {
    constructor(resume) {
      super({ autoDestroy: true });
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError();
      }
      callback(err);
    }
  }
  class PipelineHandler extends AsyncResource {
    constructor(opts, handler2) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof handler2 !== "function") {
        throw new InvalidArgumentError("invalid handler");
      }
      const { signal, method, opaque, onInfo, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError("invalid method");
      }
      if (onInfo && typeof onInfo !== "function") {
        throw new InvalidArgumentError("invalid onInfo callback");
      }
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.handler = handler2;
      this.abort = null;
      this.context = null;
      this.onInfo = onInfo || null;
      this.req = new PipelineRequest().on("error", util2.nop);
      this.ret = new Duplex({
        readableObjectMode: opts.objectMode,
        autoDestroy: true,
        read: () => {
          const { body: body2 } = this;
          if (body2?.resume) {
            body2.resume();
          }
        },
        write: (chunk, encoding2, callback) => {
          const { req } = this;
          if (req.push(chunk, encoding2) || req._readableState.destroyed) {
            callback();
          } else {
            req[kResume] = callback;
          }
        },
        destroy: (err, callback) => {
          const { body: body2, req, res, ret, abort } = this;
          if (!err && !ret._readableState.endEmitted) {
            err = new RequestAbortedError();
          }
          if (abort && err) {
            abort();
          }
          util2.destroy(body2, err);
          util2.destroy(req, err);
          util2.destroy(res, err);
          removeSignal(this);
          callback(err);
        }
      }).on("prefinish", () => {
        const { req } = this;
        req.push(null);
      });
      this.res = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      const { ret, res } = this;
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(!res, "pipeline cannot be retried");
      assert(!ret.destroyed);
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume) {
      const { opaque, handler: handler2, context } = this;
      if (statusCode < 200) {
        if (this.onInfo) {
          const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
          this.onInfo({ statusCode, headers: headers2 });
        }
        return;
      }
      this.res = new PipelineResponse(resume);
      let body2;
      try {
        this.handler = null;
        const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
        body2 = this.runInAsyncScope(handler2, null, {
          statusCode,
          headers: headers2,
          opaque,
          body: this.res,
          context
        });
      } catch (err) {
        this.res.on("error", util2.nop);
        throw err;
      }
      if (!body2 || typeof body2.on !== "function") {
        throw new InvalidReturnValueError("expected Readable");
      }
      body2.on("data", (chunk) => {
        const { ret, body: body3 } = this;
        if (!ret.push(chunk) && body3.pause) {
          body3.pause();
        }
      }).on("error", (err) => {
        const { ret } = this;
        util2.destroy(ret, err);
      }).on("end", () => {
        const { ret } = this;
        ret.push(null);
      }).on("close", () => {
        const { ret } = this;
        if (!ret._readableState.ended) {
          util2.destroy(ret, new RequestAbortedError());
        }
      });
      this.body = body2;
    }
    onData(chunk) {
      const { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      res.push(null);
    }
    onError(err) {
      const { ret } = this;
      this.handler = null;
      util2.destroy(ret, err);
    }
  }
  function pipeline(opts, handler2) {
    try {
      const pipelineHandler = new PipelineHandler(opts, handler2);
      this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
      return pipelineHandler.ret;
    } catch (err) {
      return new PassThrough2().destroy(err);
    }
  }
  apiPipeline = pipeline;
  return apiPipeline;
}
var apiUpgrade;
var hasRequiredApiUpgrade;
function requireApiUpgrade() {
  if (hasRequiredApiUpgrade) return apiUpgrade;
  hasRequiredApiUpgrade = 1;
  const { InvalidArgumentError, SocketError } = requireErrors();
  const { AsyncResource } = require$$5$1;
  const util2 = requireUtil$7();
  const { addSignal, removeSignal } = requireAbortSignal();
  const assert = require$$0$3;
  class UpgradeHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_UPGRADE");
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      this.context = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = null;
    }
    onHeaders() {
      throw new SocketError("bad upgrade", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      assert.strictEqual(statusCode, 101);
      removeSignal(this);
      this.callback = null;
      const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        headers: headers2,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  function upgrade(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve2, reject) => {
        upgrade.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve2(data);
        });
      });
    }
    try {
      const upgradeHandler = new UpgradeHandler(opts, callback);
      this.dispatch({
        ...opts,
        method: opts.method || "GET",
        upgrade: opts.protocol || "Websocket"
      }, upgradeHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  apiUpgrade = upgrade;
  return apiUpgrade;
}
var apiConnect;
var hasRequiredApiConnect;
function requireApiConnect() {
  if (hasRequiredApiConnect) return apiConnect;
  hasRequiredApiConnect = 1;
  const assert = require$$0$3;
  const { AsyncResource } = require$$5$1;
  const { InvalidArgumentError, SocketError } = requireErrors();
  const util2 = requireUtil$7();
  const { addSignal, removeSignal } = requireAbortSignal();
  class ConnectHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_CONNECT");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders() {
      throw new SocketError("bad connect", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      removeSignal(this);
      this.callback = null;
      let headers2 = rawHeaders;
      if (headers2 != null) {
        headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
      }
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers: headers2,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  function connect2(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve2, reject) => {
        connect2.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve2(data);
        });
      });
    }
    try {
      const connectHandler = new ConnectHandler(opts, callback);
      this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  apiConnect = connect2;
  return apiConnect;
}
var hasRequiredApi;
function requireApi() {
  if (hasRequiredApi) return api;
  hasRequiredApi = 1;
  api.request = requireApiRequest();
  api.stream = requireApiStream();
  api.pipeline = requireApiPipeline();
  api.upgrade = requireApiUpgrade();
  api.connect = requireApiConnect();
  return api;
}
var mockErrors;
var hasRequiredMockErrors;
function requireMockErrors() {
  if (hasRequiredMockErrors) return mockErrors;
  hasRequiredMockErrors = 1;
  const { UndiciError } = requireErrors();
  class MockNotMatchedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, MockNotMatchedError);
      this.name = "MockNotMatchedError";
      this.message = message || "The request does not match any registered mock dispatches";
      this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
  }
  mockErrors = {
    MockNotMatchedError
  };
  return mockErrors;
}
var mockSymbols;
var hasRequiredMockSymbols;
function requireMockSymbols() {
  if (hasRequiredMockSymbols) return mockSymbols;
  hasRequiredMockSymbols = 1;
  mockSymbols = {
    kAgent: Symbol("agent"),
    kOptions: Symbol("options"),
    kFactory: Symbol("factory"),
    kDispatches: Symbol("dispatches"),
    kDispatchKey: Symbol("dispatch key"),
    kDefaultHeaders: Symbol("default headers"),
    kDefaultTrailers: Symbol("default trailers"),
    kContentLength: Symbol("content length"),
    kMockAgent: Symbol("mock agent"),
    kMockAgentSet: Symbol("mock agent set"),
    kMockAgentGet: Symbol("mock agent get"),
    kMockDispatch: Symbol("mock dispatch"),
    kClose: Symbol("close"),
    kOriginalClose: Symbol("original agent close"),
    kOrigin: Symbol("origin"),
    kIsMockActive: Symbol("is mock active"),
    kNetConnect: Symbol("net connect"),
    kGetNetConnect: Symbol("get net connect"),
    kConnected: Symbol("connected")
  };
  return mockSymbols;
}
var mockUtils;
var hasRequiredMockUtils;
function requireMockUtils() {
  if (hasRequiredMockUtils) return mockUtils;
  hasRequiredMockUtils = 1;
  const { MockNotMatchedError } = requireMockErrors();
  const {
    kDispatches,
    kMockAgent,
    kOriginalDispatch,
    kOrigin,
    kGetNetConnect
  } = requireMockSymbols();
  const { buildURL } = requireUtil$7();
  const { STATUS_CODES } = require$$2;
  const {
    types: {
      isPromise
    }
  } = require$$0$5;
  function matchValue(match, value) {
    if (typeof match === "string") {
      return match === value;
    }
    if (match instanceof RegExp) {
      return match.test(value);
    }
    if (typeof match === "function") {
      return match(value) === true;
    }
    return false;
  }
  function lowerCaseEntries(headers2) {
    return Object.fromEntries(
      Object.entries(headers2).map(([headerName, headerValue]) => {
        return [headerName.toLocaleLowerCase(), headerValue];
      })
    );
  }
  function getHeaderByName(headers2, key) {
    if (Array.isArray(headers2)) {
      for (let i = 0; i < headers2.length; i += 2) {
        if (headers2[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
          return headers2[i + 1];
        }
      }
      return void 0;
    } else if (typeof headers2.get === "function") {
      return headers2.get(key);
    } else {
      return lowerCaseEntries(headers2)[key.toLocaleLowerCase()];
    }
  }
  function buildHeadersFromArray(headers2) {
    const clone = headers2.slice();
    const entries = [];
    for (let index = 0; index < clone.length; index += 2) {
      entries.push([clone[index], clone[index + 1]]);
    }
    return Object.fromEntries(entries);
  }
  function matchHeaders(mockDispatch2, headers2) {
    if (typeof mockDispatch2.headers === "function") {
      if (Array.isArray(headers2)) {
        headers2 = buildHeadersFromArray(headers2);
      }
      return mockDispatch2.headers(headers2 ? lowerCaseEntries(headers2) : {});
    }
    if (typeof mockDispatch2.headers === "undefined") {
      return true;
    }
    if (typeof headers2 !== "object" || typeof mockDispatch2.headers !== "object") {
      return false;
    }
    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
      const headerValue = getHeaderByName(headers2, matchHeaderName);
      if (!matchValue(matchHeaderValue, headerValue)) {
        return false;
      }
    }
    return true;
  }
  function safeUrl(path2) {
    if (typeof path2 !== "string") {
      return path2;
    }
    const pathSegments = path2.split("?");
    if (pathSegments.length !== 2) {
      return path2;
    }
    const qp = new URLSearchParams(pathSegments.pop());
    qp.sort();
    return [...pathSegments, qp.toString()].join("?");
  }
  function matchKey(mockDispatch2, { path: path2, method, body: body2, headers: headers2 }) {
    const pathMatch = matchValue(mockDispatch2.path, path2);
    const methodMatch = matchValue(mockDispatch2.method, method);
    const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body2) : true;
    const headersMatch = matchHeaders(mockDispatch2, headers2);
    return pathMatch && methodMatch && bodyMatch && headersMatch;
  }
  function getResponseData(data) {
    if (Buffer.isBuffer(data)) {
      return data;
    } else if (typeof data === "object") {
      return JSON.stringify(data);
    } else {
      return data.toString();
    }
  }
  function getMockDispatch(mockDispatches, key) {
    const basePath = key.query ? buildURL(key.path, key.query) : key.path;
    const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
    let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path2 }) => matchValue(safeUrl(path2), resolvedPath));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ body: body2 }) => typeof body2 !== "undefined" ? matchValue(body2, key.body) : true);
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
    if (matchedMockDispatches.length === 0) {
      const headers2 = typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers;
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers2}' on path '${resolvedPath}'`);
    }
    return matchedMockDispatches[0];
  }
  function addMockDispatch(mockDispatches, key, data) {
    const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
    const replyData = typeof data === "function" ? { callback: data } : { ...data };
    const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
    mockDispatches.push(newMockDispatch);
    return newMockDispatch;
  }
  function deleteMockDispatch(mockDispatches, key) {
    const index = mockDispatches.findIndex((dispatch) => {
      if (!dispatch.consumed) {
        return false;
      }
      return matchKey(dispatch, key);
    });
    if (index !== -1) {
      mockDispatches.splice(index, 1);
    }
  }
  function buildKey(opts) {
    const { path: path2, method, body: body2, headers: headers2, query } = opts;
    return {
      path: path2,
      method,
      body: body2,
      headers: headers2,
      query
    };
  }
  function generateKeyValues(data) {
    const keys = Object.keys(data);
    const result = [];
    for (let i = 0; i < keys.length; ++i) {
      const key = keys[i];
      const value = data[key];
      const name = Buffer.from(`${key}`);
      if (Array.isArray(value)) {
        for (let j = 0; j < value.length; ++j) {
          result.push(name, Buffer.from(`${value[j]}`));
        }
      } else {
        result.push(name, Buffer.from(`${value}`));
      }
    }
    return result;
  }
  function getStatusText(statusCode) {
    return STATUS_CODES[statusCode] || "unknown";
  }
  async function getResponse(body2) {
    const buffers = [];
    for await (const data of body2) {
      buffers.push(data);
    }
    return Buffer.concat(buffers).toString("utf8");
  }
  function mockDispatch(opts, handler2) {
    const key = buildKey(opts);
    const mockDispatch2 = getMockDispatch(this[kDispatches], key);
    mockDispatch2.timesInvoked++;
    if (mockDispatch2.data.callback) {
      mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
    }
    const { data: { statusCode, data, headers: headers2, trailers, error }, delay, persist } = mockDispatch2;
    const { timesInvoked, times } = mockDispatch2;
    mockDispatch2.consumed = !persist && timesInvoked >= times;
    mockDispatch2.pending = timesInvoked < times;
    if (error !== null) {
      deleteMockDispatch(this[kDispatches], key);
      handler2.onError(error);
      return true;
    }
    if (typeof delay === "number" && delay > 0) {
      setTimeout(() => {
        handleReply(this[kDispatches]);
      }, delay);
    } else {
      handleReply(this[kDispatches]);
    }
    function handleReply(mockDispatches, _data = data) {
      const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
      const body2 = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
      if (isPromise(body2)) {
        body2.then((newData) => handleReply(mockDispatches, newData));
        return;
      }
      const responseData = getResponseData(body2);
      const responseHeaders = generateKeyValues(headers2);
      const responseTrailers = generateKeyValues(trailers);
      handler2.onConnect?.((err) => handler2.onError(err), null);
      handler2.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode));
      handler2.onData?.(Buffer.from(responseData));
      handler2.onComplete?.(responseTrailers);
      deleteMockDispatch(mockDispatches, key);
    }
    function resume() {
    }
    return true;
  }
  function buildMockDispatch() {
    const agent2 = this[kMockAgent];
    const origin = this[kOrigin];
    const originalDispatch = this[kOriginalDispatch];
    return function dispatch(opts, handler2) {
      if (agent2.isMockActive) {
        try {
          mockDispatch.call(this, opts, handler2);
        } catch (error) {
          if (error instanceof MockNotMatchedError) {
            const netConnect = agent2[kGetNetConnect]();
            if (netConnect === false) {
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
            }
            if (checkNetConnect(netConnect, origin)) {
              originalDispatch.call(this, opts, handler2);
            } else {
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
            }
          } else {
            throw error;
          }
        }
      } else {
        originalDispatch.call(this, opts, handler2);
      }
    };
  }
  function checkNetConnect(netConnect, origin) {
    const url = new URL(origin);
    if (netConnect === true) {
      return true;
    } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
      return true;
    }
    return false;
  }
  function buildMockOptions(opts) {
    if (opts) {
      const { agent: agent2, ...mockOptions } = opts;
      return mockOptions;
    }
  }
  mockUtils = {
    getResponseData,
    getMockDispatch,
    addMockDispatch,
    deleteMockDispatch,
    buildKey,
    generateKeyValues,
    matchValue,
    getResponse,
    getStatusText,
    mockDispatch,
    buildMockDispatch,
    checkNetConnect,
    buildMockOptions,
    getHeaderByName,
    buildHeadersFromArray
  };
  return mockUtils;
}
var mockInterceptor = {};
var hasRequiredMockInterceptor;
function requireMockInterceptor() {
  if (hasRequiredMockInterceptor) return mockInterceptor;
  hasRequiredMockInterceptor = 1;
  const { getResponseData, buildKey, addMockDispatch } = requireMockUtils();
  const {
    kDispatches,
    kDispatchKey,
    kDefaultHeaders,
    kDefaultTrailers,
    kContentLength,
    kMockDispatch
  } = requireMockSymbols();
  const { InvalidArgumentError } = requireErrors();
  const { buildURL } = requireUtil$7();
  class MockScope {
    constructor(mockDispatch) {
      this[kMockDispatch] = mockDispatch;
    }
    /**
     * Delay a reply by a set amount in ms.
     */
    delay(waitInMs) {
      if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
        throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
      }
      this[kMockDispatch].delay = waitInMs;
      return this;
    }
    /**
     * For a defined reply, never mark as consumed.
     */
    persist() {
      this[kMockDispatch].persist = true;
      return this;
    }
    /**
     * Allow one to define a reply for a set amount of matching requests.
     */
    times(repeatTimes) {
      if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
        throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
      }
      this[kMockDispatch].times = repeatTimes;
      return this;
    }
  }
  class MockInterceptor {
    constructor(opts, mockDispatches) {
      if (typeof opts !== "object") {
        throw new InvalidArgumentError("opts must be an object");
      }
      if (typeof opts.path === "undefined") {
        throw new InvalidArgumentError("opts.path must be defined");
      }
      if (typeof opts.method === "undefined") {
        opts.method = "GET";
      }
      if (typeof opts.path === "string") {
        if (opts.query) {
          opts.path = buildURL(opts.path, opts.query);
        } else {
          const parsedURL = new URL(opts.path, "data://");
          opts.path = parsedURL.pathname + parsedURL.search;
        }
      }
      if (typeof opts.method === "string") {
        opts.method = opts.method.toUpperCase();
      }
      this[kDispatchKey] = buildKey(opts);
      this[kDispatches] = mockDispatches;
      this[kDefaultHeaders] = {};
      this[kDefaultTrailers] = {};
      this[kContentLength] = false;
    }
    createMockScopeDispatchData({ statusCode, data, responseOptions }) {
      const responseData = getResponseData(data);
      const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
      const headers2 = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
      const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
      return { statusCode, data, headers: headers2, trailers };
    }
    validateReplyParameters(replyParameters) {
      if (typeof replyParameters.statusCode === "undefined") {
        throw new InvalidArgumentError("statusCode must be defined");
      }
      if (typeof replyParameters.responseOptions !== "object" || replyParameters.responseOptions === null) {
        throw new InvalidArgumentError("responseOptions must be an object");
      }
    }
    /**
     * Mock an undici request with a defined reply.
     */
    reply(replyOptionsCallbackOrStatusCode) {
      if (typeof replyOptionsCallbackOrStatusCode === "function") {
        const wrappedDefaultsCallback = (opts) => {
          const resolvedData = replyOptionsCallbackOrStatusCode(opts);
          if (typeof resolvedData !== "object" || resolvedData === null) {
            throw new InvalidArgumentError("reply options callback must return an object");
          }
          const replyParameters2 = { data: "", responseOptions: {}, ...resolvedData };
          this.validateReplyParameters(replyParameters2);
          return {
            ...this.createMockScopeDispatchData(replyParameters2)
          };
        };
        const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
        return new MockScope(newMockDispatch2);
      }
      const replyParameters = {
        statusCode: replyOptionsCallbackOrStatusCode,
        data: arguments[1] === void 0 ? "" : arguments[1],
        responseOptions: arguments[2] === void 0 ? {} : arguments[2]
      };
      this.validateReplyParameters(replyParameters);
      const dispatchData = this.createMockScopeDispatchData(replyParameters);
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
      return new MockScope(newMockDispatch);
    }
    /**
     * Mock an undici request with a defined error.
     */
    replyWithError(error) {
      if (typeof error === "undefined") {
        throw new InvalidArgumentError("error must be defined");
      }
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
      return new MockScope(newMockDispatch);
    }
    /**
     * Set default reply headers on the interceptor for subsequent replies
     */
    defaultReplyHeaders(headers2) {
      if (typeof headers2 === "undefined") {
        throw new InvalidArgumentError("headers must be defined");
      }
      this[kDefaultHeaders] = headers2;
      return this;
    }
    /**
     * Set default reply trailers on the interceptor for subsequent replies
     */
    defaultReplyTrailers(trailers) {
      if (typeof trailers === "undefined") {
        throw new InvalidArgumentError("trailers must be defined");
      }
      this[kDefaultTrailers] = trailers;
      return this;
    }
    /**
     * Set reply content length header for replies on the interceptor
     */
    replyContentLength() {
      this[kContentLength] = true;
      return this;
    }
  }
  mockInterceptor.MockInterceptor = MockInterceptor;
  mockInterceptor.MockScope = MockScope;
  return mockInterceptor;
}
var mockClient;
var hasRequiredMockClient;
function requireMockClient() {
  if (hasRequiredMockClient) return mockClient;
  hasRequiredMockClient = 1;
  const { promisify: promisify2 } = require$$0$5;
  const Client2 = requireClient();
  const { buildMockDispatch } = requireMockUtils();
  const {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = requireMockSymbols();
  const { MockInterceptor } = requireMockInterceptor();
  const Symbols = requireSymbols$4();
  const { InvalidArgumentError } = requireErrors();
  class MockClient extends Client2 {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    /**
     * Sets up the base interceptor for mocking replies from undici.
     */
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async [kClose]() {
      await promisify2(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  mockClient = MockClient;
  return mockClient;
}
var mockPool;
var hasRequiredMockPool;
function requireMockPool() {
  if (hasRequiredMockPool) return mockPool;
  hasRequiredMockPool = 1;
  const { promisify: promisify2 } = require$$0$5;
  const Pool = requirePool();
  const { buildMockDispatch } = requireMockUtils();
  const {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = requireMockSymbols();
  const { MockInterceptor } = requireMockInterceptor();
  const Symbols = requireSymbols$4();
  const { InvalidArgumentError } = requireErrors();
  class MockPool extends Pool {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    /**
     * Sets up the base interceptor for mocking replies from undici.
     */
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async [kClose]() {
      await promisify2(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  mockPool = MockPool;
  return mockPool;
}
var pluralizer;
var hasRequiredPluralizer;
function requirePluralizer() {
  if (hasRequiredPluralizer) return pluralizer;
  hasRequiredPluralizer = 1;
  const singulars = {
    pronoun: "it",
    is: "is",
    was: "was",
    this: "this"
  };
  const plurals = {
    pronoun: "they",
    is: "are",
    was: "were",
    this: "these"
  };
  pluralizer = class Pluralizer {
    constructor(singular, plural) {
      this.singular = singular;
      this.plural = plural;
    }
    pluralize(count) {
      const one = count === 1;
      const keys = one ? singulars : plurals;
      const noun = one ? this.singular : this.plural;
      return { ...keys, count, noun };
    }
  };
  return pluralizer;
}
var pendingInterceptorsFormatter;
var hasRequiredPendingInterceptorsFormatter;
function requirePendingInterceptorsFormatter() {
  if (hasRequiredPendingInterceptorsFormatter) return pendingInterceptorsFormatter;
  hasRequiredPendingInterceptorsFormatter = 1;
  const { Transform } = require$$0$4;
  const { Console } = require$$1$4;
  const PERSISTENT = process.versions.icu ? "â" : "Y ";
  const NOT_PERSISTENT = process.versions.icu ? "â" : "N ";
  pendingInterceptorsFormatter = class PendingInterceptorsFormatter {
    constructor({ disableColors } = {}) {
      this.transform = new Transform({
        transform(chunk, _enc, cb) {
          cb(null, chunk);
        }
      });
      this.logger = new Console({
        stdout: this.transform,
        inspectOptions: {
          colors: !disableColors && !process.env.CI
        }
      });
    }
    format(pendingInterceptors) {
      const withPrettyHeaders = pendingInterceptors.map(
        ({ method, path: path2, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
          Method: method,
          Origin: origin,
          Path: path2,
          "Status code": statusCode,
          Persistent: persist ? PERSISTENT : NOT_PERSISTENT,
          Invocations: timesInvoked,
          Remaining: persist ? Infinity : times - timesInvoked
        })
      );
      this.logger.table(withPrettyHeaders);
      return this.transform.read().toString();
    }
  };
  return pendingInterceptorsFormatter;
}
var mockAgent;
var hasRequiredMockAgent;
function requireMockAgent() {
  if (hasRequiredMockAgent) return mockAgent;
  hasRequiredMockAgent = 1;
  const { kClients } = requireSymbols$4();
  const Agent = requireAgent();
  const {
    kAgent,
    kMockAgentSet,
    kMockAgentGet,
    kDispatches,
    kIsMockActive,
    kNetConnect,
    kGetNetConnect,
    kOptions,
    kFactory
  } = requireMockSymbols();
  const MockClient = requireMockClient();
  const MockPool = requireMockPool();
  const { matchValue, buildMockOptions } = requireMockUtils();
  const { InvalidArgumentError, UndiciError } = requireErrors();
  const Dispatcher = requireDispatcher();
  const Pluralizer = requirePluralizer();
  const PendingInterceptorsFormatter = requirePendingInterceptorsFormatter();
  class MockAgent extends Dispatcher {
    constructor(opts) {
      super(opts);
      this[kNetConnect] = true;
      this[kIsMockActive] = true;
      if (opts?.agent && typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      const agent2 = opts?.agent ? opts.agent : new Agent(opts);
      this[kAgent] = agent2;
      this[kClients] = agent2[kClients];
      this[kOptions] = buildMockOptions(opts);
    }
    get(origin) {
      let dispatcher2 = this[kMockAgentGet](origin);
      if (!dispatcher2) {
        dispatcher2 = this[kFactory](origin);
        this[kMockAgentSet](origin, dispatcher2);
      }
      return dispatcher2;
    }
    dispatch(opts, handler2) {
      this.get(opts.origin);
      return this[kAgent].dispatch(opts, handler2);
    }
    async close() {
      await this[kAgent].close();
      this[kClients].clear();
    }
    deactivate() {
      this[kIsMockActive] = false;
    }
    activate() {
      this[kIsMockActive] = true;
    }
    enableNetConnect(matcher) {
      if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
        if (Array.isArray(this[kNetConnect])) {
          this[kNetConnect].push(matcher);
        } else {
          this[kNetConnect] = [matcher];
        }
      } else if (typeof matcher === "undefined") {
        this[kNetConnect] = true;
      } else {
        throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
      }
    }
    disableNetConnect() {
      this[kNetConnect] = false;
    }
    // This is required to bypass issues caused by using global symbols - see:
    // https://github.com/nodejs/undici/issues/1447
    get isMockActive() {
      return this[kIsMockActive];
    }
    [kMockAgentSet](origin, dispatcher2) {
      this[kClients].set(origin, dispatcher2);
    }
    [kFactory](origin) {
      const mockOptions = Object.assign({ agent: this }, this[kOptions]);
      return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
    }
    [kMockAgentGet](origin) {
      const client2 = this[kClients].get(origin);
      if (client2) {
        return client2;
      }
      if (typeof origin !== "string") {
        const dispatcher2 = this[kFactory]("http://localhost:9999");
        this[kMockAgentSet](origin, dispatcher2);
        return dispatcher2;
      }
      for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients])) {
        if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
          const dispatcher2 = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher2);
          dispatcher2[kDispatches] = nonExplicitDispatcher[kDispatches];
          return dispatcher2;
        }
      }
    }
    [kGetNetConnect]() {
      return this[kNetConnect];
    }
    pendingInterceptors() {
      const mockAgentClients = this[kClients];
      return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
    }
    assertNoPendingInterceptors({ pendingInterceptorsFormatter: pendingInterceptorsFormatter2 = new PendingInterceptorsFormatter() } = {}) {
      const pending = this.pendingInterceptors();
      if (pending.length === 0) {
        return;
      }
      const pluralizer2 = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
      throw new UndiciError(`
${pluralizer2.count} ${pluralizer2.noun} ${pluralizer2.is} pending:

${pendingInterceptorsFormatter2.format(pending)}
`.trim());
    }
  }
  mockAgent = MockAgent;
  return mockAgent;
}
var global$1;
var hasRequiredGlobal;
function requireGlobal() {
  if (hasRequiredGlobal) return global$1;
  hasRequiredGlobal = 1;
  const globalDispatcher = Symbol.for("undici.globalDispatcher.1");
  const { InvalidArgumentError } = requireErrors();
  const Agent = requireAgent();
  if (getGlobalDispatcher() === void 0) {
    setGlobalDispatcher(new Agent());
  }
  function setGlobalDispatcher(agent2) {
    if (!agent2 || typeof agent2.dispatch !== "function") {
      throw new InvalidArgumentError("Argument agent must implement Agent");
    }
    Object.defineProperty(globalThis, globalDispatcher, {
      value: agent2,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  function getGlobalDispatcher() {
    return globalThis[globalDispatcher];
  }
  global$1 = {
    setGlobalDispatcher,
    getGlobalDispatcher
  };
  return global$1;
}
var decoratorHandler;
var hasRequiredDecoratorHandler;
function requireDecoratorHandler() {
  if (hasRequiredDecoratorHandler) return decoratorHandler;
  hasRequiredDecoratorHandler = 1;
  decoratorHandler = class DecoratorHandler {
    #handler;
    constructor(handler2) {
      if (typeof handler2 !== "object" || handler2 === null) {
        throw new TypeError("handler must be an object");
      }
      this.#handler = handler2;
    }
    onConnect(...args) {
      return this.#handler.onConnect?.(...args);
    }
    onError(...args) {
      return this.#handler.onError?.(...args);
    }
    onUpgrade(...args) {
      return this.#handler.onUpgrade?.(...args);
    }
    onResponseStarted(...args) {
      return this.#handler.onResponseStarted?.(...args);
    }
    onHeaders(...args) {
      return this.#handler.onHeaders?.(...args);
    }
    onData(...args) {
      return this.#handler.onData?.(...args);
    }
    onComplete(...args) {
      return this.#handler.onComplete?.(...args);
    }
    onBodySent(...args) {
      return this.#handler.onBodySent?.(...args);
    }
  };
  return decoratorHandler;
}
var redirect;
var hasRequiredRedirect;
function requireRedirect() {
  if (hasRequiredRedirect) return redirect;
  hasRequiredRedirect = 1;
  const RedirectHandler = requireRedirectHandler();
  redirect = (opts) => {
    const globalMaxRedirections = opts?.maxRedirections;
    return (dispatch) => {
      return function redirectInterceptor2(opts2, handler2) {
        const { maxRedirections = globalMaxRedirections, ...baseOpts } = opts2;
        if (!maxRedirections) {
          return dispatch(opts2, handler2);
        }
        const redirectHandler2 = new RedirectHandler(
          dispatch,
          maxRedirections,
          opts2,
          handler2
        );
        return dispatch(baseOpts, redirectHandler2);
      };
    };
  };
  return redirect;
}
var retry;
var hasRequiredRetry;
function requireRetry() {
  if (hasRequiredRetry) return retry;
  hasRequiredRetry = 1;
  const RetryHandler = requireRetryHandler();
  retry = (globalOpts) => {
    return (dispatch) => {
      return function retryInterceptor(opts, handler2) {
        return dispatch(
          opts,
          new RetryHandler(
            { ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } },
            {
              handler: handler2,
              dispatch
            }
          )
        );
      };
    };
  };
  return retry;
}
var dump;
var hasRequiredDump;
function requireDump() {
  if (hasRequiredDump) return dump;
  hasRequiredDump = 1;
  const util2 = requireUtil$7();
  const { InvalidArgumentError, RequestAbortedError } = requireErrors();
  const DecoratorHandler = requireDecoratorHandler();
  class DumpHandler extends DecoratorHandler {
    #maxSize = 1024 * 1024;
    #abort = null;
    #dumped = false;
    #aborted = false;
    #size = 0;
    #reason = null;
    #handler = null;
    constructor({ maxSize }, handler2) {
      super(handler2);
      if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {
        throw new InvalidArgumentError("maxSize must be a number greater than 0");
      }
      this.#maxSize = maxSize ?? this.#maxSize;
      this.#handler = handler2;
    }
    onConnect(abort) {
      this.#abort = abort;
      this.#handler.onConnect(this.#customAbort.bind(this));
    }
    #customAbort(reason) {
      this.#aborted = true;
      this.#reason = reason;
    }
    // TODO: will require adjustment after new hooks are out
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const headers2 = util2.parseHeaders(rawHeaders);
      const contentLength = headers2["content-length"];
      if (contentLength != null && contentLength > this.#maxSize) {
        throw new RequestAbortedError(
          `Response size (${contentLength}) larger than maxSize (${this.#maxSize})`
        );
      }
      if (this.#aborted) {
        return true;
      }
      return this.#handler.onHeaders(
        statusCode,
        rawHeaders,
        resume,
        statusMessage
      );
    }
    onError(err) {
      if (this.#dumped) {
        return;
      }
      err = this.#reason ?? err;
      this.#handler.onError(err);
    }
    onData(chunk) {
      this.#size = this.#size + chunk.length;
      if (this.#size >= this.#maxSize) {
        this.#dumped = true;
        if (this.#aborted) {
          this.#handler.onError(this.#reason);
        } else {
          this.#handler.onComplete([]);
        }
      }
      return true;
    }
    onComplete(trailers) {
      if (this.#dumped) {
        return;
      }
      if (this.#aborted) {
        this.#handler.onError(this.reason);
        return;
      }
      this.#handler.onComplete(trailers);
    }
  }
  function createDumpInterceptor({ maxSize: defaultMaxSize } = {
    maxSize: 1024 * 1024
  }) {
    return (dispatch) => {
      return function Intercept(opts, handler2) {
        const { dumpMaxSize = defaultMaxSize } = opts;
        const dumpHandler = new DumpHandler(
          { maxSize: dumpMaxSize },
          handler2
        );
        return dispatch(opts, dumpHandler);
      };
    };
  }
  dump = createDumpInterceptor;
  return dump;
}
var headers;
var hasRequiredHeaders;
function requireHeaders() {
  if (hasRequiredHeaders) return headers;
  hasRequiredHeaders = 1;
  const { kConstruct } = requireSymbols$4();
  const { kEnumerableProperty } = requireUtil$7();
  const {
    iteratorMixin,
    isValidHeaderName,
    isValidHeaderValue
  } = requireUtil$6();
  const { webidl } = requireWebidl();
  const assert = require$$0$3;
  const util2 = require$$0$5;
  const kHeadersMap = Symbol("headers map");
  const kHeadersSortedMap = Symbol("headers map sorted");
  function isHTTPWhiteSpaceCharCode(code) {
    return code === 10 || code === 13 || code === 9 || code === 32;
  }
  function headerValueNormalize(potentialValue) {
    let i = 0;
    let j = potentialValue.length;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
  }
  function fill(headers2, object) {
    if (Array.isArray(object)) {
      for (let i = 0; i < object.length; ++i) {
        const header = object[i];
        if (header.length !== 2) {
          throw webidl.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${header.length}.`
          });
        }
        appendHeader(headers2, header[0], header[1]);
      }
    } else if (typeof object === "object" && object !== null) {
      const keys = Object.keys(object);
      for (let i = 0; i < keys.length; ++i) {
        appendHeader(headers2, keys[i], object[keys[i]]);
      }
    } else {
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    }
  }
  function appendHeader(headers2, name, value) {
    value = headerValueNormalize(value);
    if (!isValidHeaderName(name)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value: name,
        type: "header name"
      });
    } else if (!isValidHeaderValue(value)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value,
        type: "header value"
      });
    }
    if (getHeadersGuard(headers2) === "immutable") {
      throw new TypeError("immutable");
    }
    return getHeadersList(headers2).append(name, value, false);
  }
  function compareHeaderName(a, b) {
    return a[0] < b[0] ? -1 : 1;
  }
  class HeadersList {
    /** @type {[string, string][]|null} */
    cookies = null;
    constructor(init) {
      if (init instanceof HeadersList) {
        this[kHeadersMap] = new Map(init[kHeadersMap]);
        this[kHeadersSortedMap] = init[kHeadersSortedMap];
        this.cookies = init.cookies === null ? null : [...init.cookies];
      } else {
        this[kHeadersMap] = new Map(init);
        this[kHeadersSortedMap] = null;
      }
    }
    /**
     * @see https://fetch.spec.whatwg.org/#header-list-contains
     * @param {string} name
     * @param {boolean} isLowerCase
     */
    contains(name, isLowerCase) {
      return this[kHeadersMap].has(isLowerCase ? name : name.toLowerCase());
    }
    clear() {
      this[kHeadersMap].clear();
      this[kHeadersSortedMap] = null;
      this.cookies = null;
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-append
     * @param {string} name
     * @param {string} value
     * @param {boolean} isLowerCase
     */
    append(name, value, isLowerCase) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = isLowerCase ? name : name.toLowerCase();
      const exists = this[kHeadersMap].get(lowercaseName);
      if (exists) {
        const delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this[kHeadersMap].set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else {
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      if (lowercaseName === "set-cookie") {
        (this.cookies ??= []).push(value);
      }
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-set
     * @param {string} name
     * @param {string} value
     * @param {boolean} isLowerCase
     */
    set(name, value, isLowerCase) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = isLowerCase ? name : name.toLowerCase();
      if (lowercaseName === "set-cookie") {
        this.cookies = [value];
      }
      this[kHeadersMap].set(lowercaseName, { name, value });
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-delete
     * @param {string} name
     * @param {boolean} isLowerCase
     */
    delete(name, isLowerCase) {
      this[kHeadersSortedMap] = null;
      if (!isLowerCase) name = name.toLowerCase();
      if (name === "set-cookie") {
        this.cookies = null;
      }
      this[kHeadersMap].delete(name);
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-get
     * @param {string} name
     * @param {boolean} isLowerCase
     * @returns {string | null}
     */
    get(name, isLowerCase) {
      return this[kHeadersMap].get(isLowerCase ? name : name.toLowerCase())?.value ?? null;
    }
    *[Symbol.iterator]() {
      for (const { 0: name, 1: { value } } of this[kHeadersMap]) {
        yield [name, value];
      }
    }
    get entries() {
      const headers2 = {};
      if (this[kHeadersMap].size !== 0) {
        for (const { name, value } of this[kHeadersMap].values()) {
          headers2[name] = value;
        }
      }
      return headers2;
    }
    rawValues() {
      return this[kHeadersMap].values();
    }
    get entriesList() {
      const headers2 = [];
      if (this[kHeadersMap].size !== 0) {
        for (const { 0: lowerName, 1: { name, value } } of this[kHeadersMap]) {
          if (lowerName === "set-cookie") {
            for (const cookie of this.cookies) {
              headers2.push([name, cookie]);
            }
          } else {
            headers2.push([name, value]);
          }
        }
      }
      return headers2;
    }
    // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set
    toSortedArray() {
      const size = this[kHeadersMap].size;
      const array = new Array(size);
      if (size <= 32) {
        if (size === 0) {
          return array;
        }
        const iterator = this[kHeadersMap][Symbol.iterator]();
        const firstValue = iterator.next().value;
        array[0] = [firstValue[0], firstValue[1].value];
        assert(firstValue[1].value !== null);
        for (let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value; i < size; ++i) {
          value = iterator.next().value;
          x = array[i] = [value[0], value[1].value];
          assert(x[1] !== null);
          left = 0;
          right = i;
          while (left < right) {
            pivot = left + (right - left >> 1);
            if (array[pivot][0] <= x[0]) {
              left = pivot + 1;
            } else {
              right = pivot;
            }
          }
          if (i !== pivot) {
            j = i;
            while (j > left) {
              array[j] = array[--j];
            }
            array[left] = x;
          }
        }
        if (!iterator.next().done) {
          throw new TypeError("Unreachable");
        }
        return array;
      } else {
        let i = 0;
        for (const { 0: name, 1: { value } } of this[kHeadersMap]) {
          array[i++] = [name, value];
          assert(value !== null);
        }
        return array.sort(compareHeaderName);
      }
    }
  }
  class Headers2 {
    #guard;
    #headersList;
    constructor(init = void 0) {
      if (init === kConstruct) {
        return;
      }
      this.#headersList = new HeadersList();
      this.#guard = "none";
      if (init !== void 0) {
        init = webidl.converters.HeadersInit(init, "Headers contructor", "init");
        fill(this, init);
      }
    }
    // https://fetch.spec.whatwg.org/#dom-headers-append
    append(name, value) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 2, "Headers.append");
      const prefix = "Headers.append";
      name = webidl.converters.ByteString(name, prefix, "name");
      value = webidl.converters.ByteString(value, prefix, "value");
      return appendHeader(this, name, value);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-delete
    delete(name) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 1, "Headers.delete");
      const prefix = "Headers.delete";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
      }
      if (this.#guard === "immutable") {
        throw new TypeError("immutable");
      }
      if (!this.#headersList.contains(name, false)) {
        return;
      }
      this.#headersList.delete(name, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-get
    get(name) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 1, "Headers.get");
      const prefix = "Headers.get";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      }
      return this.#headersList.get(name, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-has
    has(name) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 1, "Headers.has");
      const prefix = "Headers.has";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      }
      return this.#headersList.contains(name, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-set
    set(name, value) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 2, "Headers.set");
      const prefix = "Headers.set";
      name = webidl.converters.ByteString(name, prefix, "name");
      value = webidl.converters.ByteString(value, prefix, "value");
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value,
          type: "header value"
        });
      }
      if (this.#guard === "immutable") {
        throw new TypeError("immutable");
      }
      this.#headersList.set(name, value, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
    getSetCookie() {
      webidl.brandCheck(this, Headers2);
      const list = this.#headersList.cookies;
      if (list) {
        return [...list];
      }
      return [];
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
    get [kHeadersSortedMap]() {
      if (this.#headersList[kHeadersSortedMap]) {
        return this.#headersList[kHeadersSortedMap];
      }
      const headers2 = [];
      const names = this.#headersList.toSortedArray();
      const cookies2 = this.#headersList.cookies;
      if (cookies2 === null || cookies2.length === 1) {
        return this.#headersList[kHeadersSortedMap] = names;
      }
      for (let i = 0; i < names.length; ++i) {
        const { 0: name, 1: value } = names[i];
        if (name === "set-cookie") {
          for (let j = 0; j < cookies2.length; ++j) {
            headers2.push([name, cookies2[j]]);
          }
        } else {
          headers2.push([name, value]);
        }
      }
      return this.#headersList[kHeadersSortedMap] = headers2;
    }
    [util2.inspect.custom](depth, options) {
      options.depth ??= depth;
      return `Headers ${util2.formatWithOptions(options, this.#headersList.entries)}`;
    }
    static getHeadersGuard(o) {
      return o.#guard;
    }
    static setHeadersGuard(o, guard) {
      o.#guard = guard;
    }
    static getHeadersList(o) {
      return o.#headersList;
    }
    static setHeadersList(o, list) {
      o.#headersList = list;
    }
  }
  const { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers2;
  Reflect.deleteProperty(Headers2, "getHeadersGuard");
  Reflect.deleteProperty(Headers2, "setHeadersGuard");
  Reflect.deleteProperty(Headers2, "getHeadersList");
  Reflect.deleteProperty(Headers2, "setHeadersList");
  iteratorMixin("Headers", Headers2, kHeadersSortedMap, 0, 1);
  Object.defineProperties(Headers2.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    getSetCookie: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: true
    },
    [util2.inspect.custom]: {
      enumerable: false
    }
  });
  webidl.converters.HeadersInit = function(V, prefix, argument) {
    if (webidl.util.Type(V) === "Object") {
      const iterator = Reflect.get(V, Symbol.iterator);
      if (!util2.types.isProxy(V) && iterator === Headers2.prototype.entries) {
        try {
          return getHeadersList(V).entriesList;
        } catch {
        }
      }
      if (typeof iterator === "function") {
        return webidl.converters["sequence<sequence<ByteString>>"](V, prefix, argument, iterator.bind(V));
      }
      return webidl.converters["record<ByteString, ByteString>"](V, prefix, argument);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  headers = {
    fill,
    // for test.
    compareHeaderName,
    Headers: Headers2,
    HeadersList,
    getHeadersGuard,
    setHeadersGuard,
    setHeadersList,
    getHeadersList
  };
  return headers;
}
var response;
var hasRequiredResponse;
function requireResponse() {
  if (hasRequiredResponse) return response;
  hasRequiredResponse = 1;
  const { Headers: Headers2, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = requireHeaders();
  const { extractBody, cloneBody, mixinBody } = requireBody();
  const util2 = requireUtil$7();
  const nodeUtil = require$$0$5;
  const { kEnumerableProperty } = util2;
  const {
    isValidReasonPhrase,
    isCancelled,
    isAborted,
    isBlobLike,
    serializeJavascriptValueToJSONString,
    isErrorLike,
    isomorphicEncode,
    environmentSettingsObject: relevantRealm
  } = requireUtil$6();
  const {
    redirectStatusSet,
    nullBodyStatus
  } = requireConstants$2();
  const { kState, kHeaders } = requireSymbols$3();
  const { webidl } = requireWebidl();
  const { FormData } = requireFormdata();
  const { URLSerializer } = requireDataUrl();
  const { kConstruct } = requireSymbols$4();
  const assert = require$$0$3;
  const { types: types2 } = require$$0$5;
  const { isDisturbed, isErrored } = require$$0$4;
  const textEncoder = new TextEncoder("utf-8");
  const hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0;
  let registry;
  if (hasFinalizationRegistry) {
    registry = new FinalizationRegistry((stream) => {
      if (!stream.locked && !isDisturbed(stream) && !isErrored(stream)) {
        stream.cancel("Response object has been garbage collected").catch(noop);
      }
    });
  }
  function noop() {
  }
  class Response2 {
    // Creates network error Response.
    static error() {
      const responseObject = fromInnerResponse(makeNetworkError(), "immutable");
      return responseObject;
    }
    // https://fetch.spec.whatwg.org/#dom-response-json
    static json(data, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, "Response.json");
      if (init !== null) {
        init = webidl.converters.ResponseInit(init);
      }
      const bytes = textEncoder.encode(
        serializeJavascriptValueToJSONString(data)
      );
      const body2 = extractBody(bytes);
      const responseObject = fromInnerResponse(makeResponse({}), "response");
      initializeResponse(responseObject, init, { body: body2[0], type: "application/json" });
      return responseObject;
    }
    // Creates a redirect Response that redirects to url with status status.
    static redirect(url, status = 302) {
      webidl.argumentLengthCheck(arguments, 1, "Response.redirect");
      url = webidl.converters.USVString(url);
      status = webidl.converters["unsigned short"](status);
      let parsedURL;
      try {
        parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl);
      } catch (err) {
        throw new TypeError(`Failed to parse URL from ${url}`, { cause: err });
      }
      if (!redirectStatusSet.has(status)) {
        throw new RangeError(`Invalid status code ${status}`);
      }
      const responseObject = fromInnerResponse(makeResponse({}), "immutable");
      responseObject[kState].status = status;
      const value = isomorphicEncode(URLSerializer(parsedURL));
      responseObject[kState].headersList.append("location", value, true);
      return responseObject;
    }
    // https://fetch.spec.whatwg.org/#dom-response
    constructor(body2 = null, init = {}) {
      if (body2 === kConstruct) {
        return;
      }
      if (body2 !== null) {
        body2 = webidl.converters.BodyInit(body2);
      }
      init = webidl.converters.ResponseInit(init);
      this[kState] = makeResponse({});
      this[kHeaders] = new Headers2(kConstruct);
      setHeadersGuard(this[kHeaders], "response");
      setHeadersList(this[kHeaders], this[kState].headersList);
      let bodyWithType = null;
      if (body2 != null) {
        const [extractedBody, type] = extractBody(body2);
        bodyWithType = { body: extractedBody, type };
      }
      initializeResponse(this, init, bodyWithType);
    }
    // Returns responseâs type, e.g., "cors".
    get type() {
      webidl.brandCheck(this, Response2);
      return this[kState].type;
    }
    // Returns responseâs URL, if it has one; otherwise the empty string.
    get url() {
      webidl.brandCheck(this, Response2);
      const urlList = this[kState].urlList;
      const url = urlList[urlList.length - 1] ?? null;
      if (url === null) {
        return "";
      }
      return URLSerializer(url, true);
    }
    // Returns whether response was obtained through a redirect.
    get redirected() {
      webidl.brandCheck(this, Response2);
      return this[kState].urlList.length > 1;
    }
    // Returns responseâs status.
    get status() {
      webidl.brandCheck(this, Response2);
      return this[kState].status;
    }
    // Returns whether responseâs status is an ok status.
    get ok() {
      webidl.brandCheck(this, Response2);
      return this[kState].status >= 200 && this[kState].status <= 299;
    }
    // Returns responseâs status message.
    get statusText() {
      webidl.brandCheck(this, Response2);
      return this[kState].statusText;
    }
    // Returns responseâs headers as Headers.
    get headers() {
      webidl.brandCheck(this, Response2);
      return this[kHeaders];
    }
    get body() {
      webidl.brandCheck(this, Response2);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Response2);
      return !!this[kState].body && util2.isDisturbed(this[kState].body.stream);
    }
    // Returns a clone of response.
    clone() {
      webidl.brandCheck(this, Response2);
      if (this.bodyUsed || this.body?.locked) {
        throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      }
      const clonedResponse = cloneResponse(this[kState]);
      return fromInnerResponse(clonedResponse, getHeadersGuard(this[kHeaders]));
    }
    [nodeUtil.inspect.custom](depth, options) {
      if (options.depth === null) {
        options.depth = 2;
      }
      options.colors ??= true;
      const properties = {
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        body: this.body,
        bodyUsed: this.bodyUsed,
        ok: this.ok,
        redirected: this.redirected,
        type: this.type,
        url: this.url
      };
      return `Response ${nodeUtil.formatWithOptions(options, properties)}`;
    }
  }
  mixinBody(Response2);
  Object.defineProperties(Response2.prototype, {
    type: kEnumerableProperty,
    url: kEnumerableProperty,
    status: kEnumerableProperty,
    ok: kEnumerableProperty,
    redirected: kEnumerableProperty,
    statusText: kEnumerableProperty,
    headers: kEnumerableProperty,
    clone: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: true
    }
  });
  Object.defineProperties(Response2, {
    json: kEnumerableProperty,
    redirect: kEnumerableProperty,
    error: kEnumerableProperty
  });
  function cloneResponse(response2) {
    if (response2.internalResponse) {
      return filterResponse(
        cloneResponse(response2.internalResponse),
        response2.type
      );
    }
    const newResponse = makeResponse({ ...response2, body: null });
    if (response2.body != null) {
      newResponse.body = cloneBody(response2.body);
    }
    return newResponse;
  }
  function makeResponse(init) {
    return {
      aborted: false,
      rangeRequested: false,
      timingAllowPassed: false,
      requestIncludesCredentials: false,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: init?.headersList ? new HeadersList(init?.headersList) : new HeadersList(),
      urlList: init?.urlList ? [...init.urlList] : []
    };
  }
  function makeNetworkError(reason) {
    const isError2 = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError2 ? reason : new Error(reason ? String(reason) : reason),
      aborted: reason && reason.name === "AbortError"
    });
  }
  function isNetworkError(response2) {
    return (
      // A network error is a response whose type is "error",
      response2.type === "error" && // status is 0
      response2.status === 0
    );
  }
  function makeFilteredResponse(response2, state) {
    state = {
      internalResponse: response2,
      ...state
    };
    return new Proxy(response2, {
      get(target, p) {
        return p in state ? state[p] : target[p];
      },
      set(target, p, value) {
        assert(!(p in state));
        target[p] = value;
        return true;
      }
    });
  }
  function filterResponse(response2, type) {
    if (type === "basic") {
      return makeFilteredResponse(response2, {
        type: "basic",
        headersList: response2.headersList
      });
    } else if (type === "cors") {
      return makeFilteredResponse(response2, {
        type: "cors",
        headersList: response2.headersList
      });
    } else if (type === "opaque") {
      return makeFilteredResponse(response2, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    } else if (type === "opaqueredirect") {
      return makeFilteredResponse(response2, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    } else {
      assert(false);
    }
  }
  function makeAppropriateNetworkError(fetchParams, err = null) {
    assert(isCancelled(fetchParams));
    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException("Request was cancelled."), { cause: err }));
  }
  function initializeResponse(response2, init, body2) {
    if (init.status !== null && (init.status < 200 || init.status > 599)) {
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    }
    if ("statusText" in init && init.statusText != null) {
      if (!isValidReasonPhrase(String(init.statusText))) {
        throw new TypeError("Invalid statusText");
      }
    }
    if ("status" in init && init.status != null) {
      response2[kState].status = init.status;
    }
    if ("statusText" in init && init.statusText != null) {
      response2[kState].statusText = init.statusText;
    }
    if ("headers" in init && init.headers != null) {
      fill(response2[kHeaders], init.headers);
    }
    if (body2) {
      if (nullBodyStatus.includes(response2.status)) {
        throw webidl.errors.exception({
          header: "Response constructor",
          message: `Invalid response status code ${response2.status}`
        });
      }
      response2[kState].body = body2.body;
      if (body2.type != null && !response2[kState].headersList.contains("content-type", true)) {
        response2[kState].headersList.append("content-type", body2.type, true);
      }
    }
  }
  function fromInnerResponse(innerResponse, guard) {
    const response2 = new Response2(kConstruct);
    response2[kState] = innerResponse;
    response2[kHeaders] = new Headers2(kConstruct);
    setHeadersList(response2[kHeaders], innerResponse.headersList);
    setHeadersGuard(response2[kHeaders], guard);
    if (hasFinalizationRegistry && innerResponse.body?.stream) {
      registry.register(response2, innerResponse.body.stream);
    }
    return response2;
  }
  webidl.converters.ReadableStream = webidl.interfaceConverter(
    ReadableStream
  );
  webidl.converters.FormData = webidl.interfaceConverter(
    FormData
  );
  webidl.converters.URLSearchParams = webidl.interfaceConverter(
    URLSearchParams
  );
  webidl.converters.XMLHttpRequestBodyInit = function(V, prefix, name) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V, prefix, name);
    }
    if (isBlobLike(V)) {
      return webidl.converters.Blob(V, prefix, name, { strict: false });
    }
    if (ArrayBuffer.isView(V) || types2.isArrayBuffer(V)) {
      return webidl.converters.BufferSource(V, prefix, name);
    }
    if (util2.isFormDataLike(V)) {
      return webidl.converters.FormData(V, prefix, name, { strict: false });
    }
    if (V instanceof URLSearchParams) {
      return webidl.converters.URLSearchParams(V, prefix, name);
    }
    return webidl.converters.DOMString(V, prefix, name);
  };
  webidl.converters.BodyInit = function(V, prefix, argument) {
    if (V instanceof ReadableStream) {
      return webidl.converters.ReadableStream(V, prefix, argument);
    }
    if (V?.[Symbol.asyncIterator]) {
      return V;
    }
    return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([
    {
      key: "status",
      converter: webidl.converters["unsigned short"],
      defaultValue: () => 200
    },
    {
      key: "statusText",
      converter: webidl.converters.ByteString,
      defaultValue: () => ""
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    }
  ]);
  response = {
    isNetworkError,
    makeNetworkError,
    makeResponse,
    makeAppropriateNetworkError,
    filterResponse,
    Response: Response2,
    cloneResponse,
    fromInnerResponse
  };
  return response;
}
var dispatcherWeakref;
var hasRequiredDispatcherWeakref;
function requireDispatcherWeakref() {
  if (hasRequiredDispatcherWeakref) return dispatcherWeakref;
  hasRequiredDispatcherWeakref = 1;
  const { kConnected, kSize } = requireSymbols$4();
  class CompatWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
    }
  }
  class CompatFinalizer {
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
    register(dispatcher2, key) {
      if (dispatcher2.on) {
        dispatcher2.on("disconnect", () => {
          if (dispatcher2[kConnected] === 0 && dispatcher2[kSize] === 0) {
            this.finalizer(key);
          }
        });
      }
    }
    unregister(key) {
    }
  }
  dispatcherWeakref = function() {
    if (process.env.NODE_V8_COVERAGE && process.version.startsWith("v18")) {
      process._rawDebug("Using compatibility WeakRef and FinalizationRegistry");
      return {
        WeakRef: CompatWeakRef,
        FinalizationRegistry: CompatFinalizer
      };
    }
    return { WeakRef, FinalizationRegistry };
  };
  return dispatcherWeakref;
}
var request;
var hasRequiredRequest;
function requireRequest() {
  if (hasRequiredRequest) return request;
  hasRequiredRequest = 1;
  const { extractBody, mixinBody, cloneBody } = requireBody();
  const { Headers: Headers2, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = requireHeaders();
  const { FinalizationRegistry: FinalizationRegistry2 } = requireDispatcherWeakref()();
  const util2 = requireUtil$7();
  const nodeUtil = require$$0$5;
  const {
    isValidHTTPToken,
    sameOrigin,
    environmentSettingsObject
  } = requireUtil$6();
  const {
    forbiddenMethodsSet,
    corsSafeListedMethodsSet,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    requestDuplex
  } = requireConstants$2();
  const { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util2;
  const { kHeaders, kSignal, kState, kDispatcher } = requireSymbols$3();
  const { webidl } = requireWebidl();
  const { URLSerializer } = requireDataUrl();
  const { kConstruct } = requireSymbols$4();
  const assert = require$$0$3;
  const { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require$$8;
  const kAbortController = Symbol("abortController");
  const requestFinalizer = new FinalizationRegistry2(({ signal, abort }) => {
    signal.removeEventListener("abort", abort);
  });
  const dependentControllerMap = /* @__PURE__ */ new WeakMap();
  function buildAbort(acRef) {
    return abort;
    function abort() {
      const ac = acRef.deref();
      if (ac !== void 0) {
        requestFinalizer.unregister(abort);
        this.removeEventListener("abort", abort);
        ac.abort(this.reason);
        const controllerList = dependentControllerMap.get(ac.signal);
        if (controllerList !== void 0) {
          if (controllerList.size !== 0) {
            for (const ref of controllerList) {
              const ctrl = ref.deref();
              if (ctrl !== void 0) {
                ctrl.abort(this.reason);
              }
            }
            controllerList.clear();
          }
          dependentControllerMap.delete(ac.signal);
        }
      }
    }
  }
  let patchMethodWarning = false;
  class Request2 {
    // https://fetch.spec.whatwg.org/#dom-request
    constructor(input, init = {}) {
      if (input === kConstruct) {
        return;
      }
      const prefix = "Request constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      input = webidl.converters.RequestInfo(input, prefix, "input");
      init = webidl.converters.RequestInit(init, prefix, "init");
      let request2 = null;
      let fallbackMode = null;
      const baseUrl = environmentSettingsObject.settingsObject.baseUrl;
      let signal = null;
      if (typeof input === "string") {
        this[kDispatcher] = init.dispatcher;
        let parsedURL;
        try {
          parsedURL = new URL(input, baseUrl);
        } catch (err) {
          throw new TypeError("Failed to parse URL from " + input, { cause: err });
        }
        if (parsedURL.username || parsedURL.password) {
          throw new TypeError(
            "Request cannot be constructed from a URL that includes credentials: " + input
          );
        }
        request2 = makeRequest2({ urlList: [parsedURL] });
        fallbackMode = "cors";
      } else {
        this[kDispatcher] = init.dispatcher || input[kDispatcher];
        assert(input instanceof Request2);
        request2 = input[kState];
        signal = input[kSignal];
      }
      const origin = environmentSettingsObject.settingsObject.origin;
      let window2 = "client";
      if (request2.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request2.window, origin)) {
        window2 = request2.window;
      }
      if (init.window != null) {
        throw new TypeError(`'window' option '${window2}' must be null`);
      }
      if ("window" in init) {
        window2 = "no-window";
      }
      request2 = makeRequest2({
        // URL requestâs URL.
        // undici implementation note: this is set as the first item in request's urlList in makeRequest
        // method requestâs method.
        method: request2.method,
        // header list A copy of requestâs header list.
        // undici implementation note: headersList is cloned in makeRequest
        headersList: request2.headersList,
        // unsafe-request flag Set.
        unsafeRequest: request2.unsafeRequest,
        // client Thisâs relevant settings object.
        client: environmentSettingsObject.settingsObject,
        // window window.
        window: window2,
        // priority requestâs priority.
        priority: request2.priority,
        // origin requestâs origin. The propagation of the origin is only significant for navigation requests
        // being handled by a service worker. In this scenario a request can have an origin that is different
        // from the current client.
        origin: request2.origin,
        // referrer requestâs referrer.
        referrer: request2.referrer,
        // referrer policy requestâs referrer policy.
        referrerPolicy: request2.referrerPolicy,
        // mode requestâs mode.
        mode: request2.mode,
        // credentials mode requestâs credentials mode.
        credentials: request2.credentials,
        // cache mode requestâs cache mode.
        cache: request2.cache,
        // redirect mode requestâs redirect mode.
        redirect: request2.redirect,
        // integrity metadata requestâs integrity metadata.
        integrity: request2.integrity,
        // keepalive requestâs keepalive.
        keepalive: request2.keepalive,
        // reload-navigation flag requestâs reload-navigation flag.
        reloadNavigation: request2.reloadNavigation,
        // history-navigation flag requestâs history-navigation flag.
        historyNavigation: request2.historyNavigation,
        // URL list A clone of requestâs URL list.
        urlList: [...request2.urlList]
      });
      const initHasKey = Object.keys(init).length !== 0;
      if (initHasKey) {
        if (request2.mode === "navigate") {
          request2.mode = "same-origin";
        }
        request2.reloadNavigation = false;
        request2.historyNavigation = false;
        request2.origin = "client";
        request2.referrer = "client";
        request2.referrerPolicy = "";
        request2.url = request2.urlList[request2.urlList.length - 1];
        request2.urlList = [request2.url];
      }
      if (init.referrer !== void 0) {
        const referrer = init.referrer;
        if (referrer === "") {
          request2.referrer = "no-referrer";
        } else {
          let parsedReferrer;
          try {
            parsedReferrer = new URL(referrer, baseUrl);
          } catch (err) {
            throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
          }
          if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) {
            request2.referrer = "client";
          } else {
            request2.referrer = parsedReferrer;
          }
        }
      }
      if (init.referrerPolicy !== void 0) {
        request2.referrerPolicy = init.referrerPolicy;
      }
      let mode;
      if (init.mode !== void 0) {
        mode = init.mode;
      } else {
        mode = fallbackMode;
      }
      if (mode === "navigate") {
        throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      }
      if (mode != null) {
        request2.mode = mode;
      }
      if (init.credentials !== void 0) {
        request2.credentials = init.credentials;
      }
      if (init.cache !== void 0) {
        request2.cache = init.cache;
      }
      if (request2.cache === "only-if-cached" && request2.mode !== "same-origin") {
        throw new TypeError(
          "'only-if-cached' can be set only with 'same-origin' mode"
        );
      }
      if (init.redirect !== void 0) {
        request2.redirect = init.redirect;
      }
      if (init.integrity != null) {
        request2.integrity = String(init.integrity);
      }
      if (init.keepalive !== void 0) {
        request2.keepalive = Boolean(init.keepalive);
      }
      if (init.method !== void 0) {
        let method = init.method;
        const mayBeNormalized = normalizedMethodRecords[method];
        if (mayBeNormalized !== void 0) {
          request2.method = mayBeNormalized;
        } else {
          if (!isValidHTTPToken(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          const upperCase = method.toUpperCase();
          if (forbiddenMethodsSet.has(upperCase)) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = normalizedMethodRecordsBase[upperCase] ?? method;
          request2.method = method;
        }
        if (!patchMethodWarning && request2.method === "patch") {
          process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", {
            code: "UNDICI-FETCH-patch"
          });
          patchMethodWarning = true;
        }
      }
      if (init.signal !== void 0) {
        signal = init.signal;
      }
      this[kState] = request2;
      const ac = new AbortController();
      this[kSignal] = ac.signal;
      if (signal != null) {
        if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
          throw new TypeError(
            "Failed to construct 'Request': member signal is not of type AbortSignal."
          );
        }
        if (signal.aborted) {
          ac.abort(signal.reason);
        } else {
          this[kAbortController] = ac;
          const acRef = new WeakRef(ac);
          const abort = buildAbort(acRef);
          try {
            if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
              setMaxListeners(1500, signal);
            } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
              setMaxListeners(1500, signal);
            }
          } catch {
          }
          util2.addAbortListener(signal, abort);
          requestFinalizer.register(ac, { signal, abort }, abort);
        }
      }
      this[kHeaders] = new Headers2(kConstruct);
      setHeadersList(this[kHeaders], request2.headersList);
      setHeadersGuard(this[kHeaders], "request");
      if (mode === "no-cors") {
        if (!corsSafeListedMethodsSet.has(request2.method)) {
          throw new TypeError(
            `'${request2.method} is unsupported in no-cors mode.`
          );
        }
        setHeadersGuard(this[kHeaders], "request-no-cors");
      }
      if (initHasKey) {
        const headersList = getHeadersList(this[kHeaders]);
        const headers2 = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
        headersList.clear();
        if (headers2 instanceof HeadersList) {
          for (const { name, value } of headers2.rawValues()) {
            headersList.append(name, value, false);
          }
          headersList.cookies = headers2.cookies;
        } else {
          fillHeaders(this[kHeaders], headers2);
        }
      }
      const inputBody = input instanceof Request2 ? input[kState].body : null;
      if ((init.body != null || inputBody != null) && (request2.method === "GET" || request2.method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      }
      let initBody = null;
      if (init.body != null) {
        const [extractedBody, contentType] = extractBody(
          init.body,
          request2.keepalive
        );
        initBody = extractedBody;
        if (contentType && !getHeadersList(this[kHeaders]).contains("content-type", true)) {
          this[kHeaders].append("content-type", contentType);
        }
      }
      const inputOrInitBody = initBody ?? inputBody;
      if (inputOrInitBody != null && inputOrInitBody.source == null) {
        if (initBody != null && init.duplex == null) {
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        }
        if (request2.mode !== "same-origin" && request2.mode !== "cors") {
          throw new TypeError(
            'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
          );
        }
        request2.useCORSPreflightFlag = true;
      }
      let finalBody = inputOrInitBody;
      if (initBody == null && inputBody != null) {
        if (util2.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
          throw new TypeError(
            "Cannot construct a Request with a Request object that has already been used."
          );
        }
        const identityTransform = new TransformStream();
        inputBody.stream.pipeThrough(identityTransform);
        finalBody = {
          source: inputBody.source,
          length: inputBody.length,
          stream: identityTransform.readable
        };
      }
      this[kState].body = finalBody;
    }
    // Returns requestâs HTTP method, which is "GET" by default.
    get method() {
      webidl.brandCheck(this, Request2);
      return this[kState].method;
    }
    // Returns the URL of request as a string.
    get url() {
      webidl.brandCheck(this, Request2);
      return URLSerializer(this[kState].url);
    }
    // Returns a Headers object consisting of the headers associated with request.
    // Note that headers added in the network layer by the user agent will not
    // be accounted for in this object, e.g., the "Host" header.
    get headers() {
      webidl.brandCheck(this, Request2);
      return this[kHeaders];
    }
    // Returns the kind of resource requested by request, e.g., "document"
    // or "script".
    get destination() {
      webidl.brandCheck(this, Request2);
      return this[kState].destination;
    }
    // Returns the referrer of request. Its value can be a same-origin URL if
    // explicitly set in init, the empty string to indicate no referrer, and
    // "about:client" when defaulting to the globalâs default. This is used
    // during fetching to determine the value of the `Referer` header of the
    // request being made.
    get referrer() {
      webidl.brandCheck(this, Request2);
      if (this[kState].referrer === "no-referrer") {
        return "";
      }
      if (this[kState].referrer === "client") {
        return "about:client";
      }
      return this[kState].referrer.toString();
    }
    // Returns the referrer policy associated with request.
    // This is used during fetching to compute the value of the requestâs
    // referrer.
    get referrerPolicy() {
      webidl.brandCheck(this, Request2);
      return this[kState].referrerPolicy;
    }
    // Returns the mode associated with request, which is a string indicating
    // whether the request will use CORS, or will be restricted to same-origin
    // URLs.
    get mode() {
      webidl.brandCheck(this, Request2);
      return this[kState].mode;
    }
    // Returns the credentials mode associated with request,
    // which is a string indicating whether credentials will be sent with the
    // request always, never, or only when sent to a same-origin URL.
    get credentials() {
      return this[kState].credentials;
    }
    // Returns the cache mode associated with request,
    // which is a string indicating how the request will
    // interact with the browserâs cache when fetching.
    get cache() {
      webidl.brandCheck(this, Request2);
      return this[kState].cache;
    }
    // Returns the redirect mode associated with request,
    // which is a string indicating how redirects for the
    // request will be handled during fetching. A request
    // will follow redirects by default.
    get redirect() {
      webidl.brandCheck(this, Request2);
      return this[kState].redirect;
    }
    // Returns requestâs subresource integrity metadata, which is a
    // cryptographic hash of the resource being fetched. Its value
    // consists of multiple hashes separated by whitespace. [SRI]
    get integrity() {
      webidl.brandCheck(this, Request2);
      return this[kState].integrity;
    }
    // Returns a boolean indicating whether or not request can outlive the
    // global in which it was created.
    get keepalive() {
      webidl.brandCheck(this, Request2);
      return this[kState].keepalive;
    }
    // Returns a boolean indicating whether or not request is for a reload
    // navigation.
    get isReloadNavigation() {
      webidl.brandCheck(this, Request2);
      return this[kState].reloadNavigation;
    }
    // Returns a boolean indicating whether or not request is for a history
    // navigation (a.k.a. back-forward navigation).
    get isHistoryNavigation() {
      webidl.brandCheck(this, Request2);
      return this[kState].historyNavigation;
    }
    // Returns the signal associated with request, which is an AbortSignal
    // object indicating whether or not request has been aborted, and its
    // abort event handler.
    get signal() {
      webidl.brandCheck(this, Request2);
      return this[kSignal];
    }
    get body() {
      webidl.brandCheck(this, Request2);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Request2);
      return !!this[kState].body && util2.isDisturbed(this[kState].body.stream);
    }
    get duplex() {
      webidl.brandCheck(this, Request2);
      return "half";
    }
    // Returns a clone of request.
    clone() {
      webidl.brandCheck(this, Request2);
      if (this.bodyUsed || this.body?.locked) {
        throw new TypeError("unusable");
      }
      const clonedRequest = cloneRequest(this[kState]);
      const ac = new AbortController();
      if (this.signal.aborted) {
        ac.abort(this.signal.reason);
      } else {
        let list = dependentControllerMap.get(this.signal);
        if (list === void 0) {
          list = /* @__PURE__ */ new Set();
          dependentControllerMap.set(this.signal, list);
        }
        const acRef = new WeakRef(ac);
        list.add(acRef);
        util2.addAbortListener(
          ac.signal,
          buildAbort(acRef)
        );
      }
      return fromInnerRequest(clonedRequest, ac.signal, getHeadersGuard(this[kHeaders]));
    }
    [nodeUtil.inspect.custom](depth, options) {
      if (options.depth === null) {
        options.depth = 2;
      }
      options.colors ??= true;
      const properties = {
        method: this.method,
        url: this.url,
        headers: this.headers,
        destination: this.destination,
        referrer: this.referrer,
        referrerPolicy: this.referrerPolicy,
        mode: this.mode,
        credentials: this.credentials,
        cache: this.cache,
        redirect: this.redirect,
        integrity: this.integrity,
        keepalive: this.keepalive,
        isReloadNavigation: this.isReloadNavigation,
        isHistoryNavigation: this.isHistoryNavigation,
        signal: this.signal
      };
      return `Request ${nodeUtil.formatWithOptions(options, properties)}`;
    }
  }
  mixinBody(Request2);
  function makeRequest2(init) {
    return {
      method: init.method ?? "GET",
      localURLsOnly: init.localURLsOnly ?? false,
      unsafeRequest: init.unsafeRequest ?? false,
      body: init.body ?? null,
      client: init.client ?? null,
      reservedClient: init.reservedClient ?? null,
      replacesClientId: init.replacesClientId ?? "",
      window: init.window ?? "client",
      keepalive: init.keepalive ?? false,
      serviceWorkers: init.serviceWorkers ?? "all",
      initiator: init.initiator ?? "",
      destination: init.destination ?? "",
      priority: init.priority ?? null,
      origin: init.origin ?? "client",
      policyContainer: init.policyContainer ?? "client",
      referrer: init.referrer ?? "client",
      referrerPolicy: init.referrerPolicy ?? "",
      mode: init.mode ?? "no-cors",
      useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,
      credentials: init.credentials ?? "same-origin",
      useCredentials: init.useCredentials ?? false,
      cache: init.cache ?? "default",
      redirect: init.redirect ?? "follow",
      integrity: init.integrity ?? "",
      cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? "",
      parserMetadata: init.parserMetadata ?? "",
      reloadNavigation: init.reloadNavigation ?? false,
      historyNavigation: init.historyNavigation ?? false,
      userActivation: init.userActivation ?? false,
      taintedOrigin: init.taintedOrigin ?? false,
      redirectCount: init.redirectCount ?? 0,
      responseTainting: init.responseTainting ?? "basic",
      preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,
      done: init.done ?? false,
      timingAllowFailed: init.timingAllowFailed ?? false,
      urlList: init.urlList,
      url: init.urlList[0],
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
    };
  }
  function cloneRequest(request2) {
    const newRequest = makeRequest2({ ...request2, body: null });
    if (request2.body != null) {
      newRequest.body = cloneBody(request2.body);
    }
    return newRequest;
  }
  function fromInnerRequest(innerRequest, signal, guard) {
    const request2 = new Request2(kConstruct);
    request2[kState] = innerRequest;
    request2[kSignal] = signal;
    request2[kHeaders] = new Headers2(kConstruct);
    setHeadersList(request2[kHeaders], innerRequest.headersList);
    setHeadersGuard(request2[kHeaders], guard);
    return request2;
  }
  Object.defineProperties(Request2.prototype, {
    method: kEnumerableProperty,
    url: kEnumerableProperty,
    headers: kEnumerableProperty,
    redirect: kEnumerableProperty,
    clone: kEnumerableProperty,
    signal: kEnumerableProperty,
    duplex: kEnumerableProperty,
    destination: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    isHistoryNavigation: kEnumerableProperty,
    isReloadNavigation: kEnumerableProperty,
    keepalive: kEnumerableProperty,
    integrity: kEnumerableProperty,
    cache: kEnumerableProperty,
    credentials: kEnumerableProperty,
    attribute: kEnumerableProperty,
    referrerPolicy: kEnumerableProperty,
    referrer: kEnumerableProperty,
    mode: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: true
    }
  });
  webidl.converters.Request = webidl.interfaceConverter(
    Request2
  );
  webidl.converters.RequestInfo = function(V, prefix, argument) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V, prefix, argument);
    }
    if (V instanceof Request2) {
      return webidl.converters.Request(V, prefix, argument);
    }
    return webidl.converters.USVString(V, prefix, argument);
  };
  webidl.converters.AbortSignal = webidl.interfaceConverter(
    AbortSignal
  );
  webidl.converters.RequestInit = webidl.dictionaryConverter([
    {
      key: "method",
      converter: webidl.converters.ByteString
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    },
    {
      key: "body",
      converter: webidl.nullableConverter(
        webidl.converters.BodyInit
      )
    },
    {
      key: "referrer",
      converter: webidl.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: webidl.converters.DOMString,
      // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
      allowedValues: referrerPolicy
    },
    {
      key: "mode",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#concept-request-mode
      allowedValues: requestMode
    },
    {
      key: "credentials",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcredentials
      allowedValues: requestCredentials
    },
    {
      key: "cache",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcache
      allowedValues: requestCache
    },
    {
      key: "redirect",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestredirect
      allowedValues: requestRedirect
    },
    {
      key: "integrity",
      converter: webidl.converters.DOMString
    },
    {
      key: "keepalive",
      converter: webidl.converters.boolean
    },
    {
      key: "signal",
      converter: webidl.nullableConverter(
        (signal) => webidl.converters.AbortSignal(
          signal,
          "RequestInit",
          "signal",
          { strict: false }
        )
      )
    },
    {
      key: "window",
      converter: webidl.converters.any
    },
    {
      key: "duplex",
      converter: webidl.converters.DOMString,
      allowedValues: requestDuplex
    },
    {
      key: "dispatcher",
      // undici specific option
      converter: webidl.converters.any
    }
  ]);
  request = { Request: Request2, makeRequest: makeRequest2, fromInnerRequest, cloneRequest };
  return request;
}
var fetch_1;
var hasRequiredFetch;
function requireFetch() {
  if (hasRequiredFetch) return fetch_1;
  hasRequiredFetch = 1;
  const {
    makeNetworkError,
    makeAppropriateNetworkError,
    filterResponse,
    makeResponse,
    fromInnerResponse
  } = requireResponse();
  const { HeadersList } = requireHeaders();
  const { Request: Request2, cloneRequest } = requireRequest();
  const zlib = require$$1$2;
  const {
    bytesMatch,
    makePolicyContainer,
    clonePolicyContainer,
    requestBadPort,
    TAOCheck,
    appendRequestOriginHeader,
    responseLocationURL,
    requestCurrentURL,
    setRequestReferrerPolicyOnRedirect,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    createOpaqueTimingInfo,
    appendFetchMetadata,
    corsCheck,
    crossOriginResourcePolicyCheck,
    determineRequestsReferrer,
    coarsenedSharedCurrentTime,
    createDeferredPromise,
    isBlobLike,
    sameOrigin,
    isCancelled,
    isAborted,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlIsHttpHttpsScheme,
    urlHasHttpsScheme,
    clampAndCoarsenConnectionTimingInfo,
    simpleRangeHeaderValue,
    buildContentRange,
    createInflate,
    extractMimeType
  } = requireUtil$6();
  const { kState, kDispatcher } = requireSymbols$3();
  const assert = require$$0$3;
  const { safelyExtractBody, extractBody } = requireBody();
  const {
    redirectStatusSet,
    nullBodyStatus,
    safeMethodsSet,
    requestBodyHeader,
    subresourceSet
  } = requireConstants$2();
  const EE = require$$8;
  const { Readable, pipeline, finished } = require$$0$4;
  const { addAbortListener, isErrored, isReadable, bufferToLowerCasedHeaderName } = requireUtil$7();
  const { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = requireDataUrl();
  const { getGlobalDispatcher } = requireGlobal();
  const { webidl } = requireWebidl();
  const { STATUS_CODES } = require$$2;
  const GET_OR_HEAD = ["GET", "HEAD"];
  const defaultUserAgent = typeof __UNDICI_IS_NODE__ !== "undefined" || typeof esbuildDetection !== "undefined" ? "node" : "undici";
  let resolveObjectURL;
  class Fetch extends EE {
    constructor(dispatcher2) {
      super();
      this.dispatcher = dispatcher2;
      this.connection = null;
      this.dump = false;
      this.state = "ongoing";
    }
    terminate(reason) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "terminated";
      this.connection?.destroy(reason);
      this.emit("terminated", reason);
    }
    // https://fetch.spec.whatwg.org/#fetch-controller-abort
    abort(error) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "aborted";
      if (!error) {
        error = new DOMException("The operation was aborted.", "AbortError");
      }
      this.serializedAbortReason = error;
      this.connection?.destroy(error);
      this.emit("terminated", error);
    }
  }
  function handleFetchDone(response2) {
    finalizeAndReportTiming(response2, "fetch");
  }
  function fetch2(input, init = void 0) {
    webidl.argumentLengthCheck(arguments, 1, "globalThis.fetch");
    let p = createDeferredPromise();
    let requestObject;
    try {
      requestObject = new Request2(input, init);
    } catch (e) {
      p.reject(e);
      return p.promise;
    }
    const request2 = requestObject[kState];
    if (requestObject.signal.aborted) {
      abortFetch(p, request2, null, requestObject.signal.reason);
      return p.promise;
    }
    const globalObject = request2.client.globalObject;
    if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
      request2.serviceWorkers = "none";
    }
    let responseObject = null;
    let locallyAborted = false;
    let controller = null;
    addAbortListener(
      requestObject.signal,
      () => {
        locallyAborted = true;
        assert(controller != null);
        controller.abort(requestObject.signal.reason);
        const realResponse = responseObject?.deref();
        abortFetch(p, request2, realResponse, requestObject.signal.reason);
      }
    );
    const processResponse = (response2) => {
      if (locallyAborted) {
        return;
      }
      if (response2.aborted) {
        abortFetch(p, request2, responseObject, controller.serializedAbortReason);
        return;
      }
      if (response2.type === "error") {
        p.reject(new TypeError("fetch failed", { cause: response2.error }));
        return;
      }
      responseObject = new WeakRef(fromInnerResponse(response2, "immutable"));
      p.resolve(responseObject.deref());
      p = null;
    };
    controller = fetching({
      request: request2,
      processResponseEndOfBody: handleFetchDone,
      processResponse,
      dispatcher: requestObject[kDispatcher]
      // undici
    });
    return p.promise;
  }
  function finalizeAndReportTiming(response2, initiatorType = "other") {
    if (response2.type === "error" && response2.aborted) {
      return;
    }
    if (!response2.urlList?.length) {
      return;
    }
    const originalURL = response2.urlList[0];
    let timingInfo = response2.timingInfo;
    let cacheState = response2.cacheState;
    if (!urlIsHttpHttpsScheme(originalURL)) {
      return;
    }
    if (timingInfo === null) {
      return;
    }
    if (!response2.timingAllowPassed) {
      timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      });
      cacheState = "";
    }
    timingInfo.endTime = coarsenedSharedCurrentTime();
    response2.timingInfo = timingInfo;
    markResourceTiming(
      timingInfo,
      originalURL.href,
      initiatorType,
      globalThis,
      cacheState
    );
  }
  const markResourceTiming = performance.markResourceTiming;
  function abortFetch(p, request2, responseObject, error) {
    if (p) {
      p.reject(error);
    }
    if (request2.body != null && isReadable(request2.body?.stream)) {
      request2.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
    if (responseObject == null) {
      return;
    }
    const response2 = responseObject[kState];
    if (response2.body != null && isReadable(response2.body?.stream)) {
      response2.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
  }
  function fetching({
    request: request2,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseEndOfBody,
    processResponseConsumeBody,
    useParallelQueue = false,
    dispatcher: dispatcher2 = getGlobalDispatcher()
    // undici
  }) {
    assert(dispatcher2);
    let taskDestination = null;
    let crossOriginIsolatedCapability = false;
    if (request2.client != null) {
      taskDestination = request2.client.globalObject;
      crossOriginIsolatedCapability = request2.client.crossOriginIsolatedCapability;
    }
    const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
    const timingInfo = createOpaqueTimingInfo({
      startTime: currentTime
    });
    const fetchParams = {
      controller: new Fetch(dispatcher2),
      request: request2,
      timingInfo,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseConsumeBody,
      processResponseEndOfBody,
      taskDestination,
      crossOriginIsolatedCapability
    };
    assert(!request2.body || request2.body.stream);
    if (request2.window === "client") {
      request2.window = request2.client?.globalObject?.constructor?.name === "Window" ? request2.client : "no-window";
    }
    if (request2.origin === "client") {
      request2.origin = request2.client.origin;
    }
    if (request2.policyContainer === "client") {
      if (request2.client != null) {
        request2.policyContainer = clonePolicyContainer(
          request2.client.policyContainer
        );
      } else {
        request2.policyContainer = makePolicyContainer();
      }
    }
    if (!request2.headersList.contains("accept", true)) {
      const value = "*/*";
      request2.headersList.append("accept", value, true);
    }
    if (!request2.headersList.contains("accept-language", true)) {
      request2.headersList.append("accept-language", "*", true);
    }
    if (request2.priority === null) ;
    if (subresourceSet.has(request2.destination)) ;
    mainFetch(fetchParams).catch((err) => {
      fetchParams.controller.terminate(err);
    });
    return fetchParams.controller;
  }
  async function mainFetch(fetchParams, recursive = false) {
    const request2 = fetchParams.request;
    let response2 = null;
    if (request2.localURLsOnly && !urlIsLocal(requestCurrentURL(request2))) {
      response2 = makeNetworkError("local URLs only");
    }
    tryUpgradeRequestToAPotentiallyTrustworthyURL(request2);
    if (requestBadPort(request2) === "blocked") {
      response2 = makeNetworkError("bad port");
    }
    if (request2.referrerPolicy === "") {
      request2.referrerPolicy = request2.policyContainer.referrerPolicy;
    }
    if (request2.referrer !== "no-referrer") {
      request2.referrer = determineRequestsReferrer(request2);
    }
    if (response2 === null) {
      response2 = await (async () => {
        const currentURL = requestCurrentURL(request2);
        if (
          // - requestâs current URLâs origin is same origin with requestâs origin,
          //   and requestâs response tainting is "basic"
          sameOrigin(currentURL, request2.url) && request2.responseTainting === "basic" || // requestâs current URLâs scheme is "data"
          currentURL.protocol === "data:" || // - requestâs mode is "navigate" or "websocket"
          (request2.mode === "navigate" || request2.mode === "websocket")
        ) {
          request2.responseTainting = "basic";
          return await schemeFetch(fetchParams);
        }
        if (request2.mode === "same-origin") {
          return makeNetworkError('request mode cannot be "same-origin"');
        }
        if (request2.mode === "no-cors") {
          if (request2.redirect !== "follow") {
            return makeNetworkError(
              'redirect mode cannot be "follow" for "no-cors" request'
            );
          }
          request2.responseTainting = "opaque";
          return await schemeFetch(fetchParams);
        }
        if (!urlIsHttpHttpsScheme(requestCurrentURL(request2))) {
          return makeNetworkError("URL scheme must be a HTTP(S) scheme");
        }
        request2.responseTainting = "cors";
        return await httpFetch(fetchParams);
      })();
    }
    if (recursive) {
      return response2;
    }
    if (response2.status !== 0 && !response2.internalResponse) {
      if (request2.responseTainting === "cors") ;
      if (request2.responseTainting === "basic") {
        response2 = filterResponse(response2, "basic");
      } else if (request2.responseTainting === "cors") {
        response2 = filterResponse(response2, "cors");
      } else if (request2.responseTainting === "opaque") {
        response2 = filterResponse(response2, "opaque");
      } else {
        assert(false);
      }
    }
    let internalResponse = response2.status === 0 ? response2 : response2.internalResponse;
    if (internalResponse.urlList.length === 0) {
      internalResponse.urlList.push(...request2.urlList);
    }
    if (!request2.timingAllowFailed) {
      response2.timingAllowPassed = true;
    }
    if (response2.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request2.headers.contains("range", true)) {
      response2 = internalResponse = makeNetworkError();
    }
    if (response2.status !== 0 && (request2.method === "HEAD" || request2.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
      internalResponse.body = null;
      fetchParams.controller.dump = true;
    }
    if (request2.integrity) {
      const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
      if (request2.responseTainting === "opaque" || response2.body == null) {
        processBodyError(response2.error);
        return;
      }
      const processBody = (bytes) => {
        if (!bytesMatch(bytes, request2.integrity)) {
          processBodyError("integrity mismatch");
          return;
        }
        response2.body = safelyExtractBody(bytes)[0];
        fetchFinale(fetchParams, response2);
      };
      await fullyReadBody(response2.body, processBody, processBodyError);
    } else {
      fetchFinale(fetchParams, response2);
    }
  }
  function schemeFetch(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
      return Promise.resolve(makeAppropriateNetworkError(fetchParams));
    }
    const { request: request2 } = fetchParams;
    const { protocol: scheme } = requestCurrentURL(request2);
    switch (scheme) {
      case "about:": {
        return Promise.resolve(makeNetworkError("about scheme is not supported"));
      }
      case "blob:": {
        if (!resolveObjectURL) {
          resolveObjectURL = require$$0$2.resolveObjectURL;
        }
        const blobURLEntry = requestCurrentURL(request2);
        if (blobURLEntry.search.length !== 0) {
          return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
        }
        const blob = resolveObjectURL(blobURLEntry.toString());
        if (request2.method !== "GET" || !isBlobLike(blob)) {
          return Promise.resolve(makeNetworkError("invalid method"));
        }
        const response2 = makeResponse();
        const fullLength = blob.size;
        const serializedFullLength = isomorphicEncode(`${fullLength}`);
        const type = blob.type;
        if (!request2.headersList.contains("range", true)) {
          const bodyWithType = extractBody(blob);
          response2.statusText = "OK";
          response2.body = bodyWithType[0];
          response2.headersList.set("content-length", serializedFullLength, true);
          response2.headersList.set("content-type", type, true);
        } else {
          response2.rangeRequested = true;
          const rangeHeader = request2.headersList.get("range", true);
          const rangeValue = simpleRangeHeaderValue(rangeHeader, true);
          if (rangeValue === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;
          if (rangeStart === null) {
            rangeStart = fullLength - rangeEnd;
            rangeEnd = rangeStart + rangeEnd - 1;
          } else {
            if (rangeStart >= fullLength) {
              return Promise.resolve(makeNetworkError("Range start is greater than the blob's size."));
            }
            if (rangeEnd === null || rangeEnd >= fullLength) {
              rangeEnd = fullLength - 1;
            }
          }
          const slicedBlob = blob.slice(rangeStart, rangeEnd, type);
          const slicedBodyWithType = extractBody(slicedBlob);
          response2.body = slicedBodyWithType[0];
          const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);
          const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);
          response2.status = 206;
          response2.statusText = "Partial Content";
          response2.headersList.set("content-length", serializedSlicedLength, true);
          response2.headersList.set("content-type", type, true);
          response2.headersList.set("content-range", contentRange, true);
        }
        return Promise.resolve(response2);
      }
      case "data:": {
        const currentURL = requestCurrentURL(request2);
        const dataURLStruct = dataURLProcessor(currentURL);
        if (dataURLStruct === "failure") {
          return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
        }
        const mimeType = serializeAMimeType(dataURLStruct.mimeType);
        return Promise.resolve(makeResponse({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: mimeType }]
          ],
          body: safelyExtractBody(dataURLStruct.body)[0]
        }));
      }
      case "file:": {
        return Promise.resolve(makeNetworkError("not implemented... yet..."));
      }
      case "http:":
      case "https:": {
        return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
      }
      default: {
        return Promise.resolve(makeNetworkError("unknown scheme"));
      }
    }
  }
  function finalizeResponse(fetchParams, response2) {
    fetchParams.request.done = true;
    if (fetchParams.processResponseDone != null) {
      queueMicrotask(() => fetchParams.processResponseDone(response2));
    }
  }
  function fetchFinale(fetchParams, response2) {
    let timingInfo = fetchParams.timingInfo;
    const processResponseEndOfBody = () => {
      const unsafeEndTime = Date.now();
      if (fetchParams.request.destination === "document") {
        fetchParams.controller.fullTimingInfo = timingInfo;
      }
      fetchParams.controller.reportTimingSteps = () => {
        if (fetchParams.request.url.protocol !== "https:") {
          return;
        }
        timingInfo.endTime = unsafeEndTime;
        let cacheState = response2.cacheState;
        const bodyInfo = response2.bodyInfo;
        if (!response2.timingAllowPassed) {
          timingInfo = createOpaqueTimingInfo(timingInfo);
          cacheState = "";
        }
        let responseStatus = 0;
        if (fetchParams.request.mode !== "navigator" || !response2.hasCrossOriginRedirects) {
          responseStatus = response2.status;
          const mimeType = extractMimeType(response2.headersList);
          if (mimeType !== "failure") {
            bodyInfo.contentType = minimizeSupportedMimeType(mimeType);
          }
        }
        if (fetchParams.request.initiatorType != null) {
          markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);
        }
      };
      const processResponseEndOfBodyTask = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response2));
        }
        if (fetchParams.request.initiatorType != null) {
          fetchParams.controller.reportTimingSteps();
        }
      };
      queueMicrotask(() => processResponseEndOfBodyTask());
    };
    if (fetchParams.processResponse != null) {
      queueMicrotask(() => {
        fetchParams.processResponse(response2);
        fetchParams.processResponse = null;
      });
    }
    const internalResponse = response2.type === "error" ? response2 : response2.internalResponse ?? response2;
    if (internalResponse.body == null) {
      processResponseEndOfBody();
    } else {
      finished(internalResponse.body.stream, () => {
        processResponseEndOfBody();
      });
    }
  }
  async function httpFetch(fetchParams) {
    const request2 = fetchParams.request;
    let response2 = null;
    let actualResponse = null;
    const timingInfo = fetchParams.timingInfo;
    if (request2.serviceWorkers === "all") ;
    if (response2 === null) {
      if (request2.redirect === "follow") {
        request2.serviceWorkers = "none";
      }
      actualResponse = response2 = await httpNetworkOrCacheFetch(fetchParams);
      if (request2.responseTainting === "cors" && corsCheck(request2, response2) === "failure") {
        return makeNetworkError("cors failure");
      }
      if (TAOCheck(request2, response2) === "failure") {
        request2.timingAllowFailed = true;
      }
    }
    if ((request2.responseTainting === "opaque" || response2.type === "opaque") && crossOriginResourcePolicyCheck(
      request2.origin,
      request2.client,
      request2.destination,
      actualResponse
    ) === "blocked") {
      return makeNetworkError("blocked");
    }
    if (redirectStatusSet.has(actualResponse.status)) {
      if (request2.redirect !== "manual") {
        fetchParams.controller.connection.destroy(void 0, false);
      }
      if (request2.redirect === "error") {
        response2 = makeNetworkError("unexpected redirect");
      } else if (request2.redirect === "manual") {
        response2 = actualResponse;
      } else if (request2.redirect === "follow") {
        response2 = await httpRedirectFetch(fetchParams, response2);
      } else {
        assert(false);
      }
    }
    response2.timingInfo = timingInfo;
    return response2;
  }
  function httpRedirectFetch(fetchParams, response2) {
    const request2 = fetchParams.request;
    const actualResponse = response2.internalResponse ? response2.internalResponse : response2;
    let locationURL;
    try {
      locationURL = responseLocationURL(
        actualResponse,
        requestCurrentURL(request2).hash
      );
      if (locationURL == null) {
        return response2;
      }
    } catch (err) {
      return Promise.resolve(makeNetworkError(err));
    }
    if (!urlIsHttpHttpsScheme(locationURL)) {
      return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
    }
    if (request2.redirectCount === 20) {
      return Promise.resolve(makeNetworkError("redirect count exceeded"));
    }
    request2.redirectCount += 1;
    if (request2.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request2, locationURL)) {
      return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
    }
    if (request2.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
      return Promise.resolve(makeNetworkError(
        'URL cannot contain credentials for request mode "cors"'
      ));
    }
    if (actualResponse.status !== 303 && request2.body != null && request2.body.source == null) {
      return Promise.resolve(makeNetworkError());
    }
    if ([301, 302].includes(actualResponse.status) && request2.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request2.method)) {
      request2.method = "GET";
      request2.body = null;
      for (const headerName of requestBodyHeader) {
        request2.headersList.delete(headerName);
      }
    }
    if (!sameOrigin(requestCurrentURL(request2), locationURL)) {
      request2.headersList.delete("authorization", true);
      request2.headersList.delete("proxy-authorization", true);
      request2.headersList.delete("cookie", true);
      request2.headersList.delete("host", true);
    }
    if (request2.body != null) {
      assert(request2.body.source != null);
      request2.body = safelyExtractBody(request2.body.source)[0];
    }
    const timingInfo = fetchParams.timingInfo;
    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
    if (timingInfo.redirectStartTime === 0) {
      timingInfo.redirectStartTime = timingInfo.startTime;
    }
    request2.urlList.push(locationURL);
    setRequestReferrerPolicyOnRedirect(request2, actualResponse);
    return mainFetch(fetchParams, true);
  }
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
    const request2 = fetchParams.request;
    let httpFetchParams = null;
    let httpRequest = null;
    let response2 = null;
    if (request2.window === "no-window" && request2.redirect === "error") {
      httpFetchParams = fetchParams;
      httpRequest = request2;
    } else {
      httpRequest = cloneRequest(request2);
      httpFetchParams = { ...fetchParams };
      httpFetchParams.request = httpRequest;
    }
    const includeCredentials = request2.credentials === "include" || request2.credentials === "same-origin" && request2.responseTainting === "basic";
    const contentLength = httpRequest.body ? httpRequest.body.length : null;
    let contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
      contentLengthHeaderValue = "0";
    }
    if (contentLength != null) {
      contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
    }
    if (contentLengthHeaderValue != null) {
      httpRequest.headersList.append("content-length", contentLengthHeaderValue, true);
    }
    if (contentLength != null && httpRequest.keepalive) ;
    if (httpRequest.referrer instanceof URL) {
      httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href), true);
    }
    appendRequestOriginHeader(httpRequest);
    appendFetchMetadata(httpRequest);
    if (!httpRequest.headersList.contains("user-agent", true)) {
      httpRequest.headersList.append("user-agent", defaultUserAgent);
    }
    if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since", true) || httpRequest.headersList.contains("if-none-match", true) || httpRequest.headersList.contains("if-unmodified-since", true) || httpRequest.headersList.contains("if-match", true) || httpRequest.headersList.contains("if-range", true))) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control", true)) {
      httpRequest.headersList.append("cache-control", "max-age=0", true);
    }
    if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
      if (!httpRequest.headersList.contains("pragma", true)) {
        httpRequest.headersList.append("pragma", "no-cache", true);
      }
      if (!httpRequest.headersList.contains("cache-control", true)) {
        httpRequest.headersList.append("cache-control", "no-cache", true);
      }
    }
    if (httpRequest.headersList.contains("range", true)) {
      httpRequest.headersList.append("accept-encoding", "identity", true);
    }
    if (!httpRequest.headersList.contains("accept-encoding", true)) {
      if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
        httpRequest.headersList.append("accept-encoding", "br, gzip, deflate", true);
      } else {
        httpRequest.headersList.append("accept-encoding", "gzip, deflate", true);
      }
    }
    httpRequest.headersList.delete("host", true);
    {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache !== "no-store" && httpRequest.cache !== "reload") ;
    if (response2 == null) {
      if (httpRequest.cache === "only-if-cached") {
        return makeNetworkError("only if cached");
      }
      const forwardResponse = await httpNetworkFetch(
        httpFetchParams,
        includeCredentials,
        isNewConnectionFetch
      );
      if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) ;
      if (response2 == null) {
        response2 = forwardResponse;
      }
    }
    response2.urlList = [...httpRequest.urlList];
    if (httpRequest.headersList.contains("range", true)) {
      response2.rangeRequested = true;
    }
    response2.requestIncludesCredentials = includeCredentials;
    if (response2.status === 407) {
      if (request2.window === "no-window") {
        return makeNetworkError();
      }
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      return makeNetworkError("proxy authentication required");
    }
    if (
      // responseâs status is 421
      response2.status === 421 && // isNewConnectionFetch is false
      !isNewConnectionFetch && // requestâs body is null, or requestâs body is non-null and requestâs bodyâs source is non-null
      (request2.body == null || request2.body.source != null)
    ) {
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      fetchParams.controller.connection.destroy();
      response2 = await httpNetworkOrCacheFetch(
        fetchParams,
        isAuthenticationFetch,
        true
      );
    }
    return response2;
  }
  async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
    fetchParams.controller.connection = {
      abort: null,
      destroyed: false,
      destroy(err, abort = true) {
        if (!this.destroyed) {
          this.destroyed = true;
          if (abort) {
            this.abort?.(err ?? new DOMException("The operation was aborted.", "AbortError"));
          }
        }
      }
    };
    const request2 = fetchParams.request;
    let response2 = null;
    const timingInfo = fetchParams.timingInfo;
    {
      request2.cache = "no-store";
    }
    if (request2.mode === "websocket") ;
    let requestBody = null;
    if (request2.body == null && fetchParams.processRequestEndOfBody) {
      queueMicrotask(() => fetchParams.processRequestEndOfBody());
    } else if (request2.body != null) {
      const processBodyChunk = async function* (bytes) {
        if (isCancelled(fetchParams)) {
          return;
        }
        yield bytes;
        fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
      };
      const processEndOfBody = () => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (fetchParams.processRequestEndOfBody) {
          fetchParams.processRequestEndOfBody();
        }
      };
      const processBodyError = (e) => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (e.name === "AbortError") {
          fetchParams.controller.abort();
        } else {
          fetchParams.controller.terminate(e);
        }
      };
      requestBody = (async function* () {
        try {
          for await (const bytes of request2.body.stream) {
            yield* processBodyChunk(bytes);
          }
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      })();
    }
    try {
      const { body: body2, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
      if (socket) {
        response2 = makeResponse({ status, statusText, headersList, socket });
      } else {
        const iterator = body2[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next();
        response2 = makeResponse({ status, statusText, headersList });
      }
    } catch (err) {
      if (err.name === "AbortError") {
        fetchParams.controller.connection.destroy();
        return makeAppropriateNetworkError(fetchParams, err);
      }
      return makeNetworkError(err);
    }
    const pullAlgorithm = async () => {
      await fetchParams.controller.resume();
    };
    const cancelAlgorithm = (reason) => {
      if (!isCancelled(fetchParams)) {
        fetchParams.controller.abort(reason);
      }
    };
    const stream = new ReadableStream(
      {
        async start(controller) {
          fetchParams.controller.controller = controller;
        },
        async pull(controller) {
          await pullAlgorithm();
        },
        async cancel(reason) {
          await cancelAlgorithm(reason);
        },
        type: "bytes"
      }
    );
    response2.body = { stream, source: null, length: null };
    fetchParams.controller.onAborted = onAborted;
    fetchParams.controller.on("terminated", onAborted);
    fetchParams.controller.resume = async () => {
      while (true) {
        let bytes;
        let isFailure;
        try {
          const { done, value } = await fetchParams.controller.next();
          if (isAborted(fetchParams)) {
            break;
          }
          bytes = done ? void 0 : value;
        } catch (err) {
          if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
            bytes = void 0;
          } else {
            bytes = err;
            isFailure = true;
          }
        }
        if (bytes === void 0) {
          readableStreamClose(fetchParams.controller.controller);
          finalizeResponse(fetchParams, response2);
          return;
        }
        timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
        if (isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        const buffer = new Uint8Array(bytes);
        if (buffer.byteLength) {
          fetchParams.controller.controller.enqueue(buffer);
        }
        if (isErrored(stream)) {
          fetchParams.controller.terminate();
          return;
        }
        if (fetchParams.controller.controller.desiredSize <= 0) {
          return;
        }
      }
    };
    function onAborted(reason) {
      if (isAborted(fetchParams)) {
        response2.aborted = true;
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(
            fetchParams.controller.serializedAbortReason
          );
        }
      } else {
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(new TypeError("terminated", {
            cause: isErrorLike(reason) ? reason : void 0
          }));
        }
      }
      fetchParams.controller.connection.destroy();
    }
    return response2;
    function dispatch({ body: body2 }) {
      const url = requestCurrentURL(request2);
      const agent2 = fetchParams.controller.dispatcher;
      return new Promise((resolve2, reject) => agent2.dispatch(
        {
          path: url.pathname + url.search,
          origin: url.origin,
          method: request2.method,
          body: agent2.isMockActive ? request2.body && (request2.body.source || request2.body.stream) : body2,
          headers: request2.headersList.entries,
          maxRedirections: 0,
          upgrade: request2.mode === "websocket" ? "websocket" : void 0
        },
        {
          body: null,
          abort: null,
          onConnect(abort) {
            const { connection: connection2 } = fetchParams.controller;
            timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(void 0, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);
            if (connection2.destroyed) {
              abort(new DOMException("The operation was aborted.", "AbortError"));
            } else {
              fetchParams.controller.on("terminated", abort);
              this.abort = connection2.abort = abort;
            }
            timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
          },
          onResponseStarted() {
            timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
          },
          onHeaders(status, rawHeaders, resume, statusText) {
            if (status < 200) {
              return;
            }
            let codings = [];
            let location = "";
            const headersList = new HeadersList();
            for (let i = 0; i < rawHeaders.length; i += 2) {
              headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
            }
            const contentEncoding = headersList.get("content-encoding", true);
            if (contentEncoding) {
              codings = contentEncoding.toLowerCase().split(",").map((x) => x.trim());
            }
            location = headersList.get("location", true);
            this.body = new Readable({ read: resume });
            const decoders = [];
            const willFollow = location && request2.redirect === "follow" && redirectStatusSet.has(status);
            if (codings.length !== 0 && request2.method !== "HEAD" && request2.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
              for (let i = 0; i < codings.length; ++i) {
                const coding = codings[i];
                if (coding === "x-gzip" || coding === "gzip") {
                  decoders.push(zlib.createGunzip({
                    // Be less strict when decoding compressed responses, since sometimes
                    // servers send slightly invalid responses that are still accepted
                    // by common browsers.
                    // Always using Z_SYNC_FLUSH is what cURL does.
                    flush: zlib.constants.Z_SYNC_FLUSH,
                    finishFlush: zlib.constants.Z_SYNC_FLUSH
                  }));
                } else if (coding === "deflate") {
                  decoders.push(createInflate());
                } else if (coding === "br") {
                  decoders.push(zlib.createBrotliDecompress());
                } else {
                  decoders.length = 0;
                  break;
                }
              }
            }
            resolve2({
              status,
              statusText,
              headersList,
              body: decoders.length ? pipeline(this.body, ...decoders, () => {
              }) : this.body.on("error", () => {
              })
            });
            return true;
          },
          onData(chunk) {
            if (fetchParams.controller.dump) {
              return;
            }
            const bytes = chunk;
            timingInfo.encodedBodySize += bytes.byteLength;
            return this.body.push(bytes);
          },
          onComplete() {
            if (this.abort) {
              fetchParams.controller.off("terminated", this.abort);
            }
            if (fetchParams.controller.onAborted) {
              fetchParams.controller.off("terminated", fetchParams.controller.onAborted);
            }
            fetchParams.controller.ended = true;
            this.body.push(null);
          },
          onError(error) {
            if (this.abort) {
              fetchParams.controller.off("terminated", this.abort);
            }
            this.body?.destroy(error);
            fetchParams.controller.terminate(error);
            reject(error);
          },
          onUpgrade(status, rawHeaders, socket) {
            if (status !== 101) {
              return;
            }
            const headersList = new HeadersList();
            for (let i = 0; i < rawHeaders.length; i += 2) {
              headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
            }
            resolve2({
              status,
              statusText: STATUS_CODES[status],
              headersList,
              socket
            });
            return true;
          }
        }
      ));
    }
  }
  fetch_1 = {
    fetch: fetch2,
    Fetch,
    fetching,
    finalizeAndReportTiming
  };
  return fetch_1;
}
var symbols$2;
var hasRequiredSymbols$2;
function requireSymbols$2() {
  if (hasRequiredSymbols$2) return symbols$2;
  hasRequiredSymbols$2 = 1;
  symbols$2 = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted")
  };
  return symbols$2;
}
var progressevent;
var hasRequiredProgressevent;
function requireProgressevent() {
  if (hasRequiredProgressevent) return progressevent;
  hasRequiredProgressevent = 1;
  const { webidl } = requireWebidl();
  const kState = Symbol("ProgressEvent state");
  class ProgressEvent extends Event {
    constructor(type, eventInitDict = {}) {
      type = webidl.converters.DOMString(type, "ProgressEvent constructor", "type");
      eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
      super(type, eventInitDict);
      this[kState] = {
        lengthComputable: eventInitDict.lengthComputable,
        loaded: eventInitDict.loaded,
        total: eventInitDict.total
      };
    }
    get lengthComputable() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].lengthComputable;
    }
    get loaded() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].loaded;
    }
    get total() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].total;
    }
  }
  webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "loaded",
      converter: webidl.converters["unsigned long long"],
      defaultValue: () => 0
    },
    {
      key: "total",
      converter: webidl.converters["unsigned long long"],
      defaultValue: () => 0
    },
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ]);
  progressevent = {
    ProgressEvent
  };
  return progressevent;
}
var encoding;
var hasRequiredEncoding;
function requireEncoding() {
  if (hasRequiredEncoding) return encoding;
  hasRequiredEncoding = 1;
  function getEncoding(label) {
    if (!label) {
      return "failure";
    }
    switch (label.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  }
  encoding = {
    getEncoding
  };
  return encoding;
}
var util$4;
var hasRequiredUtil$4;
function requireUtil$4() {
  if (hasRequiredUtil$4) return util$4;
  hasRequiredUtil$4 = 1;
  const {
    kState,
    kError,
    kResult,
    kAborted,
    kLastProgressEventFired
  } = requireSymbols$2();
  const { ProgressEvent } = requireProgressevent();
  const { getEncoding } = requireEncoding();
  const { serializeAMimeType, parseMIMEType } = requireDataUrl();
  const { types: types2 } = require$$0$5;
  const { StringDecoder } = require$$5$2;
  const { btoa } = require$$0$2;
  const staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  function readOperation(fr, blob, type, encodingName) {
    if (fr[kState] === "loading") {
      throw new DOMException("Invalid state", "InvalidStateError");
    }
    fr[kState] = "loading";
    fr[kResult] = null;
    fr[kError] = null;
    const stream = blob.stream();
    const reader = stream.getReader();
    const bytes = [];
    let chunkPromise = reader.read();
    let isFirstChunk = true;
    (async () => {
      while (!fr[kAborted]) {
        try {
          const { done, value } = await chunkPromise;
          if (isFirstChunk && !fr[kAborted]) {
            queueMicrotask(() => {
              fireAProgressEvent("loadstart", fr);
            });
          }
          isFirstChunk = false;
          if (!done && types2.isUint8Array(value)) {
            bytes.push(value);
            if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
              fr[kLastProgressEventFired] = Date.now();
              queueMicrotask(() => {
                fireAProgressEvent("progress", fr);
              });
            }
            chunkPromise = reader.read();
          } else if (done) {
            queueMicrotask(() => {
              fr[kState] = "done";
              try {
                const result = packageData(bytes, type, blob.type, encodingName);
                if (fr[kAborted]) {
                  return;
                }
                fr[kResult] = result;
                fireAProgressEvent("load", fr);
              } catch (error) {
                fr[kError] = error;
                fireAProgressEvent("error", fr);
              }
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        } catch (error) {
          if (fr[kAborted]) {
            return;
          }
          queueMicrotask(() => {
            fr[kState] = "done";
            fr[kError] = error;
            fireAProgressEvent("error", fr);
            if (fr[kState] !== "loading") {
              fireAProgressEvent("loadend", fr);
            }
          });
          break;
        }
      }
    })();
  }
  function fireAProgressEvent(e, reader) {
    const event = new ProgressEvent(e, {
      bubbles: false,
      cancelable: false
    });
    reader.dispatchEvent(event);
  }
  function packageData(bytes, type, mimeType, encodingName) {
    switch (type) {
      case "DataURL": {
        let dataURL = "data:";
        const parsed = parseMIMEType(mimeType || "application/octet-stream");
        if (parsed !== "failure") {
          dataURL += serializeAMimeType(parsed);
        }
        dataURL += ";base64,";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          dataURL += btoa(decoder.write(chunk));
        }
        dataURL += btoa(decoder.end());
        return dataURL;
      }
      case "Text": {
        let encoding2 = "failure";
        if (encodingName) {
          encoding2 = getEncoding(encodingName);
        }
        if (encoding2 === "failure" && mimeType) {
          const type2 = parseMIMEType(mimeType);
          if (type2 !== "failure") {
            encoding2 = getEncoding(type2.parameters.get("charset"));
          }
        }
        if (encoding2 === "failure") {
          encoding2 = "UTF-8";
        }
        return decode2(bytes, encoding2);
      }
      case "ArrayBuffer": {
        const sequence = combineByteSequences(bytes);
        return sequence.buffer;
      }
      case "BinaryString": {
        let binaryString = "";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          binaryString += decoder.write(chunk);
        }
        binaryString += decoder.end();
        return binaryString;
      }
    }
  }
  function decode2(ioQueue, encoding2) {
    const bytes = combineByteSequences(ioQueue);
    const BOMEncoding = BOMSniffing(bytes);
    let slice = 0;
    if (BOMEncoding !== null) {
      encoding2 = BOMEncoding;
      slice = BOMEncoding === "UTF-8" ? 3 : 2;
    }
    const sliced = bytes.slice(slice);
    return new TextDecoder(encoding2).decode(sliced);
  }
  function BOMSniffing(ioQueue) {
    const [a, b, c] = ioQueue;
    if (a === 239 && b === 187 && c === 191) {
      return "UTF-8";
    } else if (a === 254 && b === 255) {
      return "UTF-16BE";
    } else if (a === 255 && b === 254) {
      return "UTF-16LE";
    }
    return null;
  }
  function combineByteSequences(sequences) {
    const size = sequences.reduce((a, b) => {
      return a + b.byteLength;
    }, 0);
    let offset = 0;
    return sequences.reduce((a, b) => {
      a.set(b, offset);
      offset += b.byteLength;
      return a;
    }, new Uint8Array(size));
  }
  util$4 = {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  };
  return util$4;
}
var filereader;
var hasRequiredFilereader;
function requireFilereader() {
  if (hasRequiredFilereader) return filereader;
  hasRequiredFilereader = 1;
  const {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  } = requireUtil$4();
  const {
    kState,
    kError,
    kResult,
    kEvents,
    kAborted
  } = requireSymbols$2();
  const { webidl } = requireWebidl();
  const { kEnumerableProperty } = requireUtil$7();
  class FileReader extends EventTarget {
    constructor() {
      super();
      this[kState] = "empty";
      this[kResult] = null;
      this[kError] = null;
      this[kEvents] = {
        loadend: null,
        error: null,
        abort: null,
        load: null,
        progress: null,
        loadstart: null
      };
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
     * @param {import('buffer').Blob} blob
     */
    readAsArrayBuffer(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsArrayBuffer");
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "ArrayBuffer");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#readAsBinaryString
     * @param {import('buffer').Blob} blob
     */
    readAsBinaryString(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsBinaryString");
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "BinaryString");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#readAsDataText
     * @param {import('buffer').Blob} blob
     * @param {string?} encoding
     */
    readAsText(blob, encoding2 = void 0) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsText");
      blob = webidl.converters.Blob(blob, { strict: false });
      if (encoding2 !== void 0) {
        encoding2 = webidl.converters.DOMString(encoding2, "FileReader.readAsText", "encoding");
      }
      readOperation(this, blob, "Text", encoding2);
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
     * @param {import('buffer').Blob} blob
     */
    readAsDataURL(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsDataURL");
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "DataURL");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-abort
     */
    abort() {
      if (this[kState] === "empty" || this[kState] === "done") {
        this[kResult] = null;
        return;
      }
      if (this[kState] === "loading") {
        this[kState] = "done";
        this[kResult] = null;
      }
      this[kAborted] = true;
      fireAProgressEvent("abort", this);
      if (this[kState] !== "loading") {
        fireAProgressEvent("loadend", this);
      }
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
     */
    get readyState() {
      webidl.brandCheck(this, FileReader);
      switch (this[kState]) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-result
     */
    get result() {
      webidl.brandCheck(this, FileReader);
      return this[kResult];
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-error
     */
    get error() {
      webidl.brandCheck(this, FileReader);
      return this[kError];
    }
    get onloadend() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadend;
    }
    set onloadend(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadend) {
        this.removeEventListener("loadend", this[kEvents].loadend);
      }
      if (typeof fn === "function") {
        this[kEvents].loadend = fn;
        this.addEventListener("loadend", fn);
      } else {
        this[kEvents].loadend = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].error) {
        this.removeEventListener("error", this[kEvents].error);
      }
      if (typeof fn === "function") {
        this[kEvents].error = fn;
        this.addEventListener("error", fn);
      } else {
        this[kEvents].error = null;
      }
    }
    get onloadstart() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadstart;
    }
    set onloadstart(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadstart) {
        this.removeEventListener("loadstart", this[kEvents].loadstart);
      }
      if (typeof fn === "function") {
        this[kEvents].loadstart = fn;
        this.addEventListener("loadstart", fn);
      } else {
        this[kEvents].loadstart = null;
      }
    }
    get onprogress() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].progress;
    }
    set onprogress(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].progress) {
        this.removeEventListener("progress", this[kEvents].progress);
      }
      if (typeof fn === "function") {
        this[kEvents].progress = fn;
        this.addEventListener("progress", fn);
      } else {
        this[kEvents].progress = null;
      }
    }
    get onload() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].load;
    }
    set onload(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].load) {
        this.removeEventListener("load", this[kEvents].load);
      }
      if (typeof fn === "function") {
        this[kEvents].load = fn;
        this.addEventListener("load", fn);
      } else {
        this[kEvents].load = null;
      }
    }
    get onabort() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].abort;
    }
    set onabort(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].abort) {
        this.removeEventListener("abort", this[kEvents].abort);
      }
      if (typeof fn === "function") {
        this[kEvents].abort = fn;
        this.addEventListener("abort", fn);
      } else {
        this[kEvents].abort = null;
      }
    }
  }
  FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
  FileReader.LOADING = FileReader.prototype.LOADING = 1;
  FileReader.DONE = FileReader.prototype.DONE = 2;
  Object.defineProperties(FileReader.prototype, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors,
    readAsArrayBuffer: kEnumerableProperty,
    readAsBinaryString: kEnumerableProperty,
    readAsText: kEnumerableProperty,
    readAsDataURL: kEnumerableProperty,
    abort: kEnumerableProperty,
    readyState: kEnumerableProperty,
    result: kEnumerableProperty,
    error: kEnumerableProperty,
    onloadstart: kEnumerableProperty,
    onprogress: kEnumerableProperty,
    onload: kEnumerableProperty,
    onabort: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onloadend: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(FileReader, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors
  });
  filereader = {
    FileReader
  };
  return filereader;
}
var symbols$1;
var hasRequiredSymbols$1;
function requireSymbols$1() {
  if (hasRequiredSymbols$1) return symbols$1;
  hasRequiredSymbols$1 = 1;
  symbols$1 = {
    kConstruct: requireSymbols$4().kConstruct
  };
  return symbols$1;
}
var util$3;
var hasRequiredUtil$3;
function requireUtil$3() {
  if (hasRequiredUtil$3) return util$3;
  hasRequiredUtil$3 = 1;
  const assert = require$$0$3;
  const { URLSerializer } = requireDataUrl();
  const { isValidHeaderName } = requireUtil$6();
  function urlEquals(A, B, excludeFragment = false) {
    const serializedA = URLSerializer(A, excludeFragment);
    const serializedB = URLSerializer(B, excludeFragment);
    return serializedA === serializedB;
  }
  function getFieldValues(header) {
    assert(header !== null);
    const values = [];
    for (let value of header.split(",")) {
      value = value.trim();
      if (isValidHeaderName(value)) {
        values.push(value);
      }
    }
    return values;
  }
  util$3 = {
    urlEquals,
    getFieldValues
  };
  return util$3;
}
var cache;
var hasRequiredCache;
function requireCache() {
  if (hasRequiredCache) return cache;
  hasRequiredCache = 1;
  const { kConstruct } = requireSymbols$1();
  const { urlEquals, getFieldValues } = requireUtil$3();
  const { kEnumerableProperty, isDisturbed } = requireUtil$7();
  const { webidl } = requireWebidl();
  const { Response: Response2, cloneResponse, fromInnerResponse } = requireResponse();
  const { Request: Request2, fromInnerRequest } = requireRequest();
  const { kState } = requireSymbols$3();
  const { fetching } = requireFetch();
  const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = requireUtil$6();
  const assert = require$$0$3;
  class Cache {
    /**
     * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
     * @type {requestResponseList}
     */
    #relevantRequestResponseList;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
      this.#relevantRequestResponseList = arguments[1];
    }
    async match(request2, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.match";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      const p = this.#internalMatchAll(request2, options, 1);
      if (p.length === 0) {
        return;
      }
      return p[0];
    }
    async matchAll(request2 = void 0, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.matchAll";
      if (request2 !== void 0) request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      return this.#internalMatchAll(request2, options);
    }
    async add(request2) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.add";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      const requests = [request2];
      const responseArrayPromise = this.addAll(requests);
      return await responseArrayPromise;
    }
    async addAll(requests) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.addAll";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      const responsePromises = [];
      const requestList = [];
      for (let request2 of requests) {
        if (request2 === void 0) {
          throw webidl.errors.conversionFailed({
            prefix,
            argument: "Argument 1",
            types: ["undefined is not allowed"]
          });
        }
        request2 = webidl.converters.RequestInfo(request2);
        if (typeof request2 === "string") {
          continue;
        }
        const r = request2[kState];
        if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme when method is not GET."
          });
        }
      }
      const fetchControllers = [];
      for (const request2 of requests) {
        const r = new Request2(request2)[kState];
        if (!urlIsHttpHttpsScheme(r.url)) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme."
          });
        }
        r.initiator = "fetch";
        r.destination = "subresource";
        requestList.push(r);
        const responsePromise = createDeferredPromise();
        fetchControllers.push(fetching({
          request: r,
          processResponse(response2) {
            if (response2.type === "error" || response2.status === 206 || response2.status < 200 || response2.status > 299) {
              responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            } else if (response2.headersList.contains("vary")) {
              const fieldValues = getFieldValues(response2.headersList.get("vary"));
              for (const fieldValue of fieldValues) {
                if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const controller of fetchControllers) {
                    controller.abort();
                  }
                  return;
                }
              }
            }
          },
          processResponseEndOfBody(response2) {
            if (response2.aborted) {
              responsePromise.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            responsePromise.resolve(response2);
          }
        }));
        responsePromises.push(responsePromise.promise);
      }
      const p = Promise.all(responsePromises);
      const responses = await p;
      const operations = [];
      let index = 0;
      for (const response2 of responses) {
        const operation = {
          type: "put",
          // 7.3.2
          request: requestList[index],
          // 7.3.3
          response: response2
          // 7.3.4
        };
        operations.push(operation);
        index++;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(void 0);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async put(request2, response2) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.put";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      response2 = webidl.converters.Response(response2, prefix, "response");
      let innerRequest = null;
      if (request2 instanceof Request2) {
        innerRequest = request2[kState];
      } else {
        innerRequest = new Request2(request2)[kState];
      }
      if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
        throw webidl.errors.exception({
          header: prefix,
          message: "Expected an http/s scheme when method is not GET"
        });
      }
      const innerResponse = response2[kState];
      if (innerResponse.status === 206) {
        throw webidl.errors.exception({
          header: prefix,
          message: "Got 206 status"
        });
      }
      if (innerResponse.headersList.contains("vary")) {
        const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            throw webidl.errors.exception({
              header: prefix,
              message: "Got * vary field value"
            });
          }
        }
      }
      if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
        throw webidl.errors.exception({
          header: prefix,
          message: "Response body is locked or disturbed"
        });
      }
      const clonedResponse = cloneResponse(innerResponse);
      const bodyReadPromise = createDeferredPromise();
      if (innerResponse.body != null) {
        const stream = innerResponse.body.stream;
        const reader = stream.getReader();
        readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
      } else {
        bodyReadPromise.resolve(void 0);
      }
      const operations = [];
      const operation = {
        type: "put",
        // 14.
        request: innerRequest,
        // 15.
        response: clonedResponse
        // 16.
      };
      operations.push(operation);
      const bytes = await bodyReadPromise.promise;
      if (clonedResponse.body != null) {
        clonedResponse.body.source = bytes;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve();
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async delete(request2, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      let r = null;
      if (request2 instanceof Request2) {
        r = request2[kState];
        if (r.method !== "GET" && !options.ignoreMethod) {
          return false;
        }
      } else {
        assert(typeof request2 === "string");
        r = new Request2(request2)[kState];
      }
      const operations = [];
      const operation = {
        type: "delete",
        request: r,
        options
      };
      operations.push(operation);
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      let requestResponses;
      try {
        requestResponses = this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(!!requestResponses?.length);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
     * @param {any} request
     * @param {import('../../types/cache').CacheQueryOptions} options
     * @returns {Promise<readonly Request[]>}
     */
    async keys(request2 = void 0, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.keys";
      if (request2 !== void 0) request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      let r = null;
      if (request2 !== void 0) {
        if (request2 instanceof Request2) {
          r = request2[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request2 === "string") {
          r = new Request2(request2)[kState];
        }
      }
      const promise = createDeferredPromise();
      const requests = [];
      if (request2 === void 0) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          requests.push(requestResponse[0]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options);
        for (const requestResponse of requestResponses) {
          requests.push(requestResponse[0]);
        }
      }
      queueMicrotask(() => {
        const requestList = [];
        for (const request3 of requests) {
          const requestObject = fromInnerRequest(
            request3,
            new AbortController().signal,
            "immutable"
          );
          requestList.push(requestObject);
        }
        promise.resolve(Object.freeze(requestList));
      });
      return promise.promise;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
     * @param {CacheBatchOperation[]} operations
     * @returns {requestResponseList}
     */
    #batchCacheOperations(operations) {
      const cache2 = this.#relevantRequestResponseList;
      const backupCache = [...cache2];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation.type === "delete" && operation.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (this.#queryCache(operation.request, operation.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation.type === "delete") {
            requestResponses = this.#queryCache(operation.request, operation.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache2.indexOf(requestResponse);
              assert(idx !== -1);
              cache2.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = this.#queryCache(operation.request);
            for (const requestResponse of requestResponses) {
              const idx = cache2.indexOf(requestResponse);
              assert(idx !== -1);
              cache2.splice(idx, 1);
            }
            cache2.push([operation.request, operation.response]);
            addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        this.#relevantRequestResponseList.length = 0;
        this.#relevantRequestResponseList = backupCache;
        throw e;
      }
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#query-cache
     * @param {any} requestQuery
     * @param {import('../../types/cache').CacheQueryOptions} options
     * @param {requestResponseList} targetStorage
     * @returns {requestResponseList}
     */
    #queryCache(requestQuery, options, targetStorage) {
      const resultList = [];
      const storage = targetStorage ?? this.#relevantRequestResponseList;
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
     * @param {any} requestQuery
     * @param {any} request
     * @param {any | null} response
     * @param {import('../../types/cache').CacheQueryOptions | undefined} options
     * @returns {boolean}
     */
    #requestMatchesCachedItem(requestQuery, request2, response2 = null, options) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request2.url);
      if (options?.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response2 == null || options?.ignoreVary || !response2.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response2.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request2.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    }
    #internalMatchAll(request2, options, maxResponses = Infinity) {
      let r = null;
      if (request2 !== void 0) {
        if (request2 instanceof Request2) {
          r = request2[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request2 === "string") {
          r = new Request2(request2)[kState];
        }
      }
      const responses = [];
      if (request2 === void 0) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          responses.push(requestResponse[1]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options);
        for (const requestResponse of requestResponses) {
          responses.push(requestResponse[1]);
        }
      }
      const responseList = [];
      for (const response2 of responses) {
        const responseObject = fromInnerResponse(response2, "immutable");
        responseList.push(responseObject.clone());
        if (responseList.length >= maxResponses) {
          break;
        }
      }
      return Object.freeze(responseList);
    }
  }
  Object.defineProperties(Cache.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: true
    },
    match: kEnumerableProperty,
    matchAll: kEnumerableProperty,
    add: kEnumerableProperty,
    addAll: kEnumerableProperty,
    put: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  const cacheQueryOptionConverters = [
    {
      key: "ignoreSearch",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "ignoreMethod",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "ignoreVary",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
    ...cacheQueryOptionConverters,
    {
      key: "cacheName",
      converter: webidl.converters.DOMString
    }
  ]);
  webidl.converters.Response = webidl.interfaceConverter(Response2);
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
    webidl.converters.RequestInfo
  );
  cache = {
    Cache
  };
  return cache;
}
var cachestorage;
var hasRequiredCachestorage;
function requireCachestorage() {
  if (hasRequiredCachestorage) return cachestorage;
  hasRequiredCachestorage = 1;
  const { kConstruct } = requireSymbols$1();
  const { Cache } = requireCache();
  const { webidl } = requireWebidl();
  const { kEnumerableProperty } = requireUtil$7();
  class CacheStorage {
    /**
     * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
     * @type {Map<string, import('./cache').requestResponseList}
     */
    #caches = /* @__PURE__ */ new Map();
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
    }
    async match(request2, options = {}) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, "CacheStorage.match");
      request2 = webidl.converters.RequestInfo(request2);
      options = webidl.converters.MultiCacheQueryOptions(options);
      if (options.cacheName != null) {
        if (this.#caches.has(options.cacheName)) {
          const cacheList = this.#caches.get(options.cacheName);
          const cache2 = new Cache(kConstruct, cacheList);
          return await cache2.match(request2, options);
        }
      } else {
        for (const cacheList of this.#caches.values()) {
          const cache2 = new Cache(kConstruct, cacheList);
          const response2 = await cache2.match(request2, options);
          if (response2 !== void 0) {
            return response2;
          }
        }
      }
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async has(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.has";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      return this.#caches.has(cacheName);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
     * @param {string} cacheName
     * @returns {Promise<Cache>}
     */
    async open(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.open";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      if (this.#caches.has(cacheName)) {
        const cache3 = this.#caches.get(cacheName);
        return new Cache(kConstruct, cache3);
      }
      const cache2 = [];
      this.#caches.set(cacheName, cache2);
      return new Cache(kConstruct, cache2);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async delete(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      return this.#caches.delete(cacheName);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
     * @returns {Promise<string[]>}
     */
    async keys() {
      webidl.brandCheck(this, CacheStorage);
      const keys = this.#caches.keys();
      return [...keys];
    }
  }
  Object.defineProperties(CacheStorage.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: true
    },
    match: kEnumerableProperty,
    has: kEnumerableProperty,
    open: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  cachestorage = {
    CacheStorage
  };
  return cachestorage;
}
var constants$1;
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  const maxAttributeValueSize = 1024;
  const maxNameValuePairSize = 4096;
  constants$1 = {
    maxAttributeValueSize,
    maxNameValuePairSize
  };
  return constants$1;
}
var util$2;
var hasRequiredUtil$2;
function requireUtil$2() {
  if (hasRequiredUtil$2) return util$2;
  hasRequiredUtil$2 = 1;
  function isCTLExcludingHtab(value) {
    for (let i = 0; i < value.length; ++i) {
      const code = value.charCodeAt(i);
      if (code >= 0 && code <= 8 || code >= 10 && code <= 31 || code === 127) {
        return true;
      }
    }
    return false;
  }
  function validateCookieName(name) {
    for (let i = 0; i < name.length; ++i) {
      const code = name.charCodeAt(i);
      if (code < 33 || // exclude CTLs (0-31), SP and HT
      code > 126 || // exclude non-ascii and DEL
      code === 34 || // "
      code === 40 || // (
      code === 41 || // )
      code === 60 || // <
      code === 62 || // >
      code === 64 || // @
      code === 44 || // ,
      code === 59 || // ;
      code === 58 || // :
      code === 92 || // \
      code === 47 || // /
      code === 91 || // [
      code === 93 || // ]
      code === 63 || // ?
      code === 61 || // =
      code === 123 || // {
      code === 125) {
        throw new Error("Invalid cookie name");
      }
    }
  }
  function validateCookieValue(value) {
    let len = value.length;
    let i = 0;
    if (value[0] === '"') {
      if (len === 1 || value[len - 1] !== '"') {
        throw new Error("Invalid cookie value");
      }
      --len;
      ++i;
    }
    while (i < len) {
      const code = value.charCodeAt(i++);
      if (code < 33 || // exclude CTLs (0-31)
      code > 126 || // non-ascii and DEL (127)
      code === 34 || // "
      code === 44 || // ,
      code === 59 || // ;
      code === 92) {
        throw new Error("Invalid cookie value");
      }
    }
  }
  function validateCookiePath(path2) {
    for (let i = 0; i < path2.length; ++i) {
      const code = path2.charCodeAt(i);
      if (code < 32 || // exclude CTLs (0-31)
      code === 127 || // DEL
      code === 59) {
        throw new Error("Invalid cookie path");
      }
    }
  }
  function validateCookieDomain(domain) {
    if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
      throw new Error("Invalid cookie domain");
    }
  }
  const IMFDays = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ];
  const IMFMonths = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  const IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, "0"));
  function toIMFDate(date) {
    if (typeof date === "number") {
      date = new Date(date);
    }
    return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`;
  }
  function validateCookieMaxAge(maxAge) {
    if (maxAge < 0) {
      throw new Error("Invalid cookie max-age");
    }
  }
  function stringify2(cookie) {
    if (cookie.name.length === 0) {
      return null;
    }
    validateCookieName(cookie.name);
    validateCookieValue(cookie.value);
    const out = [`${cookie.name}=${cookie.value}`];
    if (cookie.name.startsWith("__Secure-")) {
      cookie.secure = true;
    }
    if (cookie.name.startsWith("__Host-")) {
      cookie.secure = true;
      cookie.domain = null;
      cookie.path = "/";
    }
    if (cookie.secure) {
      out.push("Secure");
    }
    if (cookie.httpOnly) {
      out.push("HttpOnly");
    }
    if (typeof cookie.maxAge === "number") {
      validateCookieMaxAge(cookie.maxAge);
      out.push(`Max-Age=${cookie.maxAge}`);
    }
    if (cookie.domain) {
      validateCookieDomain(cookie.domain);
      out.push(`Domain=${cookie.domain}`);
    }
    if (cookie.path) {
      validateCookiePath(cookie.path);
      out.push(`Path=${cookie.path}`);
    }
    if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
      out.push(`Expires=${toIMFDate(cookie.expires)}`);
    }
    if (cookie.sameSite) {
      out.push(`SameSite=${cookie.sameSite}`);
    }
    for (const part of cookie.unparsed) {
      if (!part.includes("=")) {
        throw new Error("Invalid unparsed");
      }
      const [key, ...value] = part.split("=");
      out.push(`${key.trim()}=${value.join("=")}`);
    }
    return out.join("; ");
  }
  util$2 = {
    isCTLExcludingHtab,
    validateCookieName,
    validateCookiePath,
    validateCookieValue,
    toIMFDate,
    stringify: stringify2
  };
  return util$2;
}
var parse$2;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse$2;
  hasRequiredParse = 1;
  const { maxNameValuePairSize, maxAttributeValueSize } = requireConstants$1();
  const { isCTLExcludingHtab } = requireUtil$2();
  const { collectASequenceOfCodePointsFast } = requireDataUrl();
  const assert = require$$0$3;
  function parseSetCookie(header) {
    if (isCTLExcludingHtab(header)) {
      return null;
    }
    let nameValuePair = "";
    let unparsedAttributes = "";
    let name = "";
    let value = "";
    if (header.includes(";")) {
      const position = { position: 0 };
      nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
      unparsedAttributes = header.slice(position.position);
    } else {
      nameValuePair = header;
    }
    if (!nameValuePair.includes("=")) {
      value = nameValuePair;
    } else {
      const position = { position: 0 };
      name = collectASequenceOfCodePointsFast(
        "=",
        nameValuePair,
        position
      );
      value = nameValuePair.slice(position.position + 1);
    }
    name = name.trim();
    value = value.trim();
    if (name.length + value.length > maxNameValuePairSize) {
      return null;
    }
    return {
      name,
      value,
      ...parseUnparsedAttributes(unparsedAttributes)
    };
  }
  function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
    if (unparsedAttributes.length === 0) {
      return cookieAttributeList;
    }
    assert(unparsedAttributes[0] === ";");
    unparsedAttributes = unparsedAttributes.slice(1);
    let cookieAv = "";
    if (unparsedAttributes.includes(";")) {
      cookieAv = collectASequenceOfCodePointsFast(
        ";",
        unparsedAttributes,
        { position: 0 }
      );
      unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
    } else {
      cookieAv = unparsedAttributes;
      unparsedAttributes = "";
    }
    let attributeName = "";
    let attributeValue = "";
    if (cookieAv.includes("=")) {
      const position = { position: 0 };
      attributeName = collectASequenceOfCodePointsFast(
        "=",
        cookieAv,
        position
      );
      attributeValue = cookieAv.slice(position.position + 1);
    } else {
      attributeName = cookieAv;
    }
    attributeName = attributeName.trim();
    attributeValue = attributeValue.trim();
    if (attributeValue.length > maxAttributeValueSize) {
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    const attributeNameLowercase = attributeName.toLowerCase();
    if (attributeNameLowercase === "expires") {
      const expiryTime = new Date(attributeValue);
      cookieAttributeList.expires = expiryTime;
    } else if (attributeNameLowercase === "max-age") {
      const charCode = attributeValue.charCodeAt(0);
      if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      if (!/^\d+$/.test(attributeValue)) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const deltaSeconds = Number(attributeValue);
      cookieAttributeList.maxAge = deltaSeconds;
    } else if (attributeNameLowercase === "domain") {
      let cookieDomain = attributeValue;
      if (cookieDomain[0] === ".") {
        cookieDomain = cookieDomain.slice(1);
      }
      cookieDomain = cookieDomain.toLowerCase();
      cookieAttributeList.domain = cookieDomain;
    } else if (attributeNameLowercase === "path") {
      let cookiePath = "";
      if (attributeValue.length === 0 || attributeValue[0] !== "/") {
        cookiePath = "/";
      } else {
        cookiePath = attributeValue;
      }
      cookieAttributeList.path = cookiePath;
    } else if (attributeNameLowercase === "secure") {
      cookieAttributeList.secure = true;
    } else if (attributeNameLowercase === "httponly") {
      cookieAttributeList.httpOnly = true;
    } else if (attributeNameLowercase === "samesite") {
      let enforcement = "Default";
      const attributeValueLowercase = attributeValue.toLowerCase();
      if (attributeValueLowercase.includes("none")) {
        enforcement = "None";
      }
      if (attributeValueLowercase.includes("strict")) {
        enforcement = "Strict";
      }
      if (attributeValueLowercase.includes("lax")) {
        enforcement = "Lax";
      }
      cookieAttributeList.sameSite = enforcement;
    } else {
      cookieAttributeList.unparsed ??= [];
      cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
    }
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
  }
  parse$2 = {
    parseSetCookie,
    parseUnparsedAttributes
  };
  return parse$2;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies) return cookies;
  hasRequiredCookies = 1;
  const { parseSetCookie } = requireParse();
  const { stringify: stringify2 } = requireUtil$2();
  const { webidl } = requireWebidl();
  const { Headers: Headers2 } = requireHeaders();
  function getCookies(headers2) {
    webidl.argumentLengthCheck(arguments, 1, "getCookies");
    webidl.brandCheck(headers2, Headers2, { strict: false });
    const cookie = headers2.get("cookie");
    const out = {};
    if (!cookie) {
      return out;
    }
    for (const piece of cookie.split(";")) {
      const [name, ...value] = piece.split("=");
      out[name.trim()] = value.join("=");
    }
    return out;
  }
  function deleteCookie(headers2, name, attributes) {
    webidl.brandCheck(headers2, Headers2, { strict: false });
    const prefix = "deleteCookie";
    webidl.argumentLengthCheck(arguments, 2, prefix);
    name = webidl.converters.DOMString(name, prefix, "name");
    attributes = webidl.converters.DeleteCookieAttributes(attributes);
    setCookie(headers2, {
      name,
      value: "",
      expires: /* @__PURE__ */ new Date(0),
      ...attributes
    });
  }
  function getSetCookies(headers2) {
    webidl.argumentLengthCheck(arguments, 1, "getSetCookies");
    webidl.brandCheck(headers2, Headers2, { strict: false });
    const cookies2 = headers2.getSetCookie();
    if (!cookies2) {
      return [];
    }
    return cookies2.map((pair) => parseSetCookie(pair));
  }
  function setCookie(headers2, cookie) {
    webidl.argumentLengthCheck(arguments, 2, "setCookie");
    webidl.brandCheck(headers2, Headers2, { strict: false });
    cookie = webidl.converters.Cookie(cookie);
    const str = stringify2(cookie);
    if (str) {
      headers2.append("Set-Cookie", str);
    }
  }
  webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    }
  ]);
  webidl.converters.Cookie = webidl.dictionaryConverter([
    {
      converter: webidl.converters.DOMString,
      key: "name"
    },
    {
      converter: webidl.converters.DOMString,
      key: "value"
    },
    {
      converter: webidl.nullableConverter((value) => {
        if (typeof value === "number") {
          return webidl.converters["unsigned long long"](value);
        }
        return new Date(value);
      }),
      key: "expires",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters["long long"]),
      key: "maxAge",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "secure",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "httpOnly",
      defaultValue: () => null
    },
    {
      converter: webidl.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: webidl.sequenceConverter(webidl.converters.DOMString),
      key: "unparsed",
      defaultValue: () => new Array(0)
    }
  ]);
  cookies = {
    getCookies,
    deleteCookie,
    getSetCookies,
    setCookie
  };
  return cookies;
}
var events;
var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events;
  hasRequiredEvents = 1;
  const { webidl } = requireWebidl();
  const { kEnumerableProperty } = requireUtil$7();
  const { kConstruct } = requireSymbols$4();
  const { MessagePort } = require$$3;
  class MessageEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      if (type === kConstruct) {
        super(arguments[1], arguments[2]);
        return;
      }
      const prefix = "MessageEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, "eventInitDict");
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get data() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.data;
    }
    get origin() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.origin;
    }
    get lastEventId() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.lastEventId;
    }
    get source() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.source;
    }
    get ports() {
      webidl.brandCheck(this, MessageEvent);
      if (!Object.isFrozen(this.#eventInit.ports)) {
        Object.freeze(this.#eventInit.ports);
      }
      return this.#eventInit.ports;
    }
    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
      webidl.brandCheck(this, MessageEvent);
      webidl.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent");
      return new MessageEvent(type, {
        bubbles,
        cancelable,
        data,
        origin,
        lastEventId,
        source,
        ports
      });
    }
    static createFastMessageEvent(type, init) {
      const messageEvent = new MessageEvent(kConstruct, type, init);
      messageEvent.#eventInit = init;
      messageEvent.#eventInit.data ??= null;
      messageEvent.#eventInit.origin ??= "";
      messageEvent.#eventInit.lastEventId ??= "";
      messageEvent.#eventInit.source ??= null;
      messageEvent.#eventInit.ports ??= [];
      return messageEvent;
    }
  }
  const { createFastMessageEvent } = MessageEvent;
  delete MessageEvent.createFastMessageEvent;
  class CloseEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      const prefix = "CloseEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get wasClean() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.wasClean;
    }
    get code() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.code;
    }
    get reason() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.reason;
    }
  }
  class ErrorEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict) {
      const prefix = "ErrorEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      super(type, eventInitDict);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
      this.#eventInit = eventInitDict;
    }
    get message() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.message;
    }
    get filename() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.filename;
    }
    get lineno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.lineno;
    }
    get colno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.colno;
    }
    get error() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.error;
    }
  }
  Object.defineProperties(MessageEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: true
    },
    data: kEnumerableProperty,
    origin: kEnumerableProperty,
    lastEventId: kEnumerableProperty,
    source: kEnumerableProperty,
    ports: kEnumerableProperty,
    initMessageEvent: kEnumerableProperty
  });
  Object.defineProperties(CloseEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: true
    },
    reason: kEnumerableProperty,
    code: kEnumerableProperty,
    wasClean: kEnumerableProperty
  });
  Object.defineProperties(ErrorEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: true
    },
    message: kEnumerableProperty,
    filename: kEnumerableProperty,
    lineno: kEnumerableProperty,
    colno: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
  webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
    webidl.converters.MessagePort
  );
  const eventInit = [
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ];
  webidl.converters.MessageEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "data",
      converter: webidl.converters.any,
      defaultValue: () => null
    },
    {
      key: "origin",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lastEventId",
      converter: webidl.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "source",
      // Node doesn't implement WindowProxy or ServiceWorker, so the only
      // valid value for source is a MessagePort.
      converter: webidl.nullableConverter(webidl.converters.MessagePort),
      defaultValue: () => null
    },
    {
      key: "ports",
      converter: webidl.converters["sequence<MessagePort>"],
      defaultValue: () => new Array(0)
    }
  ]);
  webidl.converters.CloseEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "wasClean",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "code",
      converter: webidl.converters["unsigned short"],
      defaultValue: () => 0
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    }
  ]);
  webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "message",
      converter: webidl.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "filename",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lineno",
      converter: webidl.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "colno",
      converter: webidl.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "error",
      converter: webidl.converters.any
    }
  ]);
  events = {
    MessageEvent,
    CloseEvent,
    ErrorEvent,
    createFastMessageEvent
  };
  return events;
}
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  const uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  const staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  const states = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  };
  const sentCloseFrameState = {
    NOT_SENT: 0,
    PROCESSING: 1,
    SENT: 2
  };
  const opcodes = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  };
  const maxUnsigned16Bit = 2 ** 16 - 1;
  const parserStates = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  };
  const emptyBuffer = Buffer.allocUnsafe(0);
  const sendHints = {
    string: 1,
    typedArray: 2,
    arrayBuffer: 3,
    blob: 4
  };
  constants = {
    uid,
    sentCloseFrameState,
    staticPropertyDescriptors,
    states,
    opcodes,
    maxUnsigned16Bit,
    parserStates,
    emptyBuffer,
    sendHints
  };
  return constants;
}
var symbols;
var hasRequiredSymbols;
function requireSymbols() {
  if (hasRequiredSymbols) return symbols;
  hasRequiredSymbols = 1;
  symbols = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser")
  };
  return symbols;
}
var util$1;
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  const { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = requireSymbols();
  const { states, opcodes } = requireConstants();
  const { ErrorEvent, createFastMessageEvent } = requireEvents();
  const { isUtf8 } = require$$0$2;
  const { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = requireDataUrl();
  function isConnecting(ws) {
    return ws[kReadyState] === states.CONNECTING;
  }
  function isEstablished(ws) {
    return ws[kReadyState] === states.OPEN;
  }
  function isClosing(ws) {
    return ws[kReadyState] === states.CLOSING;
  }
  function isClosed(ws) {
    return ws[kReadyState] === states.CLOSED;
  }
  function fireEvent(e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {
    const event = eventFactory(e, eventInitDict);
    target.dispatchEvent(event);
  }
  function websocketMessageReceived(ws, type, data) {
    if (ws[kReadyState] !== states.OPEN) {
      return;
    }
    let dataForEvent;
    if (type === opcodes.TEXT) {
      try {
        dataForEvent = utf8Decode(data);
      } catch {
        failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
        return;
      }
    } else if (type === opcodes.BINARY) {
      if (ws[kBinaryType] === "blob") {
        dataForEvent = new Blob([data]);
      } else {
        dataForEvent = toArrayBuffer(data);
      }
    }
    fireEvent("message", ws, createFastMessageEvent, {
      origin: ws[kWebSocketURL].origin,
      data: dataForEvent
    });
  }
  function toArrayBuffer(buffer) {
    if (buffer.byteLength === buffer.buffer.byteLength) {
      return buffer.buffer;
    }
    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
  }
  function isValidSubprotocol(protocol) {
    if (protocol.length === 0) {
      return false;
    }
    for (let i = 0; i < protocol.length; ++i) {
      const code = protocol.charCodeAt(i);
      if (code < 33 || // CTL, contains SP (0x20) and HT (0x09)
      code > 126 || code === 34 || // "
      code === 40 || // (
      code === 41 || // )
      code === 44 || // ,
      code === 47 || // /
      code === 58 || // :
      code === 59 || // ;
      code === 60 || // <
      code === 61 || // =
      code === 62 || // >
      code === 63 || // ?
      code === 64 || // @
      code === 91 || // [
      code === 92 || // \
      code === 93 || // ]
      code === 123 || // {
      code === 125) {
        return false;
      }
    }
    return true;
  }
  function isValidStatusCode(code) {
    if (code >= 1e3 && code < 1015) {
      return code !== 1004 && // reserved
      code !== 1005 && // "MUST NOT be set as a status code"
      code !== 1006;
    }
    return code >= 3e3 && code <= 4999;
  }
  function failWebsocketConnection(ws, reason) {
    const { [kController]: controller, [kResponse]: response2 } = ws;
    controller.abort();
    if (response2?.socket && !response2.socket.destroyed) {
      response2.socket.destroy();
    }
    if (reason) {
      fireEvent("error", ws, (type, init) => new ErrorEvent(type, init), {
        error: new Error(reason),
        message: reason
      });
    }
  }
  function isControlFrame(opcode) {
    return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;
  }
  function isContinuationFrame(opcode) {
    return opcode === opcodes.CONTINUATION;
  }
  function isTextBinaryFrame(opcode) {
    return opcode === opcodes.TEXT || opcode === opcodes.BINARY;
  }
  function isValidOpcode(opcode) {
    return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);
  }
  function parseExtensions(extensions) {
    const position = { position: 0 };
    const extensionList = /* @__PURE__ */ new Map();
    while (position.position < extensions.length) {
      const pair = collectASequenceOfCodePointsFast(";", extensions, position);
      const [name, value = ""] = pair.split("=");
      extensionList.set(
        removeHTTPWhitespace(name, true, false),
        removeHTTPWhitespace(value, false, true)
      );
      position.position++;
    }
    return extensionList;
  }
  function isValidClientWindowBits(value) {
    for (let i = 0; i < value.length; i++) {
      const byte = value.charCodeAt(i);
      if (byte < 48 || byte > 57) {
        return false;
      }
    }
    return true;
  }
  const hasIntl = typeof process.versions.icu === "string";
  const fatalDecoder = hasIntl ? new TextDecoder("utf-8", { fatal: true }) : void 0;
  const utf8Decode = hasIntl ? fatalDecoder.decode.bind(fatalDecoder) : function(buffer) {
    if (isUtf8(buffer)) {
      return buffer.toString("utf-8");
    }
    throw new TypeError("Invalid utf-8 received.");
  };
  util$1 = {
    isConnecting,
    isEstablished,
    isClosing,
    isClosed,
    fireEvent,
    isValidSubprotocol,
    isValidStatusCode,
    failWebsocketConnection,
    websocketMessageReceived,
    utf8Decode,
    isControlFrame,
    isContinuationFrame,
    isTextBinaryFrame,
    isValidOpcode,
    parseExtensions,
    isValidClientWindowBits
  };
  return util$1;
}
var frame;
var hasRequiredFrame;
function requireFrame() {
  if (hasRequiredFrame) return frame;
  hasRequiredFrame = 1;
  const { maxUnsigned16Bit } = requireConstants();
  const BUFFER_SIZE = 16386;
  let crypto;
  let buffer = null;
  let bufIdx = BUFFER_SIZE;
  try {
    crypto = require("node:crypto");
  } catch {
    crypto = {
      // not full compatibility, but minimum.
      randomFillSync: function randomFillSync(buffer2, _offset, _size) {
        for (let i = 0; i < buffer2.length; ++i) {
          buffer2[i] = Math.random() * 255 | 0;
        }
        return buffer2;
      }
    };
  }
  function generateMask() {
    if (bufIdx === BUFFER_SIZE) {
      bufIdx = 0;
      crypto.randomFillSync(buffer ??= Buffer.allocUnsafe(BUFFER_SIZE), 0, BUFFER_SIZE);
    }
    return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]];
  }
  class WebsocketFrameSend {
    /**
     * @param {Buffer|undefined} data
     */
    constructor(data) {
      this.frameData = data;
    }
    createFrame(opcode) {
      const frameData = this.frameData;
      const maskKey = generateMask();
      const bodyLength = frameData?.byteLength ?? 0;
      let payloadLength = bodyLength;
      let offset = 6;
      if (bodyLength > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const buffer2 = Buffer.allocUnsafe(bodyLength + offset);
      buffer2[0] = buffer2[1] = 0;
      buffer2[0] |= 128;
      buffer2[0] = (buffer2[0] & 240) + opcode;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      buffer2[offset - 4] = maskKey[0];
      buffer2[offset - 3] = maskKey[1];
      buffer2[offset - 2] = maskKey[2];
      buffer2[offset - 1] = maskKey[3];
      buffer2[1] = payloadLength;
      if (payloadLength === 126) {
        buffer2.writeUInt16BE(bodyLength, 2);
      } else if (payloadLength === 127) {
        buffer2[2] = buffer2[3] = 0;
        buffer2.writeUIntBE(bodyLength, 4, 6);
      }
      buffer2[1] |= 128;
      for (let i = 0; i < bodyLength; ++i) {
        buffer2[offset + i] = frameData[i] ^ maskKey[i & 3];
      }
      return buffer2;
    }
  }
  frame = {
    WebsocketFrameSend
  };
  return frame;
}
var connection;
var hasRequiredConnection;
function requireConnection() {
  if (hasRequiredConnection) return connection;
  hasRequiredConnection = 1;
  const { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = requireConstants();
  const {
    kReadyState,
    kSentClose,
    kByteParser,
    kReceivedClose,
    kResponse
  } = requireSymbols();
  const { fireEvent, failWebsocketConnection, isClosing, isClosed, isEstablished, parseExtensions } = requireUtil$1();
  const { channels } = requireDiagnostics();
  const { CloseEvent } = requireEvents();
  const { makeRequest: makeRequest2 } = requireRequest();
  const { fetching } = requireFetch();
  const { Headers: Headers2, getHeadersList } = requireHeaders();
  const { getDecodeSplit } = requireUtil$6();
  const { WebsocketFrameSend } = requireFrame();
  let crypto;
  try {
    crypto = require("node:crypto");
  } catch {
  }
  function establishWebSocketConnection(url, protocols, client2, ws, onEstablish, options) {
    const requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    const request2 = makeRequest2({
      urlList: [requestURL],
      client: client2,
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (options.headers) {
      const headersList = getHeadersList(new Headers2(options.headers));
      request2.headersList = headersList;
    }
    const keyValue = crypto.randomBytes(16).toString("base64");
    request2.headersList.append("sec-websocket-key", keyValue);
    request2.headersList.append("sec-websocket-version", "13");
    for (const protocol of protocols) {
      request2.headersList.append("sec-websocket-protocol", protocol);
    }
    const permessageDeflate2 = "permessage-deflate; client_max_window_bits";
    request2.headersList.append("sec-websocket-extensions", permessageDeflate2);
    const controller = fetching({
      request: request2,
      useParallelQueue: true,
      dispatcher: options.dispatcher,
      processResponse(response2) {
        if (response2.type === "error" || response2.status !== 101) {
          failWebsocketConnection(ws, "Received network error or non-101 status code.");
          return;
        }
        if (protocols.length !== 0 && !response2.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Server did not respond with sent protocols.");
          return;
        }
        if (response2.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (response2.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const secWSAccept = response2.headersList.get("Sec-WebSocket-Accept");
        const digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const secExtension = response2.headersList.get("Sec-WebSocket-Extensions");
        let extensions;
        if (secExtension !== null) {
          extensions = parseExtensions(secExtension);
          if (!extensions.has("permessage-deflate")) {
            failWebsocketConnection(ws, "Sec-WebSocket-Extensions header does not match.");
            return;
          }
        }
        const secProtocol = response2.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null) {
          const requestProtocols = getDecodeSplit("sec-websocket-protocol", request2.headersList);
          if (!requestProtocols.includes(secProtocol)) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
        }
        response2.socket.on("data", onSocketData);
        response2.socket.on("close", onSocketClose);
        response2.socket.on("error", onSocketError);
        if (channels.open.hasSubscribers) {
          channels.open.publish({
            address: response2.socket.address(),
            protocol: secProtocol,
            extensions: secExtension
          });
        }
        onEstablish(response2, extensions);
      }
    });
    return controller;
  }
  function closeWebSocketConnection(ws, code, reason, reasonByteLength) {
    if (isClosing(ws) || isClosed(ws)) ;
    else if (!isEstablished(ws)) {
      failWebsocketConnection(ws, "Connection was closed before it was established.");
      ws[kReadyState] = states.CLOSING;
    } else if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {
      ws[kSentClose] = sentCloseFrameState.PROCESSING;
      const frame2 = new WebsocketFrameSend();
      if (code !== void 0 && reason === void 0) {
        frame2.frameData = Buffer.allocUnsafe(2);
        frame2.frameData.writeUInt16BE(code, 0);
      } else if (code !== void 0 && reason !== void 0) {
        frame2.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
        frame2.frameData.writeUInt16BE(code, 0);
        frame2.frameData.write(reason, 2, "utf-8");
      } else {
        frame2.frameData = emptyBuffer;
      }
      const socket = ws[kResponse].socket;
      socket.write(frame2.createFrame(opcodes.CLOSE));
      ws[kSentClose] = sentCloseFrameState.SENT;
      ws[kReadyState] = states.CLOSING;
    } else {
      ws[kReadyState] = states.CLOSING;
    }
  }
  function onSocketData(chunk) {
    if (!this.ws[kByteParser].write(chunk)) {
      this.pause();
    }
  }
  function onSocketClose() {
    const { ws } = this;
    const { [kResponse]: response2 } = ws;
    response2.socket.off("data", onSocketData);
    response2.socket.off("close", onSocketClose);
    response2.socket.off("error", onSocketError);
    const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose];
    let code = 1005;
    let reason = "";
    const result = ws[kByteParser].closingInfo;
    if (result && !result.error) {
      code = result.code ?? 1005;
      reason = result.reason;
    } else if (!ws[kReceivedClose]) {
      code = 1006;
    }
    ws[kReadyState] = states.CLOSED;
    fireEvent("close", ws, (type, init) => new CloseEvent(type, init), {
      wasClean,
      code,
      reason
    });
    if (channels.close.hasSubscribers) {
      channels.close.publish({
        websocket: ws,
        code,
        reason
      });
    }
  }
  function onSocketError(error) {
    const { ws } = this;
    ws[kReadyState] = states.CLOSING;
    if (channels.socketError.hasSubscribers) {
      channels.socketError.publish(error);
    }
    this.destroy();
  }
  connection = {
    establishWebSocketConnection,
    closeWebSocketConnection
  };
  return connection;
}
var permessageDeflate;
var hasRequiredPermessageDeflate;
function requirePermessageDeflate() {
  if (hasRequiredPermessageDeflate) return permessageDeflate;
  hasRequiredPermessageDeflate = 1;
  const { createInflateRaw, Z_DEFAULT_WINDOWBITS } = require$$1$2;
  const { isValidClientWindowBits } = requireUtil$1();
  const tail = Buffer.from([0, 0, 255, 255]);
  const kBuffer = Symbol("kBuffer");
  const kLength = Symbol("kLength");
  class PerMessageDeflate {
    /** @type {import('node:zlib').InflateRaw} */
    #inflate;
    #options = {};
    constructor(extensions) {
      this.#options.serverNoContextTakeover = extensions.has("server_no_context_takeover");
      this.#options.serverMaxWindowBits = extensions.get("server_max_window_bits");
    }
    decompress(chunk, fin, callback) {
      if (!this.#inflate) {
        let windowBits = Z_DEFAULT_WINDOWBITS;
        if (this.#options.serverMaxWindowBits) {
          if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {
            callback(new Error("Invalid server_max_window_bits"));
            return;
          }
          windowBits = Number.parseInt(this.#options.serverMaxWindowBits);
        }
        this.#inflate = createInflateRaw({ windowBits });
        this.#inflate[kBuffer] = [];
        this.#inflate[kLength] = 0;
        this.#inflate.on("data", (data) => {
          this.#inflate[kBuffer].push(data);
          this.#inflate[kLength] += data.length;
        });
        this.#inflate.on("error", (err) => {
          this.#inflate = null;
          callback(err);
        });
      }
      this.#inflate.write(chunk);
      if (fin) {
        this.#inflate.write(tail);
      }
      this.#inflate.flush(() => {
        const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength]);
        this.#inflate[kBuffer].length = 0;
        this.#inflate[kLength] = 0;
        callback(null, full);
      });
    }
  }
  permessageDeflate = { PerMessageDeflate };
  return permessageDeflate;
}
var receiver;
var hasRequiredReceiver;
function requireReceiver() {
  if (hasRequiredReceiver) return receiver;
  hasRequiredReceiver = 1;
  const { Writable } = require$$0$4;
  const assert = require$$0$3;
  const { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = requireConstants();
  const { kReadyState, kSentClose, kResponse, kReceivedClose } = requireSymbols();
  const { channels } = requireDiagnostics();
  const {
    isValidStatusCode,
    isValidOpcode,
    failWebsocketConnection,
    websocketMessageReceived,
    utf8Decode,
    isControlFrame,
    isTextBinaryFrame,
    isContinuationFrame
  } = requireUtil$1();
  const { WebsocketFrameSend } = requireFrame();
  const { closeWebSocketConnection } = requireConnection();
  const { PerMessageDeflate } = requirePermessageDeflate();
  class ByteParser extends Writable {
    #buffers = [];
    #byteOffset = 0;
    #loop = false;
    #state = parserStates.INFO;
    #info = {};
    #fragments = [];
    /** @type {Map<string, PerMessageDeflate>} */
    #extensions;
    constructor(ws, extensions) {
      super();
      this.ws = ws;
      this.#extensions = extensions == null ? /* @__PURE__ */ new Map() : extensions;
      if (this.#extensions.has("permessage-deflate")) {
        this.#extensions.set("permessage-deflate", new PerMessageDeflate(extensions));
      }
    }
    /**
     * @param {Buffer} chunk
     * @param {() => void} callback
     */
    _write(chunk, _, callback) {
      this.#buffers.push(chunk);
      this.#byteOffset += chunk.length;
      this.#loop = true;
      this.run(callback);
    }
    /**
     * Runs whenever a new chunk is received.
     * Callback is called whenever there are no more chunks buffering,
     * or not enough bytes are buffered to parse.
     */
    run(callback) {
      while (this.#loop) {
        if (this.#state === parserStates.INFO) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          const fin = (buffer[0] & 128) !== 0;
          const opcode = buffer[0] & 15;
          const masked = (buffer[1] & 128) === 128;
          const fragmented = !fin && opcode !== opcodes.CONTINUATION;
          const payloadLength = buffer[1] & 127;
          const rsv1 = buffer[0] & 64;
          const rsv2 = buffer[0] & 32;
          const rsv3 = buffer[0] & 16;
          if (!isValidOpcode(opcode)) {
            failWebsocketConnection(this.ws, "Invalid opcode received");
            return callback();
          }
          if (masked) {
            failWebsocketConnection(this.ws, "Frame cannot be masked");
            return callback();
          }
          if (rsv1 !== 0 && !this.#extensions.has("permessage-deflate")) {
            failWebsocketConnection(this.ws, "Expected RSV1 to be clear.");
            return;
          }
          if (rsv2 !== 0 || rsv3 !== 0) {
            failWebsocketConnection(this.ws, "RSV1, RSV2, RSV3 must be clear");
            return;
          }
          if (fragmented && !isTextBinaryFrame(opcode)) {
            failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {
            failWebsocketConnection(this.ws, "Expected continuation frame");
            return;
          }
          if (this.#info.fragmented && fragmented) {
            failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          }
          if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {
            failWebsocketConnection(this.ws, "Control frame either too large or fragmented");
            return;
          }
          if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {
            failWebsocketConnection(this.ws, "Unexpected continuation frame");
            return;
          }
          if (payloadLength <= 125) {
            this.#info.payloadLength = payloadLength;
            this.#state = parserStates.READ_DATA;
          } else if (payloadLength === 126) {
            this.#state = parserStates.PAYLOADLENGTH_16;
          } else if (payloadLength === 127) {
            this.#state = parserStates.PAYLOADLENGTH_64;
          }
          if (isTextBinaryFrame(opcode)) {
            this.#info.binaryType = opcode;
            this.#info.compressed = rsv1 !== 0;
          }
          this.#info.opcode = opcode;
          this.#info.masked = masked;
          this.#info.fin = fin;
          this.#info.fragmented = fragmented;
        } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.payloadLength = buffer.readUInt16BE(0);
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
          if (this.#byteOffset < 8) {
            return callback();
          }
          const buffer = this.consume(8);
          const upper = buffer.readUInt32BE(0);
          if (upper > 2 ** 31 - 1) {
            failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          const lower = buffer.readUInt32BE(4);
          this.#info.payloadLength = (upper << 8) + lower;
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.READ_DATA) {
          if (this.#byteOffset < this.#info.payloadLength) {
            return callback();
          }
          const body2 = this.consume(this.#info.payloadLength);
          if (isControlFrame(this.#info.opcode)) {
            this.#loop = this.parseControlFrame(body2);
            this.#state = parserStates.INFO;
          } else {
            if (!this.#info.compressed) {
              this.#fragments.push(body2);
              if (!this.#info.fragmented && this.#info.fin) {
                const fullMessage = Buffer.concat(this.#fragments);
                websocketMessageReceived(this.ws, this.#info.binaryType, fullMessage);
                this.#fragments.length = 0;
              }
              this.#state = parserStates.INFO;
            } else {
              this.#extensions.get("permessage-deflate").decompress(body2, this.#info.fin, (error, data) => {
                if (error) {
                  closeWebSocketConnection(this.ws, 1007, error.message, error.message.length);
                  return;
                }
                this.#fragments.push(data);
                if (!this.#info.fin) {
                  this.#state = parserStates.INFO;
                  this.#loop = true;
                  this.run(callback);
                  return;
                }
                websocketMessageReceived(this.ws, this.#info.binaryType, Buffer.concat(this.#fragments));
                this.#loop = true;
                this.#state = parserStates.INFO;
                this.#fragments.length = 0;
                this.run(callback);
              });
              this.#loop = false;
              break;
            }
          }
        }
      }
    }
    /**
     * Take n bytes from the buffered Buffers
     * @param {number} n
     * @returns {Buffer}
     */
    consume(n) {
      if (n > this.#byteOffset) {
        throw new Error("Called consume() before buffers satiated.");
      } else if (n === 0) {
        return emptyBuffer;
      }
      if (this.#buffers[0].length === n) {
        this.#byteOffset -= this.#buffers[0].length;
        return this.#buffers.shift();
      }
      const buffer = Buffer.allocUnsafe(n);
      let offset = 0;
      while (offset !== n) {
        const next = this.#buffers[0];
        const { length } = next;
        if (length + offset === n) {
          buffer.set(this.#buffers.shift(), offset);
          break;
        } else if (length + offset > n) {
          buffer.set(next.subarray(0, n - offset), offset);
          this.#buffers[0] = next.subarray(n - offset);
          break;
        } else {
          buffer.set(this.#buffers.shift(), offset);
          offset += next.length;
        }
      }
      this.#byteOffset -= n;
      return buffer;
    }
    parseCloseBody(data) {
      assert(data.length !== 1);
      let code;
      if (data.length >= 2) {
        code = data.readUInt16BE(0);
      }
      if (code !== void 0 && !isValidStatusCode(code)) {
        return { code: 1002, reason: "Invalid status code", error: true };
      }
      let reason = data.subarray(2);
      if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
        reason = reason.subarray(3);
      }
      try {
        reason = utf8Decode(reason);
      } catch {
        return { code: 1007, reason: "Invalid UTF-8", error: true };
      }
      return { code, reason, error: false };
    }
    /**
     * Parses control frames.
     * @param {Buffer} body
     */
    parseControlFrame(body2) {
      const { opcode, payloadLength } = this.#info;
      if (opcode === opcodes.CLOSE) {
        if (payloadLength === 1) {
          failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
          return false;
        }
        this.#info.closeInfo = this.parseCloseBody(body2);
        if (this.#info.closeInfo.error) {
          const { code, reason } = this.#info.closeInfo;
          closeWebSocketConnection(this.ws, code, reason, reason.length);
          failWebsocketConnection(this.ws, reason);
          return false;
        }
        if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {
          let body3 = emptyBuffer;
          if (this.#info.closeInfo.code) {
            body3 = Buffer.allocUnsafe(2);
            body3.writeUInt16BE(this.#info.closeInfo.code, 0);
          }
          const closeFrame = new WebsocketFrameSend(body3);
          this.ws[kResponse].socket.write(
            closeFrame.createFrame(opcodes.CLOSE),
            (err) => {
              if (!err) {
                this.ws[kSentClose] = sentCloseFrameState.SENT;
              }
            }
          );
        }
        this.ws[kReadyState] = states.CLOSING;
        this.ws[kReceivedClose] = true;
        return false;
      } else if (opcode === opcodes.PING) {
        if (!this.ws[kReceivedClose]) {
          const frame2 = new WebsocketFrameSend(body2);
          this.ws[kResponse].socket.write(frame2.createFrame(opcodes.PONG));
          if (channels.ping.hasSubscribers) {
            channels.ping.publish({
              payload: body2
            });
          }
        }
      } else if (opcode === opcodes.PONG) {
        if (channels.pong.hasSubscribers) {
          channels.pong.publish({
            payload: body2
          });
        }
      }
      return true;
    }
    get closingInfo() {
      return this.#info.closeInfo;
    }
  }
  receiver = {
    ByteParser
  };
  return receiver;
}
var sender;
var hasRequiredSender;
function requireSender() {
  if (hasRequiredSender) return sender;
  hasRequiredSender = 1;
  const { WebsocketFrameSend } = requireFrame();
  const { opcodes, sendHints } = requireConstants();
  const FixedQueue = requireFixedQueue();
  const FastBuffer = Buffer[Symbol.species];
  class SendQueue {
    /**
     * @type {FixedQueue}
     */
    #queue = new FixedQueue();
    /**
     * @type {boolean}
     */
    #running = false;
    /** @type {import('node:net').Socket} */
    #socket;
    constructor(socket) {
      this.#socket = socket;
    }
    add(item, cb, hint) {
      if (hint !== sendHints.blob) {
        const frame2 = createFrame(item, hint);
        if (!this.#running) {
          this.#socket.write(frame2, cb);
        } else {
          const node3 = {
            promise: null,
            callback: cb,
            frame: frame2
          };
          this.#queue.push(node3);
        }
        return;
      }
      const node2 = {
        promise: item.arrayBuffer().then((ab) => {
          node2.promise = null;
          node2.frame = createFrame(ab, hint);
        }),
        callback: cb,
        frame: null
      };
      this.#queue.push(node2);
      if (!this.#running) {
        this.#run();
      }
    }
    async #run() {
      this.#running = true;
      const queue = this.#queue;
      while (!queue.isEmpty()) {
        const node2 = queue.shift();
        if (node2.promise !== null) {
          await node2.promise;
        }
        this.#socket.write(node2.frame, node2.callback);
        node2.callback = node2.frame = null;
      }
      this.#running = false;
    }
  }
  function createFrame(data, hint) {
    return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.string ? opcodes.TEXT : opcodes.BINARY);
  }
  function toBuffer(data, hint) {
    switch (hint) {
      case sendHints.string:
        return Buffer.from(data);
      case sendHints.arrayBuffer:
      case sendHints.blob:
        return new FastBuffer(data);
      case sendHints.typedArray:
        return new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    }
  }
  sender = { SendQueue };
  return sender;
}
var websocket;
var hasRequiredWebsocket;
function requireWebsocket() {
  if (hasRequiredWebsocket) return websocket;
  hasRequiredWebsocket = 1;
  const { webidl } = requireWebidl();
  const { URLSerializer } = requireDataUrl();
  const { environmentSettingsObject } = requireUtil$6();
  const { staticPropertyDescriptors, states, sentCloseFrameState, sendHints } = requireConstants();
  const {
    kWebSocketURL,
    kReadyState,
    kController,
    kBinaryType,
    kResponse,
    kSentClose,
    kByteParser
  } = requireSymbols();
  const {
    isConnecting,
    isEstablished,
    isClosing,
    isValidSubprotocol,
    fireEvent
  } = requireUtil$1();
  const { establishWebSocketConnection, closeWebSocketConnection } = requireConnection();
  const { ByteParser } = requireReceiver();
  const { kEnumerableProperty, isBlobLike } = requireUtil$7();
  const { getGlobalDispatcher } = requireGlobal();
  const { types: types2 } = require$$0$5;
  const { ErrorEvent, CloseEvent } = requireEvents();
  const { SendQueue } = requireSender();
  class WebSocket extends EventTarget {
    #events = {
      open: null,
      error: null,
      close: null,
      message: null
    };
    #bufferedAmount = 0;
    #protocol = "";
    #extensions = "";
    /** @type {SendQueue} */
    #sendQueue;
    /**
     * @param {string} url
     * @param {string|string[]} protocols
     */
    constructor(url, protocols = []) {
      super();
      const prefix = "WebSocket constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols, prefix, "options");
      url = webidl.converters.USVString(url, prefix, "url");
      protocols = options.protocols;
      const baseURL = environmentSettingsObject.settingsObject.baseUrl;
      let urlRecord;
      try {
        urlRecord = new URL(url, baseURL);
      } catch (e) {
        throw new DOMException(e, "SyntaxError");
      }
      if (urlRecord.protocol === "http:") {
        urlRecord.protocol = "ws:";
      } else if (urlRecord.protocol === "https:") {
        urlRecord.protocol = "wss:";
      }
      if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
        throw new DOMException(
          `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
          "SyntaxError"
        );
      }
      if (urlRecord.hash || urlRecord.href.endsWith("#")) {
        throw new DOMException("Got fragment", "SyntaxError");
      }
      if (typeof protocols === "string") {
        protocols = [protocols];
      }
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      this[kWebSocketURL] = new URL(urlRecord.href);
      const client2 = environmentSettingsObject.settingsObject;
      this[kController] = establishWebSocketConnection(
        urlRecord,
        protocols,
        client2,
        this,
        (response2, extensions) => this.#onConnectionEstablished(response2, extensions),
        options
      );
      this[kReadyState] = WebSocket.CONNECTING;
      this[kSentClose] = sentCloseFrameState.NOT_SENT;
      this[kBinaryType] = "blob";
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-close
     * @param {number|undefined} code
     * @param {string|undefined} reason
     */
    close(code = void 0, reason = void 0) {
      webidl.brandCheck(this, WebSocket);
      const prefix = "WebSocket.close";
      if (code !== void 0) {
        code = webidl.converters["unsigned short"](code, prefix, "code", { clamp: true });
      }
      if (reason !== void 0) {
        reason = webidl.converters.USVString(reason, prefix, "reason");
      }
      if (code !== void 0) {
        if (code !== 1e3 && (code < 3e3 || code > 4999)) {
          throw new DOMException("invalid code", "InvalidAccessError");
        }
      }
      let reasonByteLength = 0;
      if (reason !== void 0) {
        reasonByteLength = Buffer.byteLength(reason);
        if (reasonByteLength > 123) {
          throw new DOMException(
            `Reason must be less than 123 bytes; received ${reasonByteLength}`,
            "SyntaxError"
          );
        }
      }
      closeWebSocketConnection(this, code, reason, reasonByteLength);
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-send
     * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
     */
    send(data) {
      webidl.brandCheck(this, WebSocket);
      const prefix = "WebSocket.send";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      data = webidl.converters.WebSocketSendData(data, prefix, "data");
      if (isConnecting(this)) {
        throw new DOMException("Sent before connected.", "InvalidStateError");
      }
      if (!isEstablished(this) || isClosing(this)) {
        return;
      }
      if (typeof data === "string") {
        const length = Buffer.byteLength(data);
        this.#bufferedAmount += length;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= length;
        }, sendHints.string);
      } else if (types2.isArrayBuffer(data)) {
        this.#bufferedAmount += data.byteLength;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= data.byteLength;
        }, sendHints.arrayBuffer);
      } else if (ArrayBuffer.isView(data)) {
        this.#bufferedAmount += data.byteLength;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= data.byteLength;
        }, sendHints.typedArray);
      } else if (isBlobLike(data)) {
        this.#bufferedAmount += data.size;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= data.size;
        }, sendHints.blob);
      }
    }
    get readyState() {
      webidl.brandCheck(this, WebSocket);
      return this[kReadyState];
    }
    get bufferedAmount() {
      webidl.brandCheck(this, WebSocket);
      return this.#bufferedAmount;
    }
    get url() {
      webidl.brandCheck(this, WebSocket);
      return URLSerializer(this[kWebSocketURL]);
    }
    get extensions() {
      webidl.brandCheck(this, WebSocket);
      return this.#extensions;
    }
    get protocol() {
      webidl.brandCheck(this, WebSocket);
      return this.#protocol;
    }
    get onopen() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.open;
    }
    set onopen(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      if (typeof fn === "function") {
        this.#events.open = fn;
        this.addEventListener("open", fn);
      } else {
        this.#events.open = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      if (typeof fn === "function") {
        this.#events.error = fn;
        this.addEventListener("error", fn);
      } else {
        this.#events.error = null;
      }
    }
    get onclose() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.close;
    }
    set onclose(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.close) {
        this.removeEventListener("close", this.#events.close);
      }
      if (typeof fn === "function") {
        this.#events.close = fn;
        this.addEventListener("close", fn);
      } else {
        this.#events.close = null;
      }
    }
    get onmessage() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.message;
    }
    set onmessage(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      if (typeof fn === "function") {
        this.#events.message = fn;
        this.addEventListener("message", fn);
      } else {
        this.#events.message = null;
      }
    }
    get binaryType() {
      webidl.brandCheck(this, WebSocket);
      return this[kBinaryType];
    }
    set binaryType(type) {
      webidl.brandCheck(this, WebSocket);
      if (type !== "blob" && type !== "arraybuffer") {
        this[kBinaryType] = "blob";
      } else {
        this[kBinaryType] = type;
      }
    }
    /**
     * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
     */
    #onConnectionEstablished(response2, parsedExtensions) {
      this[kResponse] = response2;
      const parser = new ByteParser(this, parsedExtensions);
      parser.on("drain", onParserDrain);
      parser.on("error", onParserError.bind(this));
      response2.socket.ws = this;
      this[kByteParser] = parser;
      this.#sendQueue = new SendQueue(response2.socket);
      this[kReadyState] = states.OPEN;
      const extensions = response2.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        this.#extensions = extensions;
      }
      const protocol = response2.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        this.#protocol = protocol;
      }
      fireEvent("open", this);
    }
  }
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty,
    readyState: kEnumerableProperty,
    bufferedAmount: kEnumerableProperty,
    onopen: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onclose: kEnumerableProperty,
    close: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    binaryType: kEnumerableProperty,
    send: kEnumerableProperty,
    extensions: kEnumerableProperty,
    protocol: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
    webidl.converters.DOMString
  );
  webidl.converters["DOMString or sequence<DOMString>"] = function(V, prefix, argument) {
    if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
      return webidl.converters["sequence<DOMString>"](V);
    }
    return webidl.converters.DOMString(V, prefix, argument);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.converters["DOMString or sequence<DOMString>"],
      defaultValue: () => new Array(0)
    },
    {
      key: "dispatcher",
      converter: webidl.converters.any,
      defaultValue: () => getGlobalDispatcher()
    },
    {
      key: "headers",
      converter: webidl.nullableConverter(webidl.converters.HeadersInit)
    }
  ]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
    if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
      return webidl.converters.WebSocketInit(V);
    }
    return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
  };
  webidl.converters.WebSocketSendData = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types2.isArrayBuffer(V)) {
        return webidl.converters.BufferSource(V);
      }
    }
    return webidl.converters.USVString(V);
  };
  function onParserDrain() {
    this.ws[kResponse].socket.resume();
  }
  function onParserError(err) {
    let message;
    let code;
    if (err instanceof CloseEvent) {
      message = err.reason;
      code = err.code;
    } else {
      message = err.message;
    }
    fireEvent("error", this, () => new ErrorEvent("error", { error: err, message }));
    closeWebSocketConnection(this, code);
  }
  websocket = {
    WebSocket
  };
  return websocket;
}
var util;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  function isValidLastEventId(value) {
    return value.indexOf("\0") === -1;
  }
  function isASCIINumber(value) {
    if (value.length === 0) return false;
    for (let i = 0; i < value.length; i++) {
      if (value.charCodeAt(i) < 48 || value.charCodeAt(i) > 57) return false;
    }
    return true;
  }
  function delay(ms2) {
    return new Promise((resolve2) => {
      setTimeout(resolve2, ms2).unref();
    });
  }
  util = {
    isValidLastEventId,
    isASCIINumber,
    delay
  };
  return util;
}
var eventsourceStream;
var hasRequiredEventsourceStream;
function requireEventsourceStream() {
  if (hasRequiredEventsourceStream) return eventsourceStream;
  hasRequiredEventsourceStream = 1;
  const { Transform } = require$$0$4;
  const { isASCIINumber, isValidLastEventId } = requireUtil();
  const BOM = [239, 187, 191];
  const LF = 10;
  const CR = 13;
  const COLON = 58;
  const SPACE = 32;
  class EventSourceStream extends Transform {
    /**
     * @type {eventSourceSettings}
     */
    state = null;
    /**
     * Leading byte-order-mark check.
     * @type {boolean}
     */
    checkBOM = true;
    /**
     * @type {boolean}
     */
    crlfCheck = false;
    /**
     * @type {boolean}
     */
    eventEndCheck = false;
    /**
     * @type {Buffer}
     */
    buffer = null;
    pos = 0;
    event = {
      data: void 0,
      event: void 0,
      id: void 0,
      retry: void 0
    };
    /**
     * @param {object} options
     * @param {eventSourceSettings} options.eventSourceSettings
     * @param {Function} [options.push]
     */
    constructor(options = {}) {
      options.readableObjectMode = true;
      super(options);
      this.state = options.eventSourceSettings || {};
      if (options.push) {
        this.push = options.push;
      }
    }
    /**
     * @param {Buffer} chunk
     * @param {string} _encoding
     * @param {Function} callback
     * @returns {void}
     */
    _transform(chunk, _encoding, callback) {
      if (chunk.length === 0) {
        callback();
        return;
      }
      if (this.buffer) {
        this.buffer = Buffer.concat([this.buffer, chunk]);
      } else {
        this.buffer = chunk;
      }
      if (this.checkBOM) {
        switch (this.buffer.length) {
          case 1:
            if (this.buffer[0] === BOM[0]) {
              callback();
              return;
            }
            this.checkBOM = false;
            callback();
            return;
          case 2:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {
              callback();
              return;
            }
            this.checkBOM = false;
            break;
          case 3:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = Buffer.alloc(0);
              this.checkBOM = false;
              callback();
              return;
            }
            this.checkBOM = false;
            break;
          default:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = this.buffer.subarray(3);
            }
            this.checkBOM = false;
            break;
        }
      }
      while (this.pos < this.buffer.length) {
        if (this.eventEndCheck) {
          if (this.crlfCheck) {
            if (this.buffer[this.pos] === LF) {
              this.buffer = this.buffer.subarray(this.pos + 1);
              this.pos = 0;
              this.crlfCheck = false;
              continue;
            }
            this.crlfCheck = false;
          }
          if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
            if (this.buffer[this.pos] === CR) {
              this.crlfCheck = true;
            }
            this.buffer = this.buffer.subarray(this.pos + 1);
            this.pos = 0;
            if (this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) {
              this.processEvent(this.event);
            }
            this.clearEvent();
            continue;
          }
          this.eventEndCheck = false;
          continue;
        }
        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
          if (this.buffer[this.pos] === CR) {
            this.crlfCheck = true;
          }
          this.parseLine(this.buffer.subarray(0, this.pos), this.event);
          this.buffer = this.buffer.subarray(this.pos + 1);
          this.pos = 0;
          this.eventEndCheck = true;
          continue;
        }
        this.pos++;
      }
      callback();
    }
    /**
     * @param {Buffer} line
     * @param {EventStreamEvent} event
     */
    parseLine(line, event) {
      if (line.length === 0) {
        return;
      }
      const colonPosition = line.indexOf(COLON);
      if (colonPosition === 0) {
        return;
      }
      let field = "";
      let value = "";
      if (colonPosition !== -1) {
        field = line.subarray(0, colonPosition).toString("utf8");
        let valueStart = colonPosition + 1;
        if (line[valueStart] === SPACE) {
          ++valueStart;
        }
        value = line.subarray(valueStart).toString("utf8");
      } else {
        field = line.toString("utf8");
        value = "";
      }
      switch (field) {
        case "data":
          if (event[field] === void 0) {
            event[field] = value;
          } else {
            event[field] += `
${value}`;
          }
          break;
        case "retry":
          if (isASCIINumber(value)) {
            event[field] = value;
          }
          break;
        case "id":
          if (isValidLastEventId(value)) {
            event[field] = value;
          }
          break;
        case "event":
          if (value.length > 0) {
            event[field] = value;
          }
          break;
      }
    }
    /**
     * @param {EventSourceStreamEvent} event
     */
    processEvent(event) {
      if (event.retry && isASCIINumber(event.retry)) {
        this.state.reconnectionTime = parseInt(event.retry, 10);
      }
      if (event.id && isValidLastEventId(event.id)) {
        this.state.lastEventId = event.id;
      }
      if (event.data !== void 0) {
        this.push({
          type: event.event || "message",
          options: {
            data: event.data,
            lastEventId: this.state.lastEventId,
            origin: this.state.origin
          }
        });
      }
    }
    clearEvent() {
      this.event = {
        data: void 0,
        event: void 0,
        id: void 0,
        retry: void 0
      };
    }
  }
  eventsourceStream = {
    EventSourceStream
  };
  return eventsourceStream;
}
var eventsource;
var hasRequiredEventsource;
function requireEventsource() {
  if (hasRequiredEventsource) return eventsource;
  hasRequiredEventsource = 1;
  const { pipeline } = require$$0$4;
  const { fetching } = requireFetch();
  const { makeRequest: makeRequest2 } = requireRequest();
  const { webidl } = requireWebidl();
  const { EventSourceStream } = requireEventsourceStream();
  const { parseMIMEType } = requireDataUrl();
  const { createFastMessageEvent } = requireEvents();
  const { isNetworkError } = requireResponse();
  const { delay } = requireUtil();
  const { kEnumerableProperty } = requireUtil$7();
  const { environmentSettingsObject } = requireUtil$6();
  let experimentalWarned = false;
  const defaultReconnectionTime = 3e3;
  const CONNECTING = 0;
  const OPEN = 1;
  const CLOSED = 2;
  const ANONYMOUS = "anonymous";
  const USE_CREDENTIALS = "use-credentials";
  class EventSource extends EventTarget {
    #events = {
      open: null,
      error: null,
      message: null
    };
    #url = null;
    #withCredentials = false;
    #readyState = CONNECTING;
    #request = null;
    #controller = null;
    #dispatcher;
    /**
     * @type {import('./eventsource-stream').eventSourceSettings}
     */
    #state;
    /**
     * Creates a new EventSource object.
     * @param {string} url
     * @param {EventSourceInit} [eventSourceInitDict]
     * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface
     */
    constructor(url, eventSourceInitDict = {}) {
      super();
      const prefix = "EventSource constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      if (!experimentalWarned) {
        experimentalWarned = true;
        process.emitWarning("EventSource is experimental, expect them to change at any time.", {
          code: "UNDICI-ES"
        });
      }
      url = webidl.converters.USVString(url, prefix, "url");
      eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, "eventSourceInitDict");
      this.#dispatcher = eventSourceInitDict.dispatcher;
      this.#state = {
        lastEventId: "",
        reconnectionTime: defaultReconnectionTime
      };
      const settings = environmentSettingsObject;
      let urlRecord;
      try {
        urlRecord = new URL(url, settings.settingsObject.baseUrl);
        this.#state.origin = urlRecord.origin;
      } catch (e) {
        throw new DOMException(e, "SyntaxError");
      }
      this.#url = urlRecord.href;
      let corsAttributeState = ANONYMOUS;
      if (eventSourceInitDict.withCredentials) {
        corsAttributeState = USE_CREDENTIALS;
        this.#withCredentials = true;
      }
      const initRequest = {
        redirect: "follow",
        keepalive: true,
        // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes
        mode: "cors",
        credentials: corsAttributeState === "anonymous" ? "same-origin" : "omit",
        referrer: "no-referrer"
      };
      initRequest.client = environmentSettingsObject.settingsObject;
      initRequest.headersList = [["accept", { name: "accept", value: "text/event-stream" }]];
      initRequest.cache = "no-store";
      initRequest.initiator = "other";
      initRequest.urlList = [new URL(this.#url)];
      this.#request = makeRequest2(initRequest);
      this.#connect();
    }
    /**
     * Returns the state of this EventSource object's connection. It can have the
     * values described below.
     * @returns {0|1|2}
     * @readonly
     */
    get readyState() {
      return this.#readyState;
    }
    /**
     * Returns the URL providing the event stream.
     * @readonly
     * @returns {string}
     */
    get url() {
      return this.#url;
    }
    /**
     * Returns a boolean indicating whether the EventSource object was
     * instantiated with CORS credentials set (true), or not (false, the default).
     */
    get withCredentials() {
      return this.#withCredentials;
    }
    #connect() {
      if (this.#readyState === CLOSED) return;
      this.#readyState = CONNECTING;
      const fetchParams = {
        request: this.#request,
        dispatcher: this.#dispatcher
      };
      const processEventSourceEndOfBody = (response2) => {
        if (isNetworkError(response2)) {
          this.dispatchEvent(new Event("error"));
          this.close();
        }
        this.#reconnect();
      };
      fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;
      fetchParams.processResponse = (response2) => {
        if (isNetworkError(response2)) {
          if (response2.aborted) {
            this.close();
            this.dispatchEvent(new Event("error"));
            return;
          } else {
            this.#reconnect();
            return;
          }
        }
        const contentType = response2.headersList.get("content-type", true);
        const mimeType = contentType !== null ? parseMIMEType(contentType) : "failure";
        const contentTypeValid = mimeType !== "failure" && mimeType.essence === "text/event-stream";
        if (response2.status !== 200 || contentTypeValid === false) {
          this.close();
          this.dispatchEvent(new Event("error"));
          return;
        }
        this.#readyState = OPEN;
        this.dispatchEvent(new Event("open"));
        this.#state.origin = response2.urlList[response2.urlList.length - 1].origin;
        const eventSourceStream = new EventSourceStream({
          eventSourceSettings: this.#state,
          push: (event) => {
            this.dispatchEvent(createFastMessageEvent(
              event.type,
              event.options
            ));
          }
        });
        pipeline(
          response2.body.stream,
          eventSourceStream,
          (error) => {
            if (error?.aborted === false) {
              this.close();
              this.dispatchEvent(new Event("error"));
            }
          }
        );
      };
      this.#controller = fetching(fetchParams);
    }
    /**
     * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model
     * @returns {Promise<void>}
     */
    async #reconnect() {
      if (this.#readyState === CLOSED) return;
      this.#readyState = CONNECTING;
      this.dispatchEvent(new Event("error"));
      await delay(this.#state.reconnectionTime);
      if (this.#readyState !== CONNECTING) return;
      if (this.#state.lastEventId.length) {
        this.#request.headersList.set("last-event-id", this.#state.lastEventId, true);
      }
      this.#connect();
    }
    /**
     * Closes the connection, if any, and sets the readyState attribute to
     * CLOSED.
     */
    close() {
      webidl.brandCheck(this, EventSource);
      if (this.#readyState === CLOSED) return;
      this.#readyState = CLOSED;
      this.#controller.abort();
      this.#request = null;
    }
    get onopen() {
      return this.#events.open;
    }
    set onopen(fn) {
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      if (typeof fn === "function") {
        this.#events.open = fn;
        this.addEventListener("open", fn);
      } else {
        this.#events.open = null;
      }
    }
    get onmessage() {
      return this.#events.message;
    }
    set onmessage(fn) {
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      if (typeof fn === "function") {
        this.#events.message = fn;
        this.addEventListener("message", fn);
      } else {
        this.#events.message = null;
      }
    }
    get onerror() {
      return this.#events.error;
    }
    set onerror(fn) {
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      if (typeof fn === "function") {
        this.#events.error = fn;
        this.addEventListener("error", fn);
      } else {
        this.#events.error = null;
      }
    }
  }
  const constantsPropertyDescriptors = {
    CONNECTING: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: CONNECTING,
      writable: false
    },
    OPEN: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: OPEN,
      writable: false
    },
    CLOSED: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: CLOSED,
      writable: false
    }
  };
  Object.defineProperties(EventSource, constantsPropertyDescriptors);
  Object.defineProperties(EventSource.prototype, constantsPropertyDescriptors);
  Object.defineProperties(EventSource.prototype, {
    close: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    onopen: kEnumerableProperty,
    readyState: kEnumerableProperty,
    url: kEnumerableProperty,
    withCredentials: kEnumerableProperty
  });
  webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([
    {
      key: "withCredentials",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "dispatcher",
      // undici only
      converter: webidl.converters.any
    }
  ]);
  eventsource = {
    EventSource,
    defaultReconnectionTime
  };
  return eventsource;
}
var hasRequiredUndici;
function requireUndici() {
  if (hasRequiredUndici) return undici;
  hasRequiredUndici = 1;
  const Client2 = requireClient();
  const Dispatcher = requireDispatcher();
  const Pool = requirePool();
  const BalancedPool = requireBalancedPool();
  const Agent = requireAgent();
  const ProxyAgent = requireProxyAgent();
  const EnvHttpProxyAgent = requireEnvHttpProxyAgent();
  const RetryAgent = requireRetryAgent();
  const errors2 = requireErrors();
  const util2 = requireUtil$7();
  const { InvalidArgumentError } = errors2;
  const api2 = requireApi();
  const buildConnector = requireConnect();
  const MockClient = requireMockClient();
  const MockAgent = requireMockAgent();
  const MockPool = requireMockPool();
  const mockErrors2 = requireMockErrors();
  const RetryHandler = requireRetryHandler();
  const { getGlobalDispatcher, setGlobalDispatcher } = requireGlobal();
  const DecoratorHandler = requireDecoratorHandler();
  const RedirectHandler = requireRedirectHandler();
  const createRedirectInterceptor = requireRedirectInterceptor();
  Object.assign(Dispatcher.prototype, api2);
  undici.Dispatcher = Dispatcher;
  undici.Client = Client2;
  undici.Pool = Pool;
  undici.BalancedPool = BalancedPool;
  undici.Agent = Agent;
  undici.ProxyAgent = ProxyAgent;
  undici.EnvHttpProxyAgent = EnvHttpProxyAgent;
  undici.RetryAgent = RetryAgent;
  undici.RetryHandler = RetryHandler;
  undici.DecoratorHandler = DecoratorHandler;
  undici.RedirectHandler = RedirectHandler;
  undici.createRedirectInterceptor = createRedirectInterceptor;
  undici.interceptors = {
    redirect: requireRedirect(),
    retry: requireRetry(),
    dump: requireDump()
  };
  undici.buildConnector = buildConnector;
  undici.errors = errors2;
  undici.util = {
    parseHeaders: util2.parseHeaders,
    headerNameToString: util2.headerNameToString
  };
  function makeDispatcher(fn) {
    return (url, opts, handler2) => {
      if (typeof opts === "function") {
        handler2 = opts;
        opts = null;
      }
      if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
        throw new InvalidArgumentError("invalid url");
      }
      if (opts != null && typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (opts && opts.path != null) {
        if (typeof opts.path !== "string") {
          throw new InvalidArgumentError("invalid opts.path");
        }
        let path2 = opts.path;
        if (!opts.path.startsWith("/")) {
          path2 = `/${path2}`;
        }
        url = new URL(util2.parseOrigin(url).origin + path2);
      } else {
        if (!opts) {
          opts = typeof url === "object" ? url : {};
        }
        url = util2.parseURL(url);
      }
      const { agent: agent2, dispatcher: dispatcher2 = getGlobalDispatcher() } = opts;
      if (agent2) {
        throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
      }
      return fn.call(dispatcher2, {
        ...opts,
        origin: url.origin,
        path: url.search ? `${url.pathname}${url.search}` : url.pathname,
        method: opts.method || (opts.body ? "PUT" : "GET")
      }, handler2);
    };
  }
  undici.setGlobalDispatcher = setGlobalDispatcher;
  undici.getGlobalDispatcher = getGlobalDispatcher;
  const fetchImpl = requireFetch().fetch;
  undici.fetch = async function fetch2(init, options = void 0) {
    try {
      return await fetchImpl(init, options);
    } catch (err) {
      if (err && typeof err === "object") {
        Error.captureStackTrace(err);
      }
      throw err;
    }
  };
  undici.Headers = requireHeaders().Headers;
  undici.Response = requireResponse().Response;
  undici.Request = requireRequest().Request;
  undici.FormData = requireFormdata().FormData;
  undici.File = globalThis.File ?? require$$0$2.File;
  undici.FileReader = requireFilereader().FileReader;
  const { setGlobalOrigin, getGlobalOrigin } = requireGlobal$1();
  undici.setGlobalOrigin = setGlobalOrigin;
  undici.getGlobalOrigin = getGlobalOrigin;
  const { CacheStorage } = requireCachestorage();
  const { kConstruct } = requireSymbols$1();
  undici.caches = new CacheStorage(kConstruct);
  const { deleteCookie, getCookies, getSetCookies, setCookie } = requireCookies();
  undici.deleteCookie = deleteCookie;
  undici.getCookies = getCookies;
  undici.getSetCookies = getSetCookies;
  undici.setCookie = setCookie;
  const { parseMIMEType, serializeAMimeType } = requireDataUrl();
  undici.parseMIMEType = parseMIMEType;
  undici.serializeAMimeType = serializeAMimeType;
  const { CloseEvent, ErrorEvent, MessageEvent } = requireEvents();
  undici.WebSocket = requireWebsocket().WebSocket;
  undici.CloseEvent = CloseEvent;
  undici.ErrorEvent = ErrorEvent;
  undici.MessageEvent = MessageEvent;
  undici.request = makeDispatcher(api2.request);
  undici.stream = makeDispatcher(api2.stream);
  undici.pipeline = makeDispatcher(api2.pipeline);
  undici.connect = makeDispatcher(api2.connect);
  undici.upgrade = makeDispatcher(api2.upgrade);
  undici.MockClient = MockClient;
  undici.MockPool = MockPool;
  undici.MockAgent = MockAgent;
  undici.mockErrors = mockErrors2;
  const { EventSource } = requireEventsource();
  undici.EventSource = EventSource;
  return undici;
}
var undiciExports = requireUndici();
const LOCAL_QUEUE_MAX_VISIBILITY = parseInt(process.env.WORKFLOW_LOCAL_QUEUE_MAX_VISIBILITY ?? "0", 10) || Infinity;
const DEFAULT_CONCURRENCY_LIMIT = 20;
const WORKFLOW_LOCAL_QUEUE_CONCURRENCY = parseInt(process.env.WORKFLOW_LOCAL_QUEUE_CONCURRENCY ?? "0", 10) || DEFAULT_CONCURRENCY_LIMIT;
const httpAgent = new undiciExports.Agent({
  headersTimeout: 0
});
function createQueue$1(config2) {
  const transport = new JsonTransport();
  const generateId = monotonicFactory();
  const semaphore = new libExports.Sema(WORKFLOW_LOCAL_QUEUE_CONCURRENCY);
  const inflightMessages = /* @__PURE__ */ new Map();
  const queue = async (queueName, message, opts) => {
    const cleanup = [];
    if (opts?.idempotencyKey) {
      const existing = inflightMessages.get(opts.idempotencyKey);
      if (existing) {
        return { messageId: existing };
      }
    }
    const body2 = transport.serialize(message);
    let pathname;
    if (queueName.startsWith("__wkf_step_")) {
      pathname = `step`;
    } else if (queueName.startsWith("__wkf_workflow_")) {
      pathname = `flow`;
    } else {
      throw new Error("Unknown queue name prefix");
    }
    const messageId = MessageId.parse(`msg_${generateId()}`);
    if (opts?.idempotencyKey) {
      const key = opts.idempotencyKey;
      inflightMessages.set(key, messageId);
      cleanup.push(() => {
        inflightMessages.delete(key);
      });
    }
    (async () => {
      const token = semaphore.tryAcquire();
      if (!token) {
        console.warn(`[world-local]: concurrency limit (${WORKFLOW_LOCAL_QUEUE_CONCURRENCY}) reached, waiting for queue to free up`);
        await semaphore.acquire();
      }
      try {
        let defaultRetriesLeft = 3;
        const baseUrl = await resolveBaseUrl(config2);
        for (let attempt = 0; defaultRetriesLeft > 0; attempt++) {
          defaultRetriesLeft--;
          const response2 = await fetch(`${baseUrl}/.well-known/workflow/v1/${pathname}`, {
            method: "POST",
            duplex: "half",
            // @ts-expect-error undici type differences
            dispatcher: httpAgent,
            headers: {
              "content-type": "application/json",
              "x-vqs-queue-name": queueName,
              "x-vqs-message-id": messageId,
              "x-vqs-message-attempt": String(attempt + 1)
            },
            body: body2
          });
          if (response2.ok) {
            return;
          }
          const text = await response2.text();
          if (response2.status === 503) {
            try {
              const timeoutSeconds = Number(JSON.parse(text).timeoutSeconds);
              await setTimeout$1(timeoutSeconds * 1e3);
              defaultRetriesLeft++;
              continue;
            } catch {
            }
          }
          console.error(`[local world] Failed to queue message`, {
            queueName,
            text,
            status: response2.status,
            headers: Object.fromEntries(response2.headers.entries()),
            body: body2.toString()
          });
        }
        console.error(`[local world] Reached max retries of local world queue implementation`);
      } finally {
        semaphore.release();
      }
    })().catch((err) => {
      const isAbortError = err?.name === "AbortError" || err?.name === "ResponseAborted";
      if (!isAbortError) {
        console.error("[local world] Queue operation failed:", err);
      }
    }).finally(() => {
      for (const fn of cleanup) {
        fn();
      }
    });
    return { messageId };
  };
  const HeaderParser = z__default.object({
    "x-vqs-queue-name": ValidQueueName,
    "x-vqs-message-id": MessageId,
    "x-vqs-message-attempt": z__default.coerce.number()
  });
  const createQueueHandler = (prefix, handler2) => {
    return async (req) => {
      const headers2 = HeaderParser.safeParse(Object.fromEntries(req.headers));
      if (!headers2.success || !req.body) {
        return Response.json({
          error: !req.body ? "Missing request body" : "Missing required headers"
        }, { status: 400 });
      }
      const queueName = headers2.data["x-vqs-queue-name"];
      const messageId = headers2.data["x-vqs-message-id"];
      const attempt = headers2.data["x-vqs-message-attempt"];
      if (!queueName.startsWith(prefix)) {
        return Response.json({ error: "Unhandled queue" }, { status: 400 });
      }
      const body2 = await new JsonTransport().deserialize(req.body);
      try {
        const result = await handler2(body2, { attempt, queueName, messageId });
        let timeoutSeconds = null;
        if (typeof result?.timeoutSeconds === "number") {
          timeoutSeconds = Math.min(result.timeoutSeconds, LOCAL_QUEUE_MAX_VISIBILITY);
        }
        if (timeoutSeconds) {
          return Response.json({ timeoutSeconds }, { status: 503 });
        }
        return Response.json({ ok: true });
      } catch (error) {
        return Response.json(String(error), { status: 500 });
      }
    };
  };
  const getDeploymentId = async () => {
    return "dpl_local";
  };
  return { queue, createQueueHandler, getDeploymentId };
}
const ulid = monotonicFactory(() => Math.random());
const Ulid = z$1.string().ulid();
function ulidToDate(maybeUlid) {
  const ulid2 = Ulid.safeParse(maybeUlid);
  if (!ulid2.success) {
    return null;
  }
  return new Date(decodeTime(ulid2.data));
}
async function ensureDir(dirPath) {
  try {
    await promises.mkdir(dirPath, { recursive: true });
  } catch (_error) {
  }
}
async function writeJSON(filePath, data, opts) {
  return write(filePath, JSON.stringify(data, null, 2), opts);
}
async function write(filePath, data, opts) {
  if (!opts?.overwrite) {
    try {
      await promises.access(filePath);
      throw new WorkflowAPIError(`File ${filePath} already exists and 'overwrite' is false`, { status: 409 });
    } catch (error) {
      if (error.code !== "ENOENT") {
        throw error;
      }
    }
  }
  const tempPath = `${filePath}.tmp.${ulid()}`;
  let tempFileCreated = false;
  try {
    await ensureDir(path.dirname(filePath));
    await promises.writeFile(tempPath, data);
    tempFileCreated = true;
    await promises.rename(tempPath, filePath);
  } catch (error) {
    if (tempFileCreated) {
      await promises.unlink(tempPath).catch(() => {
      });
    }
    throw error;
  }
}
async function readJSON(filePath, decoder) {
  try {
    const content = await promises.readFile(filePath, "utf-8");
    return decoder.parse(JSON.parse(content));
  } catch (error) {
    if (error.code === "ENOENT")
      return null;
    throw error;
  }
}
async function readBuffer(filePath) {
  const content = await promises.readFile(filePath);
  return content;
}
async function deleteJSON(filePath) {
  try {
    await promises.unlink(filePath);
  } catch (error) {
    if (error.code !== "ENOENT")
      throw error;
  }
}
async function listJSONFiles(dirPath) {
  try {
    const files = await promises.readdir(dirPath);
    return files.filter((f) => f.endsWith(".json")).map((f) => f.replace(".json", ""));
  } catch (error) {
    if (error.code === "ENOENT")
      return [];
    throw error;
  }
}
function parseCursor(cursor) {
  if (!cursor)
    return null;
  const parts = cursor.split("|");
  return {
    timestamp: new Date(parts[0]),
    id: parts[1] || null
  };
}
function createCursor(timestamp, id) {
  return id ? `${timestamp.toISOString()}|${id}` : timestamp.toISOString();
}
async function paginatedFileSystemQuery(config2) {
  const { directory, schema, filePrefix, filter, sortOrder = "desc", limit = 20, cursor, getCreatedAt, getId } = config2;
  const fileIds = await listJSONFiles(directory);
  const relevantFileIds = filePrefix ? fileIds.filter((fileId) => fileId.startsWith(filePrefix)) : fileIds;
  const parsedCursor = parseCursor(cursor);
  let candidateFileIds = relevantFileIds;
  if (parsedCursor) {
    candidateFileIds = relevantFileIds.filter((fileId) => {
      const filenameDate = getCreatedAt(`${fileId}.json`);
      if (filenameDate) {
        const cursorTime = parsedCursor.timestamp.getTime();
        const fileTime = filenameDate.getTime();
        if (parsedCursor.id) {
          return sortOrder === "desc" ? fileTime <= cursorTime : fileTime >= cursorTime;
        } else {
          return sortOrder === "desc" ? fileTime < cursorTime : fileTime > cursorTime;
        }
      }
      return false;
    });
  } else {
    candidateFileIds = relevantFileIds.filter((fileId) => {
      return getCreatedAt(`${fileId}.json`) !== null;
    });
  }
  const validItems = [];
  for (const fileId of candidateFileIds) {
    const filePath = path.join(directory, `${fileId}.json`);
    const item = await readJSON(filePath, schema);
    if (item) {
      if (filter && !filter(item))
        continue;
      if (parsedCursor) {
        const itemTime = item.createdAt.getTime();
        const cursorTime = parsedCursor.timestamp.getTime();
        if (sortOrder === "desc") {
          if (itemTime > cursorTime)
            continue;
          if (itemTime === cursorTime && parsedCursor.id && getId) {
            const itemId = getId(item);
            if (itemId >= parsedCursor.id)
              continue;
          }
        } else {
          if (itemTime < cursorTime)
            continue;
          if (itemTime === cursorTime && parsedCursor.id && getId) {
            const itemId = getId(item);
            if (itemId <= parsedCursor.id)
              continue;
          }
        }
      }
      validItems.push(item);
    }
  }
  validItems.sort((a, b) => {
    const aTime = a.createdAt.getTime();
    const bTime = b.createdAt.getTime();
    const timeComparison = sortOrder === "asc" ? aTime - bTime : bTime - aTime;
    if (timeComparison === 0 && getId) {
      const aId = getId(a);
      const bId = getId(b);
      return sortOrder === "asc" ? aId.localeCompare(bId) : bId.localeCompare(aId);
    }
    return timeComparison;
  });
  const hasMore = validItems.length > limit;
  const items = hasMore ? validItems.slice(0, limit) : validItems;
  const nextCursor = items.length > 0 ? createCursor(items[items.length - 1].createdAt, getId?.(items[items.length - 1])) : null;
  return {
    data: items,
    cursor: nextCursor,
    hasMore
  };
}
const monotonicUlid$1 = monotonicFactory(() => Math.random());
function filterRunData$1(run, resolveData) {
  if (resolveData === "none") {
    return {
      ...run,
      input: [],
      output: void 0
    };
  }
  return run;
}
function filterStepData$1(step, resolveData) {
  if (resolveData === "none") {
    return {
      ...step,
      input: [],
      output: void 0
    };
  }
  return step;
}
function filterEventData$1(event, resolveData) {
  if (resolveData === "none") {
    const { eventData: _eventData, ...rest } = event;
    return rest;
  }
  return event;
}
function filterHookData$1(hook, resolveData) {
  if (resolveData === "none") {
    const { metadata: _metadata, ...rest } = hook;
    return rest;
  }
  return hook;
}
const getObjectCreatedAt = (idPrefix) => (filename) => {
  const replaceRegex = new RegExp(`^${idPrefix}_`, "g");
  const dashIndex = filename.indexOf("-");
  if (dashIndex === -1) {
    const ulid3 = filename.replace(/\.json$/, "").replace(replaceRegex, "");
    return ulidToDate(ulid3);
  }
  if (idPrefix === "step") {
    const runId = filename.substring(0, dashIndex);
    const ulid3 = runId.replace(/^wrun_/, "");
    return ulidToDate(ulid3);
  }
  const id = filename.substring(dashIndex + 1).replace(/\.json$/, "");
  const ulid2 = id.replace(replaceRegex, "");
  return ulidToDate(ulid2);
};
function createHooksStorage(basedir) {
  async function findHookByToken(token) {
    const hooksDir = path.join(basedir, "hooks");
    const files = await listJSONFiles(hooksDir);
    for (const file2 of files) {
      const hookPath = path.join(hooksDir, `${file2}.json`);
      const hook = await readJSON(hookPath, HookSchema);
      if (hook && hook.token === token) {
        return hook;
      }
    }
    return null;
  }
  async function create(runId, data) {
    const existingHook = await findHookByToken(data.token);
    if (existingHook) {
      throw new Error(`Hook with token ${data.token} already exists for this project`);
    }
    const now = /* @__PURE__ */ new Date();
    const result = {
      runId,
      hookId: data.hookId,
      token: data.token,
      metadata: data.metadata,
      ownerId: "local-owner",
      projectId: "local-project",
      environment: "local",
      createdAt: now
    };
    const hookPath = path.join(basedir, "hooks", `${data.hookId}.json`);
    await writeJSON(hookPath, result);
    return result;
  }
  async function get(hookId, params) {
    const hookPath = path.join(basedir, "hooks", `${hookId}.json`);
    const hook = await readJSON(hookPath, HookSchema);
    if (!hook) {
      throw new Error(`Hook ${hookId} not found`);
    }
    const resolveData = params?.resolveData || DEFAULT_RESOLVE_DATA_OPTION$1;
    return filterHookData$1(hook, resolveData);
  }
  async function getByToken(token) {
    const hook = await findHookByToken(token);
    if (!hook) {
      throw new Error(`Hook with token ${token} not found`);
    }
    return hook;
  }
  async function list(params) {
    const hooksDir = path.join(basedir, "hooks");
    const resolveData = params.resolveData || DEFAULT_RESOLVE_DATA_OPTION$1;
    const result = await paginatedFileSystemQuery({
      directory: hooksDir,
      schema: HookSchema,
      sortOrder: params.pagination?.sortOrder,
      limit: params.pagination?.limit,
      cursor: params.pagination?.cursor,
      filePrefix: void 0,
      // Hooks don't have ULIDs, so we can't optimize by filename
      filter: (hook) => {
        if (params.runId && hook.runId !== params.runId) {
          return false;
        }
        return true;
      },
      getCreatedAt: () => {
        return /* @__PURE__ */ new Date(0);
      },
      getId: (hook) => hook.hookId
    });
    return {
      ...result,
      data: result.data.map((hook) => filterHookData$1(hook, resolveData))
    };
  }
  async function dispose(hookId) {
    const hookPath = path.join(basedir, "hooks", `${hookId}.json`);
    const hook = await readJSON(hookPath, HookSchema);
    if (!hook) {
      throw new Error(`Hook ${hookId} not found`);
    }
    await deleteJSON(hookPath);
    return hook;
  }
  return { create, get, getByToken, list, dispose };
}
async function deleteAllHooksForRun(basedir, runId) {
  const hooksDir = path.join(basedir, "hooks");
  const files = await listJSONFiles(hooksDir);
  for (const file2 of files) {
    const hookPath = path.join(hooksDir, `${file2}.json`);
    const hook = await readJSON(hookPath, HookSchema);
    if (hook && hook.runId === runId) {
      await deleteJSON(hookPath);
    }
  }
}
function createStorage$1(basedir) {
  return {
    runs: {
      async create(data) {
        const runId = `wrun_${monotonicUlid$1()}`;
        const now = /* @__PURE__ */ new Date();
        const result = {
          runId,
          deploymentId: data.deploymentId,
          status: "pending",
          workflowName: data.workflowName,
          executionContext: data.executionContext,
          input: data.input || [],
          output: void 0,
          error: void 0,
          startedAt: void 0,
          completedAt: void 0,
          createdAt: now,
          updatedAt: now
        };
        const runPath = path.join(basedir, "runs", `${runId}.json`);
        await writeJSON(runPath, result);
        return result;
      },
      async get(id, params) {
        const runPath = path.join(basedir, "runs", `${id}.json`);
        const run = await readJSON(runPath, WorkflowRunSchema);
        if (!run) {
          throw new WorkflowRunNotFoundError(id);
        }
        const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION$1;
        return filterRunData$1(run, resolveData);
      },
      /**
       * Updates a workflow run.
       *
       * Note: This operation is not atomic. Concurrent updates from multiple
       * processes may result in lost updates (last writer wins). This is an
       * inherent limitation of filesystem-based storage without locking.
       * For the local world, this is acceptable as it's typically
       * used in single-process scenarios.
       */
      async update(id, data) {
        const runPath = path.join(basedir, "runs", `${id}.json`);
        const run = await readJSON(runPath, WorkflowRunSchema);
        if (!run) {
          throw new WorkflowRunNotFoundError(id);
        }
        const now = /* @__PURE__ */ new Date();
        const updatedRun = {
          ...run,
          ...data,
          updatedAt: now
        };
        if (data.status === "running" && !updatedRun.startedAt) {
          updatedRun.startedAt = now;
        }
        const isBecomingTerminal = data.status === "completed" || data.status === "failed" || data.status === "cancelled";
        if (isBecomingTerminal) {
          updatedRun.completedAt = now;
        }
        await writeJSON(runPath, updatedRun, { overwrite: true });
        if (isBecomingTerminal) {
          await deleteAllHooksForRun(basedir, id);
        }
        return updatedRun;
      },
      async list(params) {
        const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION$1;
        const result = await paginatedFileSystemQuery({
          directory: path.join(basedir, "runs"),
          schema: WorkflowRunSchema,
          filter: (run) => {
            if (params?.workflowName && run.workflowName !== params.workflowName) {
              return false;
            }
            if (params?.status && run.status !== params.status) {
              return false;
            }
            return true;
          },
          sortOrder: params?.pagination?.sortOrder ?? "desc",
          limit: params?.pagination?.limit,
          cursor: params?.pagination?.cursor,
          getCreatedAt: getObjectCreatedAt("wrun"),
          getId: (run) => run.runId
        });
        if (resolveData === "none") {
          return {
            ...result,
            data: result.data.map((run) => ({
              ...run,
              input: [],
              output: void 0
            }))
          };
        }
        return result;
      },
      async cancel(id, params) {
        const run = await this.update(id, { status: "cancelled" });
        const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION$1;
        return filterRunData$1(run, resolveData);
      },
      async pause(id, params) {
        const run = await this.update(id, { status: "paused" });
        const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION$1;
        return filterRunData$1(run, resolveData);
      },
      async resume(id, params) {
        const run = await this.update(id, { status: "running" });
        const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION$1;
        return filterRunData$1(run, resolveData);
      }
    },
    steps: {
      async create(runId, data) {
        const now = /* @__PURE__ */ new Date();
        const result = {
          runId,
          stepId: data.stepId,
          stepName: data.stepName,
          status: "pending",
          input: data.input,
          output: void 0,
          error: void 0,
          attempt: 0,
          startedAt: void 0,
          completedAt: void 0,
          createdAt: now,
          updatedAt: now
        };
        const compositeKey = `${runId}-${data.stepId}`;
        const stepPath = path.join(basedir, "steps", `${compositeKey}.json`);
        await writeJSON(stepPath, result);
        return result;
      },
      async get(runId, stepId, params) {
        if (!runId) {
          const fileIds = await listJSONFiles(path.join(basedir, "steps"));
          const fileId = fileIds.find((fileId2) => fileId2.endsWith(`-${stepId}`));
          if (!fileId) {
            throw new Error(`Step ${stepId} not found`);
          }
          runId = fileId.split("-")[0];
        }
        const compositeKey = `${runId}-${stepId}`;
        const stepPath = path.join(basedir, "steps", `${compositeKey}.json`);
        const step = await readJSON(stepPath, StepSchema);
        if (!step) {
          throw new Error(`Step ${stepId} in run ${runId} not found`);
        }
        const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION$1;
        return filterStepData$1(step, resolveData);
      },
      /**
       * Updates a step.
       *
       * Note: This operation is not atomic. Concurrent updates from multiple
       * processes may result in lost updates (last writer wins). This is an
       * inherent limitation of filesystem-based storage without locking.
       */
      async update(runId, stepId, data) {
        const compositeKey = `${runId}-${stepId}`;
        const stepPath = path.join(basedir, "steps", `${compositeKey}.json`);
        const step = await readJSON(stepPath, StepSchema);
        if (!step) {
          throw new Error(`Step ${stepId} in run ${runId} not found`);
        }
        const now = /* @__PURE__ */ new Date();
        const updatedStep = {
          ...step,
          ...data,
          updatedAt: now
        };
        if (data.status === "running" && !updatedStep.startedAt) {
          updatedStep.startedAt = now;
        }
        if (data.status === "completed" || data.status === "failed") {
          updatedStep.completedAt = now;
        }
        await writeJSON(stepPath, updatedStep, { overwrite: true });
        return updatedStep;
      },
      async list(params) {
        const resolveData = params.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION$1;
        const result = await paginatedFileSystemQuery({
          directory: path.join(basedir, "steps"),
          schema: StepSchema,
          filePrefix: `${params.runId}-`,
          sortOrder: params.pagination?.sortOrder ?? "desc",
          limit: params.pagination?.limit,
          cursor: params.pagination?.cursor,
          getCreatedAt: getObjectCreatedAt("step"),
          getId: (step) => step.stepId
        });
        if (resolveData === "none") {
          return {
            ...result,
            data: result.data.map((step) => ({
              ...step,
              input: [],
              output: void 0
            }))
          };
        }
        return result;
      }
    },
    // Events - filesystem-backed storage
    events: {
      async create(runId, data, params) {
        const eventId = `evnt_${monotonicUlid$1()}`;
        const now = /* @__PURE__ */ new Date();
        const result = {
          ...data,
          runId,
          eventId,
          createdAt: now
        };
        const compositeKey = `${runId}-${eventId}`;
        const eventPath = path.join(basedir, "events", `${compositeKey}.json`);
        await writeJSON(eventPath, result);
        const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION$1;
        return filterEventData$1(result, resolveData);
      },
      async list(params) {
        const { runId } = params;
        const resolveData = params.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION$1;
        const result = await paginatedFileSystemQuery({
          directory: path.join(basedir, "events"),
          schema: EventSchema,
          filePrefix: `${runId}-`,
          // Events in chronological order (oldest first) by default,
          // different from the default for other list calls.
          sortOrder: params.pagination?.sortOrder ?? "asc",
          limit: params.pagination?.limit,
          cursor: params.pagination?.cursor,
          getCreatedAt: getObjectCreatedAt("evnt"),
          getId: (event) => event.eventId
        });
        if (resolveData === "none") {
          return {
            ...result,
            data: result.data.map((event) => {
              const { eventData: _eventData, ...rest } = event;
              return rest;
            })
          };
        }
        return result;
      },
      async listByCorrelationId(params) {
        const correlationId = params.correlationId;
        const resolveData = params.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION$1;
        const result = await paginatedFileSystemQuery({
          directory: path.join(basedir, "events"),
          schema: EventSchema,
          // No filePrefix - search all events
          filter: (event) => event.correlationId === correlationId,
          // Events in chronological order (oldest first) by default,
          // different from the default for other list calls.
          sortOrder: params.pagination?.sortOrder ?? "asc",
          limit: params.pagination?.limit,
          cursor: params.pagination?.cursor,
          getCreatedAt: getObjectCreatedAt("evnt"),
          getId: (event) => event.eventId
        });
        if (resolveData === "none") {
          return {
            ...result,
            data: result.data.map((event) => {
              const { eventData: _eventData, ...rest } = event;
              return rest;
            })
          };
        }
        return result;
      }
    },
    // Hooks
    hooks: createHooksStorage(basedir)
  };
}
const monotonicUlid = monotonicFactory(() => Math.random());
function serializeChunk(chunk) {
  const eofByte = Buffer.from([chunk.eof ? 1 : 0]);
  return Buffer.concat([eofByte, chunk.chunk]);
}
function deserializeChunk(serialized) {
  const eof = serialized[0] === 1;
  const chunk = Buffer.from(serialized.subarray(1));
  return { eof, chunk };
}
function createStreamer$1(basedir) {
  const streamEmitter = new EventEmitter();
  return {
    async writeToStream(name, _runId, chunk) {
      await _runId;
      const chunkId = `strm_${monotonicUlid()}`;
      let chunkBuffer;
      if (typeof chunk === "string") {
        chunkBuffer = Buffer.from(new TextEncoder().encode(chunk));
      } else if (chunk instanceof Buffer) {
        chunkBuffer = chunk;
      } else {
        chunkBuffer = Buffer.from(chunk);
      }
      const serialized = serializeChunk({
        chunk: chunkBuffer,
        eof: false
      });
      const chunkPath = path.join(basedir, "streams", "chunks", `${name}-${chunkId}.json`);
      await write(chunkPath, serialized);
      const chunkData = Uint8Array.from(chunkBuffer);
      streamEmitter.emit(`chunk:${name}`, {
        streamName: name,
        chunkData,
        chunkId
      });
    },
    async closeStream(name, _runId) {
      await _runId;
      const chunkId = `strm_${monotonicUlid()}`;
      const chunkPath = path.join(basedir, "streams", "chunks", `${name}-${chunkId}.json`);
      await write(chunkPath, serializeChunk({ chunk: Buffer.from([]), eof: true }));
      streamEmitter.emit(`close:${name}`, { streamName: name });
    },
    async readFromStream(name, startIndex = 0) {
      const chunksDir = path.join(basedir, "streams", "chunks");
      let removeListeners = () => {
      };
      return new ReadableStream({
        async start(controller) {
          const deliveredChunkIds = /* @__PURE__ */ new Set();
          const bufferedEventChunks = [];
          let isReadingFromDisk = true;
          const chunkListener = (event) => {
            deliveredChunkIds.add(event.chunkId);
            if (event.chunkData.byteLength === 0) {
              return;
            }
            if (isReadingFromDisk) {
              bufferedEventChunks.push({
                chunkId: event.chunkId,
                chunkData: Uint8Array.from(event.chunkData)
              });
            } else {
              controller.enqueue(Uint8Array.from(event.chunkData));
            }
          };
          const closeListener = () => {
            streamEmitter.off(`chunk:${name}`, chunkListener);
            streamEmitter.off(`close:${name}`, closeListener);
            try {
              controller.close();
            } catch (e) {
            }
          };
          removeListeners = closeListener;
          streamEmitter.on(`chunk:${name}`, chunkListener);
          streamEmitter.on(`close:${name}`, closeListener);
          const files = await listJSONFiles(chunksDir);
          const chunkFiles = files.filter((file2) => file2.startsWith(`${name}-`)).sort();
          let isComplete = false;
          for (let i = startIndex; i < chunkFiles.length; i++) {
            const file2 = chunkFiles[i];
            const chunkId = file2.substring(name.length + 1);
            if (deliveredChunkIds.has(chunkId)) {
              continue;
            }
            const chunk = deserializeChunk(await readBuffer(path.join(chunksDir, `${file2}.json`)));
            if (chunk?.eof === true) {
              isComplete = true;
              break;
            }
            if (chunk.chunk.byteLength) {
              controller.enqueue(Uint8Array.from(chunk.chunk));
            }
          }
          isReadingFromDisk = false;
          bufferedEventChunks.sort((a, b) => a.chunkId.localeCompare(b.chunkId));
          for (const buffered of bufferedEventChunks) {
            controller.enqueue(Uint8Array.from(buffered.chunkData));
          }
          if (isComplete) {
            removeListeners();
            try {
              controller.close();
            } catch (e) {
            }
            return;
          }
        },
        cancel() {
          removeListeners();
        }
      });
    }
  };
}
function createLocalWorld(args) {
  const definedArgs = args ? Object.fromEntries(Object.entries(args).filter(([, value]) => value !== void 0)) : {};
  const mergedConfig = { ...config.value, ...definedArgs };
  return {
    ...createQueue$1(mergedConfig),
    ...createStorage$1(mergedConfig.dataDir),
    ...createStreamer$1(mergedConfig.dataDir)
  };
}
const version = "4.0.1-beta.16";
const DEFAULT_RESOLVE_DATA_OPTION = "all";
function dateToStringReplacer(_key, value) {
  if (value instanceof Date) {
    return value.toISOString();
  }
  return value;
}
function serializeError(data) {
  const { error, ...rest } = data;
  if (error !== void 0) {
    return {
      ...rest,
      error: JSON.stringify({
        message: error.message,
        stack: error.stack,
        code: error.code
      })
    };
  }
  return data;
}
function deserializeError(obj) {
  const { error, ...rest } = obj;
  if (!error) {
    return obj;
  }
  try {
    const parsed = StructuredErrorSchema.parse(JSON.parse(error));
    return {
      ...rest,
      error: {
        message: parsed.message,
        stack: parsed.stack,
        code: parsed.code
      }
    };
  } catch {
    return {
      ...rest,
      error: {
        message: error
      }
    };
  }
}
const getUserAgent = () => {
  return `@workflow/world-vercel/${version} node-${process.version} ${os.platform()} (${os.arch()})`;
};
const getHttpUrl = (config2) => {
  const projectConfig = config2?.projectConfig;
  const defaultUrl = "https://vercel-workflow.com/api";
  const defaultProxyUrl = "https://api.vercel.com/v1/workflow";
  const usingProxy = Boolean(config2?.baseUrl || projectConfig?.projectId && projectConfig?.teamId);
  const baseUrl = config2?.baseUrl || (usingProxy ? defaultProxyUrl : defaultUrl);
  return { baseUrl, usingProxy };
};
const getHeaders = (config2) => {
  const projectConfig = config2?.projectConfig;
  const headers2 = new Headers(config2?.headers);
  headers2.set("User-Agent", getUserAgent());
  if (projectConfig) {
    headers2.set("x-vercel-environment", projectConfig.environment || "production");
    if (projectConfig.projectId) {
      headers2.set("x-vercel-project-id", projectConfig.projectId);
    }
    if (projectConfig.teamId) {
      headers2.set("x-vercel-team-id", projectConfig.teamId);
    }
  }
  return headers2;
};
async function getHttpConfig(config2) {
  const headers2 = getHeaders(config2);
  const token = config2?.token ?? await distExports.getVercelOidcToken();
  if (token) {
    headers2.set("Authorization", `Bearer ${token}`);
  }
  const { baseUrl, usingProxy } = getHttpUrl(config2);
  return { baseUrl, headers: headers2, usingProxy };
}
async function makeRequest({ endpoint, options = {}, config: config2 = {}, schema }) {
  const { baseUrl, headers: headers2 } = await getHttpConfig(config2);
  headers2.set("Content-Type", "application/json");
  const url = `${baseUrl}${endpoint}`;
  const response2 = await fetch(url, {
    ...options,
    headers: headers2
  });
  if (!response2.ok) {
    const errorData = await response2.json().catch(() => ({}));
    if (process.env.DEBUG === "1") {
      const stringifiedHeaders = Array.from(headers2.entries()).map(([key, value]) => `-H "${key}: ${value}"`).join(" ");
      console.error(`Failed to fetch, reproduce with:
curl -X ${options.method} ${stringifiedHeaders} "${url}"`);
    }
    throw new WorkflowAPIError(errorData.message || `${options.method ?? "GET"} ${endpoint} -> HTTP ${response2.status}: ${response2.statusText}`, { url, status: response2.status, code: errorData.code });
  }
  try {
    const text = await response2.text();
    return schema.parse(JSON.parse(text));
  } catch (error) {
    if (error instanceof ZodError) {
      throw new WorkflowAPIError(`Failed to parse server response for ${options.method ?? "GET"} ${endpoint}: ${error.message}`, { url, cause: error });
    }
    throw new WorkflowAPIError(`Failed to parse server response for ${options.method ?? "GET"} ${endpoint}`, { url, cause: error });
  }
}
const MessageWrapper = z.object({
  payload: QueuePayloadSchema,
  queueName: ValidQueueName
});
const VERCEL_QUEUE_MAX_VISIBILITY = 39600;
function createQueue(config2) {
  const { baseUrl, usingProxy } = getHttpUrl(config2);
  const headers2 = getHeaders(config2);
  const queueClient = new Client({
    baseUrl: usingProxy ? baseUrl : void 0,
    basePath: usingProxy ? "/queues/v2/messages" : void 0,
    token: usingProxy ? config2?.token : void 0,
    headers: Object.fromEntries(headers2.entries())
  });
  const queue = async (queueName, x, opts) => {
    const hasEncoder = typeof MessageWrapper.encode === "function";
    if (!hasEncoder) {
      console.warn("Using zod v3 compatibility mode for queue() calls - this may not work as expected");
    }
    const encoder = hasEncoder ? MessageWrapper.encode : (data) => data;
    const encoded = encoder({
      payload: x,
      queueName
    });
    const sanitizedQueueName = queueName.replace(/[^A-Za-z0-9-_]/g, "-");
    const { messageId } = await queueClient.send(sanitizedQueueName, encoded, opts);
    return { messageId: MessageId.parse(messageId) };
  };
  const createQueueHandler = (prefix, handler2) => {
    return queueClient.handleCallback({
      [`${prefix}*`]: {
        default: async (body2, meta2) => {
          const { payload, queueName } = MessageWrapper.parse(body2);
          const result = await handler2(payload, {
            queueName,
            messageId: MessageId.parse(meta2.messageId),
            attempt: meta2.deliveryCount
          });
          if (typeof result?.timeoutSeconds === "number") {
            const adjustedTimeoutSeconds = Math.min(result.timeoutSeconds, VERCEL_QUEUE_MAX_VISIBILITY);
            if (adjustedTimeoutSeconds !== result.timeoutSeconds) {
              result.timeoutSeconds = adjustedTimeoutSeconds;
            }
          }
          return result;
        }
      }
    });
  };
  const getDeploymentId = async () => {
    const deploymentId = process.env.VERCEL_DEPLOYMENT_ID;
    if (!deploymentId) {
      throw new Error("VERCEL_DEPLOYMENT_ID environment variable is not set");
    }
    return deploymentId;
  };
  return { queue, createQueueHandler, getDeploymentId };
}
function filterEventData(event, resolveData) {
  if (resolveData === "none") {
    const { eventData: _eventData, ...rest } = event;
    return rest;
  }
  return event;
}
const EventWithRefsSchema = z__default.object({
  eventId: z__default.string(),
  runId: z__default.string(),
  eventType: EventTypeSchema,
  correlationId: z__default.string().optional(),
  eventDataRef: z__default.any().optional(),
  createdAt: z__default.coerce.date()
});
async function getWorkflowRunEvents(params, config2) {
  const searchParams = new URLSearchParams();
  const { pagination, resolveData = DEFAULT_RESOLVE_DATA_OPTION } = params;
  let runId;
  let correlationId;
  if ("runId" in params) {
    runId = params.runId;
  } else {
    correlationId = params.correlationId;
  }
  if (!runId && !correlationId) {
    throw new Error("Either runId or correlationId must be provided");
  }
  if (pagination?.limit)
    searchParams.set("limit", pagination.limit.toString());
  if (pagination?.cursor)
    searchParams.set("cursor", pagination.cursor);
  if (pagination?.sortOrder)
    searchParams.set("sortOrder", pagination.sortOrder);
  if (correlationId)
    searchParams.set("correlationId", correlationId);
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const query = queryString ? `?${queryString}` : "";
  const endpoint = correlationId ? `/v1/events${query}` : `/v1/runs/${runId}/events${query}`;
  const response2 = await makeRequest({
    endpoint,
    options: { method: "GET" },
    config: config2,
    schema: PaginatedResponseSchema(remoteRefBehavior === "lazy" ? EventWithRefsSchema : EventSchema)
  });
  return {
    ...response2,
    data: response2.data.map((event) => filterEventData(event, resolveData))
  };
}
async function createWorkflowRunEvent(id, data, params, config2) {
  const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
  const event = await makeRequest({
    endpoint: `/v1/runs/${id}/events`,
    options: {
      method: "POST",
      body: JSON.stringify(data, dateToStringReplacer)
    },
    config: config2,
    schema: EventSchema
  });
  return filterEventData(event, resolveData);
}
function filterHookData(hook, resolveData) {
  if (resolveData === "none") {
    const { metadataRef: _metadataRef, ...rest } = hook;
    return rest;
  }
  return hook;
}
const HookWithRefsSchema = HookSchema.omit({
  metadata: true
}).extend({
  metadataRef: z__default.any().optional()
});
async function listHooks(params, config2) {
  const { runId, pagination, resolveData = DEFAULT_RESOLVE_DATA_OPTION } = params;
  const searchParams = new URLSearchParams();
  if (pagination?.limit)
    searchParams.set("limit", pagination.limit.toString());
  if (pagination?.cursor)
    searchParams.set("cursor", pagination.cursor);
  if (pagination?.sortOrder)
    searchParams.set("sortOrder", pagination.sortOrder);
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  if (runId)
    searchParams.set("runId", runId);
  const queryString = searchParams.toString();
  const endpoint = `/v1/hooks${queryString ? `?${queryString}` : ""}`;
  const response2 = await makeRequest({
    endpoint,
    options: { method: "GET" },
    config: config2,
    schema: PaginatedResponseSchema(remoteRefBehavior === "lazy" ? HookWithRefsSchema : HookSchema)
  });
  return {
    ...response2,
    data: response2.data.map((hook) => filterHookData(hook, resolveData))
  };
}
async function getHook(hookId, params, config2) {
  const resolveData = params?.resolveData || "all";
  const endpoint = `/v1/hooks/${hookId}`;
  const hook = await makeRequest({
    endpoint,
    options: { method: "GET" },
    config: config2,
    schema: HookSchema
  });
  return filterHookData(hook, resolveData);
}
async function createHook(runId, data, config2) {
  return makeRequest({
    endpoint: `/v1/hooks/create`,
    options: {
      method: "POST",
      body: JSON.stringify({
        runId,
        ...data
      }, dateToStringReplacer)
    },
    config: config2,
    schema: HookSchema
  });
}
async function getHookByToken$1(token, config2) {
  return makeRequest({
    endpoint: `/v1/hooks/by-token?token=${encodeURIComponent(token)}`,
    options: {
      method: "GET"
    },
    config: config2,
    schema: HookSchema
  });
}
async function disposeHook(hookId, config2) {
  return makeRequest({
    endpoint: `/v1/hooks/${hookId}`,
    options: { method: "DELETE" },
    config: config2,
    schema: HookSchema
  });
}
const WorkflowRunWireBaseSchema = WorkflowRunBaseSchema.omit({
  error: true
}).extend({
  // Backend returns error as a JSON string, not an object
  error: z$1.string().optional()
});
const WorkflowRunWireSchema = WorkflowRunWireBaseSchema;
const WorkflowRunWireWithRefsSchema = WorkflowRunWireBaseSchema.omit({
  input: true,
  output: true
}).extend({
  // We discard the results of the refs, so we don't care about the type here
  inputRef: z$1.any().optional(),
  outputRef: z$1.any().optional(),
  input: z$1.array(z$1.any()).optional(),
  output: z$1.any().optional(),
  blobStorageBytes: z$1.number().optional(),
  streamStorageBytes: z$1.number().optional()
});
function filterRunData(run, resolveData) {
  if (resolveData === "none") {
    const { inputRef: _inputRef, outputRef: _outputRef, ...rest } = run;
    const deserialized = deserializeError(rest);
    return {
      ...deserialized,
      input: [],
      output: void 0
    };
  }
  return deserializeError(run);
}
async function listWorkflowRuns(params = {}, config2) {
  const { workflowName, status, pagination, resolveData = DEFAULT_RESOLVE_DATA_OPTION } = params;
  const searchParams = new URLSearchParams();
  if (workflowName)
    searchParams.set("workflowName", workflowName);
  if (status)
    searchParams.set("status", status);
  if (pagination?.limit)
    searchParams.set("limit", pagination.limit.toString());
  if (pagination?.cursor)
    searchParams.set("cursor", pagination.cursor);
  if (pagination?.sortOrder)
    searchParams.set("sortOrder", pagination.sortOrder);
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const endpoint = `/v1/runs${queryString ? `?${queryString}` : ""}`;
  const response2 = await makeRequest({
    endpoint,
    options: { method: "GET" },
    config: config2,
    schema: PaginatedResponseSchema(remoteRefBehavior === "lazy" ? WorkflowRunWireWithRefsSchema : WorkflowRunWireSchema)
  });
  return {
    ...response2,
    data: response2.data.map((run) => filterRunData(run, resolveData))
  };
}
async function createWorkflowRun(data, config2) {
  const run = await makeRequest({
    endpoint: "/v1/runs/create",
    options: {
      method: "POST",
      body: JSON.stringify(data, dateToStringReplacer)
    },
    config: config2,
    schema: WorkflowRunWireSchema
  });
  return deserializeError(run);
}
async function getWorkflowRun(id, params, config2) {
  const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  const searchParams = new URLSearchParams();
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const endpoint = `/v1/runs/${id}${queryString ? `?${queryString}` : ""}`;
  try {
    const run = await makeRequest({
      endpoint,
      options: { method: "GET" },
      config: config2,
      schema: remoteRefBehavior === "lazy" ? WorkflowRunWireWithRefsSchema : WorkflowRunWireSchema
    });
    return filterRunData(run, resolveData);
  } catch (error) {
    if (error instanceof WorkflowAPIError && error.status === 404) {
      throw new WorkflowRunNotFoundError(id);
    }
    throw error;
  }
}
async function updateWorkflowRun(id, data, config2) {
  try {
    const serialized = serializeError(data);
    const run = await makeRequest({
      endpoint: `/v1/runs/${id}`,
      options: {
        method: "PUT",
        body: JSON.stringify(serialized, dateToStringReplacer)
      },
      config: config2,
      schema: WorkflowRunWireSchema
    });
    return deserializeError(run);
  } catch (error) {
    if (error instanceof WorkflowAPIError && error.status === 404) {
      throw new WorkflowRunNotFoundError(id);
    }
    throw error;
  }
}
async function cancelWorkflowRun(id, params, config2) {
  const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  const searchParams = new URLSearchParams();
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const endpoint = `/v1/runs/${id}/cancel${queryString ? `?${queryString}` : ""}`;
  try {
    const run = await makeRequest({
      endpoint,
      options: { method: "PUT" },
      config: config2,
      schema: remoteRefBehavior === "lazy" ? WorkflowRunWireWithRefsSchema : WorkflowRunWireSchema
    });
    return filterRunData(run, resolveData);
  } catch (error) {
    if (error instanceof WorkflowAPIError && error.status === 404) {
      throw new WorkflowRunNotFoundError(id);
    }
    throw error;
  }
}
async function pauseWorkflowRun(id, params, config2) {
  const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  const searchParams = new URLSearchParams();
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const endpoint = `/v1/runs/${id}/pause${queryString ? `?${queryString}` : ""}`;
  try {
    const run = await makeRequest({
      endpoint,
      options: { method: "PUT" },
      config: config2,
      schema: remoteRefBehavior === "lazy" ? WorkflowRunWireWithRefsSchema : WorkflowRunWireSchema
    });
    return filterRunData(run, resolveData);
  } catch (error) {
    if (error instanceof WorkflowAPIError && error.status === 404) {
      throw new WorkflowRunNotFoundError(id);
    }
    throw error;
  }
}
async function resumeWorkflowRun(id, params, config2) {
  const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  const searchParams = new URLSearchParams();
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const endpoint = `/v1/runs/${id}/resume${queryString ? `?${queryString}` : ""}`;
  try {
    const run = await makeRequest({
      endpoint,
      options: { method: "PUT" },
      config: config2,
      schema: remoteRefBehavior === "lazy" ? WorkflowRunWireWithRefsSchema : WorkflowRunWireSchema
    });
    return filterRunData(run, resolveData);
  } catch (error) {
    if (error instanceof WorkflowAPIError && error.status === 404) {
      throw new WorkflowRunNotFoundError(id);
    }
    throw error;
  }
}
const StepWireSchema = StepSchema.omit({
  error: true
}).extend({
  // Backend returns error as a JSON string, not an object
  error: z$1.string().optional()
});
const StepWireWithRefsSchema = StepWireSchema.omit({
  input: true,
  output: true
}).extend({
  // We discard the results of the refs, so we don't care about the type here
  inputRef: z$1.any().optional(),
  outputRef: z$1.any().optional(),
  input: z$1.array(z$1.any()).optional(),
  output: z$1.any().optional()
});
function filterStepData(step, resolveData) {
  if (resolveData === "none") {
    const { inputRef: _inputRef, outputRef: _outputRef, ...rest } = step;
    const deserialized = deserializeError(rest);
    return {
      ...deserialized,
      input: [],
      output: void 0
    };
  }
  return deserializeError(step);
}
async function listWorkflowRunSteps(params, config2) {
  const { runId, pagination, resolveData = DEFAULT_RESOLVE_DATA_OPTION } = params;
  const searchParams = new URLSearchParams();
  if (pagination?.cursor)
    searchParams.set("cursor", pagination.cursor);
  if (pagination?.limit)
    searchParams.set("limit", pagination.limit.toString());
  if (pagination?.sortOrder)
    searchParams.set("sortOrder", pagination.sortOrder);
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const endpoint = `/v1/runs/${runId}/steps${queryString ? `?${queryString}` : ""}`;
  const response2 = await makeRequest({
    endpoint,
    options: { method: "GET" },
    config: config2,
    schema: PaginatedResponseSchema(remoteRefBehavior === "lazy" ? StepWireWithRefsSchema : StepWireSchema)
  });
  return {
    ...response2,
    data: response2.data.map((step) => filterStepData(step, resolveData))
  };
}
async function createStep(runId, data, config2) {
  const step = await makeRequest({
    endpoint: `/v1/runs/${runId}/steps`,
    options: {
      method: "POST",
      body: JSON.stringify(data, dateToStringReplacer)
    },
    config: config2,
    schema: StepWireSchema
  });
  return deserializeError(step);
}
async function updateStep(runId, stepId, data, config2) {
  const serialized = serializeError(data);
  const step = await makeRequest({
    endpoint: `/v1/runs/${runId}/steps/${stepId}`,
    options: {
      method: "PUT",
      body: JSON.stringify(serialized, dateToStringReplacer)
    },
    config: config2,
    schema: StepWireSchema
  });
  return deserializeError(step);
}
async function getStep(runId, stepId, params, config2) {
  const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  const searchParams = new URLSearchParams();
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const endpoint = runId ? `/v1/runs/${runId}/steps/${stepId}${queryString ? `?${queryString}` : ""}` : `/v1/steps/${stepId}${queryString ? `?${queryString}` : ""}`;
  const step = await makeRequest({
    endpoint,
    options: { method: "GET" },
    config: config2,
    schema: remoteRefBehavior === "lazy" ? StepWireWithRefsSchema : StepWireSchema
  });
  return filterStepData(step, resolveData);
}
function createStorage(config2) {
  return {
    // Storage interface with namespaced methods
    runs: {
      create: (data) => createWorkflowRun(data, config2),
      get: (id, params) => getWorkflowRun(id, params, config2),
      update: (id, data) => updateWorkflowRun(id, data, config2),
      list: (params) => listWorkflowRuns(params, config2),
      cancel: (id, params) => cancelWorkflowRun(id, params, config2),
      pause: (id, params) => pauseWorkflowRun(id, params, config2),
      resume: (id, params) => resumeWorkflowRun(id, params, config2)
    },
    steps: {
      create: (runId, data) => createStep(runId, data, config2),
      get: (runId, stepId, params) => getStep(runId, stepId, params, config2),
      update: (runId, stepId, data) => updateStep(runId, stepId, data, config2),
      list: (params) => listWorkflowRunSteps(params, config2)
    },
    events: {
      create: (runId, data, params) => createWorkflowRunEvent(runId, data, params, config2),
      list: (params) => getWorkflowRunEvents(params, config2),
      listByCorrelationId: (params) => getWorkflowRunEvents(params, config2)
    },
    hooks: {
      create: (runId, data) => createHook(runId, data, config2),
      get: (hookId, params) => getHook(hookId, params, config2),
      getByToken: (token) => getHookByToken$1(token, config2),
      list: (params) => listHooks(params, config2),
      dispose: (hookId) => disposeHook(hookId, config2)
    }
  };
}
function getStreamUrl(name, runId, httpConfig) {
  if (runId) {
    return new URL(`${httpConfig.baseUrl}/v1/runs/${runId}/stream/${encodeURIComponent(name)}`);
  }
  return new URL(`${httpConfig.baseUrl}/v1/stream/${encodeURIComponent(name)}`);
}
function createStreamer(config2) {
  return {
    async writeToStream(name, runId, chunk) {
      const resolvedRunId = await runId;
      const httpConfig = await getHttpConfig(config2);
      await fetch(getStreamUrl(name, resolvedRunId, httpConfig), {
        method: "PUT",
        body: chunk,
        headers: httpConfig.headers,
        duplex: "half"
      });
    },
    async closeStream(name, runId) {
      const resolvedRunId = await runId;
      const httpConfig = await getHttpConfig(config2);
      httpConfig.headers.set("X-Stream-Done", "true");
      await fetch(getStreamUrl(name, resolvedRunId, httpConfig), {
        method: "PUT",
        headers: httpConfig.headers
      });
    },
    async readFromStream(name, startIndex) {
      const httpConfig = await getHttpConfig(config2);
      const url = getStreamUrl(name, void 0, httpConfig);
      if (typeof startIndex === "number") {
        url.searchParams.set("startIndex", String(startIndex));
      }
      const res = await fetch(url, { headers: httpConfig.headers });
      if (!res.ok)
        throw new Error(`Failed to fetch stream: ${res.status}`);
      return res.body;
    }
  };
}
function createVercelWorld(config2) {
  return {
    ...createQueue(config2),
    ...createStorage(config2),
    ...createStreamer(config2)
  };
}
const require$1 = createRequire(join$1(process.cwd(), "index.js"));
const WorldCache = Symbol.for("@workflow/world//cache");
const StubbedWorldCache = Symbol.for("@workflow/world//stubbedCache");
const globalSymbols = globalThis;
function defaultWorld() {
  if (process.env.VERCEL_DEPLOYMENT_ID) {
    return "vercel";
  }
  return "local";
}
const createWorld = () => {
  const targetWorld = process.env.WORKFLOW_TARGET_WORLD || defaultWorld();
  if (targetWorld === "vercel") {
    return createVercelWorld({
      baseUrl: process.env.WORKFLOW_VERCEL_PROXY_URL,
      token: process.env.WORKFLOW_VERCEL_AUTH_TOKEN,
      projectConfig: {
        environment: process.env.WORKFLOW_VERCEL_ENV,
        projectId: process.env.WORKFLOW_VERCEL_PROJECT,
        teamId: process.env.WORKFLOW_VERCEL_TEAM
      }
    });
  }
  if (targetWorld === "local") {
    return createLocalWorld({
      dataDir: process.env.WORKFLOW_LOCAL_DATA_DIR
    });
  }
  const mod = require$1(targetWorld);
  if (typeof mod === "function") {
    return mod();
  } else if (typeof mod.default === "function") {
    return mod.default();
  } else if (typeof mod.createWorld === "function") {
    return mod.createWorld();
  }
  throw new Error(`Invalid target world module: ${targetWorld}, must export a default function or createWorld function that returns a World instance.`);
};
const getWorldHandlers = () => {
  if (globalSymbols[StubbedWorldCache]) {
    return globalSymbols[StubbedWorldCache];
  }
  const _world = createWorld();
  globalSymbols[StubbedWorldCache] = _world;
  return {
    createQueueHandler: _world.createQueueHandler
  };
};
const getWorld = () => {
  if (globalSymbols[WorldCache]) {
    return globalSymbols[WorldCache];
  }
  globalSymbols[WorldCache] = createWorld();
  return globalSymbols[WorldCache];
};
class DevalueError extends Error {
  /**
   * @param {string} message
   * @param {string[]} keys
   */
  constructor(message, keys) {
    super(message);
    this.name = "DevalueError";
    this.path = keys.join("");
  }
}
function is_primitive(thing) {
  return Object(thing) !== thing;
}
const object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
  Object.prototype
).sort().join("\0");
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getPrototypeOf(proto) === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i = 0; i < len; i += 1) {
    const char = str[i];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i) + replacement;
      last_pos = i + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
function enumerable_symbols(object) {
  return Object.getOwnPropertySymbols(object).filter(
    (symbol) => Object.getOwnPropertyDescriptor(object, symbol).enumerable
  );
}
const is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function stringify_key(key) {
  return is_identifier.test(key) ? "." + key : "[" + JSON.stringify(key) + "]";
}
function encode64(arraybuffer) {
  const dv = new DataView(arraybuffer);
  let binaryString = "";
  for (let i = 0; i < arraybuffer.byteLength; i++) {
    binaryString += String.fromCharCode(dv.getUint8(i));
  }
  return binaryToAscii(binaryString);
}
function decode64(string) {
  const binaryString = asciiToBinary(string);
  const arraybuffer = new ArrayBuffer(binaryString.length);
  const dv = new DataView(arraybuffer);
  for (let i = 0; i < arraybuffer.byteLength; i++) {
    dv.setUint8(i, binaryString.charCodeAt(i));
  }
  return arraybuffer;
}
const KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function asciiToBinary(data) {
  if (data.length % 4 === 0) {
    data = data.replace(/==?$/, "");
  }
  let output = "";
  let buffer = 0;
  let accumulatedBits = 0;
  for (let i = 0; i < data.length; i++) {
    buffer <<= 6;
    buffer |= KEY_STRING.indexOf(data[i]);
    accumulatedBits += 6;
    if (accumulatedBits === 24) {
      output += String.fromCharCode((buffer & 16711680) >> 16);
      output += String.fromCharCode((buffer & 65280) >> 8);
      output += String.fromCharCode(buffer & 255);
      buffer = accumulatedBits = 0;
    }
  }
  if (accumulatedBits === 12) {
    buffer >>= 4;
    output += String.fromCharCode(buffer);
  } else if (accumulatedBits === 18) {
    buffer >>= 2;
    output += String.fromCharCode((buffer & 65280) >> 8);
    output += String.fromCharCode(buffer & 255);
  }
  return output;
}
function binaryToAscii(str) {
  let out = "";
  for (let i = 0; i < str.length; i += 3) {
    const groupsOfSix = [void 0, void 0, void 0, void 0];
    groupsOfSix[0] = str.charCodeAt(i) >> 2;
    groupsOfSix[1] = (str.charCodeAt(i) & 3) << 4;
    if (str.length > i + 1) {
      groupsOfSix[1] |= str.charCodeAt(i + 1) >> 4;
      groupsOfSix[2] = (str.charCodeAt(i + 1) & 15) << 2;
    }
    if (str.length > i + 2) {
      groupsOfSix[2] |= str.charCodeAt(i + 2) >> 6;
      groupsOfSix[3] = str.charCodeAt(i + 2) & 63;
    }
    for (let j = 0; j < groupsOfSix.length; j++) {
      if (typeof groupsOfSix[j] === "undefined") {
        out += "=";
      } else {
        out += KEY_STRING[groupsOfSix[j]];
      }
    }
  }
  return out;
}
const UNDEFINED = -1;
const HOLE = -2;
const NAN = -3;
const POSITIVE_INFINITY = -4;
const NEGATIVE_INFINITY = -5;
const NEGATIVE_ZERO = -6;
function parse$1(serialized, revivers) {
  return unflatten(JSON.parse(serialized), revivers);
}
function unflatten(parsed, revivers) {
  if (typeof parsed === "number") return hydrate(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = (
    /** @type {any[]} */
    parsed
  );
  const hydrated = Array(values.length);
  function hydrate(index, standalone = false) {
    if (index === UNDEFINED) return void 0;
    if (index === NAN) return NaN;
    if (index === POSITIVE_INFINITY) return Infinity;
    if (index === NEGATIVE_INFINITY) return -Infinity;
    if (index === NEGATIVE_ZERO) return -0;
    if (standalone || typeof index !== "number") {
      throw new Error(`Invalid input`);
    }
    if (index in hydrated) return hydrated[index];
    const value = values[index];
    if (!value || typeof value !== "object") {
      hydrated[index] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type = value[0];
        const reviver = revivers?.[type];
        if (reviver) {
          let i = value[1];
          if (typeof i !== "number") {
            i = values.push(value[1]) - 1;
          }
          return hydrated[index] = reviver(hydrate(i));
        }
        switch (type) {
          case "Date":
            hydrated[index] = new Date(value[1]);
            break;
          case "Set":
            const set = /* @__PURE__ */ new Set();
            hydrated[index] = set;
            for (let i = 1; i < value.length; i += 1) {
              set.add(hydrate(value[i]));
            }
            break;
          case "Map":
            const map = /* @__PURE__ */ new Map();
            hydrated[index] = map;
            for (let i = 1; i < value.length; i += 2) {
              map.set(hydrate(value[i]), hydrate(value[i + 1]));
            }
            break;
          case "RegExp":
            hydrated[index] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated[index] = Object(value[1]);
            break;
          case "BigInt":
            hydrated[index] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index] = obj;
            for (let i = 1; i < value.length; i += 2) {
              obj[value[i]] = hydrate(value[i + 1]);
            }
            break;
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array": {
            const TypedArrayConstructor = globalThis[type];
            const typedArray = new TypedArrayConstructor(hydrate(value[1]));
            hydrated[index] = value[2] !== void 0 ? typedArray.subarray(value[2], value[3]) : typedArray;
            break;
          }
          case "ArrayBuffer": {
            const base64 = value[1];
            const arraybuffer = decode64(base64);
            hydrated[index] = arraybuffer;
            break;
          }
          case "Temporal.Duration":
          case "Temporal.Instant":
          case "Temporal.PlainDate":
          case "Temporal.PlainTime":
          case "Temporal.PlainDateTime":
          case "Temporal.PlainMonthDay":
          case "Temporal.PlainYearMonth":
          case "Temporal.ZonedDateTime": {
            const temporalName = type.slice(9);
            hydrated[index] = Temporal[temporalName].from(value[1]);
            break;
          }
          case "URL": {
            const url = new URL(value[1]);
            hydrated[index] = url;
            break;
          }
          case "URLSearchParams": {
            const url = new URLSearchParams(value[1]);
            hydrated[index] = url;
            break;
          }
          default:
            throw new Error(`Unknown type ${type}`);
        }
      } else {
        const array = new Array(value.length);
        hydrated[index] = array;
        for (let i = 0; i < value.length; i += 1) {
          const n = value[i];
          if (n === HOLE) continue;
          array[i] = hydrate(n);
        }
      }
    } else {
      const object = {};
      hydrated[index] = object;
      for (const key in value) {
        if (key === "__proto__") {
          throw new Error("Cannot parse an object with a `__proto__` property");
        }
        const n = value[key];
        object[key] = hydrate(n);
      }
    }
    return hydrated[index];
  }
  return hydrate(0);
}
function stringify(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom = [];
  if (reducers) {
    for (const key of Object.getOwnPropertyNames(reducers)) {
      custom.push({ key, fn: reducers[key] });
    }
  }
  const keys = [];
  let p = 0;
  function flatten(thing) {
    if (thing === void 0) return UNDEFINED;
    if (Number.isNaN(thing)) return NAN;
    if (thing === Infinity) return POSITIVE_INFINITY;
    if (thing === -Infinity) return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO;
    if (indexes.has(thing)) return indexes.get(thing);
    const index2 = p++;
    indexes.set(thing, index2);
    for (const { key, fn } of custom) {
      const value2 = fn(thing);
      if (value2) {
        stringified[index2] = `["${key}",${flatten(value2)}]`;
        return index2;
      }
    }
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          const valid = !isNaN(thing.getDate());
          str = `["Date","${valid ? thing.toISOString() : ""}"]`;
          break;
        case "URL":
          str = `["URL",${stringify_string(thing.toString())}]`;
          break;
        case "URLSearchParams":
          str = `["URLSearchParams",${stringify_string(thing.toString())}]`;
          break;
        case "RegExp":
          const { source, flags } = thing;
          str = flags ? `["RegExp",${stringify_string(source)},"${flags}"]` : `["RegExp",${stringify_string(source)}]`;
          break;
        case "Array":
          str = "[";
          for (let i = 0; i < thing.length; i += 1) {
            if (i > 0) str += ",";
            if (i in thing) {
              keys.push(`[${i}]`);
              str += flatten(thing[i]);
              keys.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key) ? stringify_primitive(key) : "..."})`
            );
            str += `,${flatten(key)},${flatten(value2)}`;
            keys.pop();
          }
          str += "]";
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array": {
          const typedArray = thing;
          str = '["' + type + '",' + flatten(typedArray.buffer);
          const a = thing.byteOffset;
          const b = a + thing.byteLength;
          if (a > 0 || b !== typedArray.buffer.byteLength) {
            const m = +/(\d+)/.exec(type)[1] / 8;
            str += `,${a / m},${b / m}`;
          }
          str += "]";
          break;
        }
        case "ArrayBuffer": {
          const arraybuffer = thing;
          const base64 = encode64(arraybuffer);
          str = `["ArrayBuffer","${base64}"]`;
          break;
        }
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          str = `["${type}",${stringify_string(thing.toString())}]`;
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key in thing) {
              keys.push(stringify_key(key));
              str += `,${stringify_string(key)},${flatten(thing[key])}`;
              keys.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key in thing) {
              if (started) str += ",";
              started = true;
              keys.push(stringify_key(key));
              str += `${stringify_string(key)}:${flatten(thing[key])}`;
              keys.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index2] = str;
    return index2;
  }
  const index = flatten(value);
  if (index < 0) return `${index}`;
  return `[${stringified.join(",")}]`;
}
function stringify_primitive(thing) {
  const type = typeof thing;
  if (type === "string") return stringify_string(thing);
  if (thing instanceof String) return stringify_string(thing.toString());
  if (thing === void 0) return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO.toString();
  if (type === "bigint") return `["BigInt","${thing}"]`;
  return String(thing);
}
const WORKFLOW_USE_STEP = Symbol.for("WORKFLOW_USE_STEP");
const WORKFLOW_CREATE_HOOK = Symbol.for("WORKFLOW_CREATE_HOOK");
const WORKFLOW_SLEEP = Symbol.for("WORKFLOW_SLEEP");
const WORKFLOW_GET_STREAM_ID = Symbol.for("WORKFLOW_GET_STREAM_ID");
const STREAM_NAME_SYMBOL = Symbol.for("WORKFLOW_STREAM_NAME");
const STREAM_TYPE_SYMBOL = Symbol.for("WORKFLOW_STREAM_TYPE");
const BODY_INIT_SYMBOL = Symbol.for("BODY_INIT");
const WEBHOOK_RESPONSE_WRITABLE = Symbol.for("WEBHOOK_RESPONSE_WRITABLE");
function getStreamType(stream) {
  try {
    const reader = stream.getReader({ mode: "byob" });
    reader.releaseLock();
    return "bytes";
  } catch {
  }
}
function getSerializeStream(reducers) {
  const encoder = new TextEncoder();
  const stream = new TransformStream({
    transform(chunk, controller) {
      try {
        const serialized = stringify(chunk, reducers);
        controller.enqueue(encoder.encode(`${serialized}
`));
      } catch (error) {
        controller.error(new WorkflowRuntimeError("Failed to serialize stream chunk. Ensure you're passing serializable types (plain objects, arrays, primitives, Date, RegExp, Map, Set).", { slug: "serialization-failed", cause: error }));
      }
    }
  });
  return stream;
}
function getDeserializeStream(revivers) {
  const decoder = new TextDecoder();
  let buffer = "";
  const stream = new TransformStream({
    transform(chunk, controller) {
      buffer += decoder.decode(chunk, { stream: true });
      while (true) {
        const newlineIndex = buffer.indexOf("\n");
        if (newlineIndex === -1)
          break;
        const line = buffer.slice(0, newlineIndex);
        buffer = buffer.slice(newlineIndex + 1);
        if (line.length > 0) {
          const obj = parse$1(line, revivers);
          controller.enqueue(obj);
        }
      }
    },
    flush(controller) {
      if (buffer && buffer.length > 0) {
        const obj = parse$1(buffer, revivers);
        controller.enqueue(obj);
      }
    }
  });
  return stream;
}
class WorkflowServerReadableStream extends ReadableStream {
  #reader;
  constructor(name, startIndex) {
    if (typeof name !== "string" || name.length === 0) {
      throw new Error(`"name" is required, got "${name}"`);
    }
    super({
      // @ts-expect-error Not sure why TypeScript is complaining about this
      type: "bytes",
      pull: async (controller) => {
        let reader = this.#reader;
        if (!reader) {
          const world = getWorld();
          const stream = await world.readFromStream(name, startIndex);
          reader = this.#reader = stream.getReader();
        }
        if (!reader) {
          controller.error(new Error("Failed to get reader"));
          return;
        }
        const result = await reader.read();
        if (result.done) {
          this.#reader = void 0;
          controller.close();
        } else {
          controller.enqueue(result.value);
        }
      }
    });
  }
}
class WorkflowServerWritableStream extends WritableStream {
  constructor(name, runId) {
    if (typeof runId !== "string" && !(runId instanceof Promise)) {
      throw new Error(`"runId" must be a string or a promise that resolves to a string, got "${typeof runId}"`);
    }
    if (typeof name !== "string" || name.length === 0) {
      throw new Error(`"name" is required, got "${name}"`);
    }
    const world = getWorld();
    super({
      async write(chunk) {
        const _runId = await runId;
        await world.writeToStream(name, _runId, chunk);
      },
      async close() {
        const _runId = await runId;
        await world.closeStream(name, _runId);
      }
    });
  }
}
function revive(str) {
  return (0, eval)(`(${str})`);
}
function getCommonReducers(global2 = globalThis) {
  const abToBase64 = (value, offset, length) => {
    if (length === 0)
      return ".";
    const uint8 = new Uint8Array(value, offset, length);
    return Buffer.from(uint8).toString("base64");
  };
  const viewToBase64 = (value) => abToBase64(value.buffer, value.byteOffset, value.byteLength);
  return {
    ArrayBuffer: (value) => value instanceof global2.ArrayBuffer && abToBase64(value, 0, value.byteLength),
    BigInt: (value) => typeof value === "bigint" && value.toString(),
    BigInt64Array: (value) => value instanceof global2.BigInt64Array && viewToBase64(value),
    BigUint64Array: (value) => value instanceof global2.BigUint64Array && viewToBase64(value),
    Date: (value) => {
      if (!(value instanceof global2.Date))
        return false;
      const valid = !Number.isNaN(value.getDate());
      return valid ? value.toISOString() : ".";
    },
    Error: (value) => {
      if (!(value instanceof global2.Error))
        return false;
      return {
        name: value.name,
        message: value.message,
        stack: value.stack
      };
    },
    Float32Array: (value) => value instanceof global2.Float32Array && viewToBase64(value),
    Float64Array: (value) => value instanceof global2.Float64Array && viewToBase64(value),
    Headers: (value) => value instanceof global2.Headers && Array.from(value),
    Int8Array: (value) => value instanceof global2.Int8Array && viewToBase64(value),
    Int16Array: (value) => value instanceof global2.Int16Array && viewToBase64(value),
    Int32Array: (value) => value instanceof global2.Int32Array && viewToBase64(value),
    Map: (value) => value instanceof global2.Map && Array.from(value),
    RegExp: (value) => value instanceof global2.RegExp && {
      source: value.source,
      flags: value.flags
    },
    Request: (value) => {
      if (!(value instanceof global2.Request))
        return false;
      const data = {
        method: value.method,
        url: value.url,
        headers: value.headers,
        body: value.body,
        duplex: value.duplex
      };
      const responseWritable = value[WEBHOOK_RESPONSE_WRITABLE];
      if (responseWritable) {
        data.responseWritable = responseWritable;
      }
      return data;
    },
    Response: (value) => {
      if (!(value instanceof global2.Response))
        return false;
      return {
        type: value.type,
        url: value.url,
        status: value.status,
        statusText: value.statusText,
        headers: value.headers,
        body: value.body,
        redirected: value.redirected
      };
    },
    Set: (value) => value instanceof global2.Set && Array.from(value),
    StepFunction: (value) => {
      if (typeof value !== "function")
        return false;
      const stepId = value.stepId;
      if (typeof stepId !== "string")
        return false;
      const closureVarsFn = value.__closureVarsFn;
      if (closureVarsFn && typeof closureVarsFn === "function") {
        const closureVars = closureVarsFn();
        return { stepId, closureVars };
      }
      return { stepId };
    },
    URL: (value) => value instanceof global2.URL && value.href,
    URLSearchParams: (value) => {
      if (!(value instanceof global2.URLSearchParams))
        return false;
      if (value.size === 0)
        return ".";
      return String(value);
    },
    Uint8Array: (value) => value instanceof global2.Uint8Array && viewToBase64(value),
    Uint8ClampedArray: (value) => value instanceof global2.Uint8ClampedArray && viewToBase64(value),
    Uint16Array: (value) => value instanceof global2.Uint16Array && viewToBase64(value),
    Uint32Array: (value) => value instanceof global2.Uint32Array && viewToBase64(value)
  };
}
function getExternalReducers(global2 = globalThis, ops, runId) {
  return {
    ...getCommonReducers(global2),
    ReadableStream: (value) => {
      if (!(value instanceof global2.ReadableStream))
        return false;
      if (value.locked) {
        throw new Error("ReadableStream is locked");
      }
      const name = global2.crypto.randomUUID();
      const type = getStreamType(value);
      const writable = new WorkflowServerWritableStream(name, runId);
      if (type === "bytes") {
        ops.push(value.pipeTo(writable));
      } else {
        ops.push(value.pipeThrough(getSerializeStream(getExternalReducers(global2, ops, runId))).pipeTo(writable));
      }
      const s = { name };
      if (type)
        s.type = type;
      return s;
    },
    WritableStream: (value) => {
      if (!(value instanceof global2.WritableStream))
        return false;
      const name = global2.crypto.randomUUID();
      const readable2 = new WorkflowServerReadableStream(name);
      ops.push(readable2.pipeTo(value));
      return { name };
    }
  };
}
function getWorkflowReducers(global2 = globalThis) {
  return {
    ...getCommonReducers(global2),
    // Readable/Writable streams from within the workflow execution environment
    // are simply "handles" that can be passed around to other steps.
    ReadableStream: (value) => {
      if (!(value instanceof global2.ReadableStream))
        return false;
      const bodyInit = value[BODY_INIT_SYMBOL];
      if (bodyInit !== void 0) {
        return { bodyInit };
      }
      const name = value[STREAM_NAME_SYMBOL];
      if (!name) {
        throw new Error("ReadableStream `name` is not set");
      }
      const s = { name };
      const type = value[STREAM_TYPE_SYMBOL];
      if (type)
        s.type = type;
      return s;
    },
    WritableStream: (value) => {
      if (!(value instanceof global2.WritableStream))
        return false;
      const name = value[STREAM_NAME_SYMBOL];
      if (!name) {
        throw new Error("WritableStream `name` is not set");
      }
      return { name };
    }
  };
}
function getStepReducers(global2 = globalThis, ops, runId) {
  return {
    ...getCommonReducers(global2),
    ReadableStream: (value) => {
      if (!(value instanceof global2.ReadableStream))
        return false;
      if (value.locked) {
        throw new Error("ReadableStream is locked");
      }
      let name = value[STREAM_NAME_SYMBOL];
      let type = value[STREAM_TYPE_SYMBOL];
      if (!name) {
        if (!runId) {
          throw new Error("ReadableStream cannot be serialized without a valid runId");
        }
        name = global2.crypto.randomUUID();
        type = getStreamType(value);
        const writable = new WorkflowServerWritableStream(name, runId);
        if (type === "bytes") {
          ops.push(value.pipeTo(writable));
        } else {
          ops.push(value.pipeThrough(getSerializeStream(getStepReducers(global2, ops, runId))).pipeTo(writable));
        }
      }
      const s = { name };
      if (type)
        s.type = type;
      return s;
    },
    WritableStream: (value) => {
      if (!(value instanceof global2.WritableStream))
        return false;
      let name = value[STREAM_NAME_SYMBOL];
      if (!name) {
        if (!runId) {
          throw new Error("WritableStream cannot be serialized without a valid runId");
        }
        name = global2.crypto.randomUUID();
        ops.push(new WorkflowServerReadableStream(name).pipeThrough(getDeserializeStream(getStepRevivers(global2, ops, runId))).pipeTo(value));
      }
      return { name };
    }
  };
}
function getCommonRevivers(global2 = globalThis) {
  function reviveArrayBuffer(value) {
    const base64 = value === "." ? "" : value;
    const buffer = Buffer.from(base64, "base64");
    const arrayBuffer = new global2.ArrayBuffer(buffer.length);
    const uint8Array = new global2.Uint8Array(arrayBuffer);
    uint8Array.set(buffer);
    return arrayBuffer;
  }
  return {
    ArrayBuffer: reviveArrayBuffer,
    BigInt: (value) => global2.BigInt(value),
    BigInt64Array: (value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.BigInt64Array(ab);
    },
    BigUint64Array: (value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.BigUint64Array(ab);
    },
    Date: (value) => new global2.Date(value),
    Error: (value) => {
      const error = new global2.Error(value.message);
      error.name = value.name;
      error.stack = value.stack;
      return error;
    },
    Float32Array: (value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Float32Array(ab);
    },
    Float64Array: (value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Float64Array(ab);
    },
    Headers: (value) => new global2.Headers(value),
    Int8Array: (value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Int8Array(ab);
    },
    Int16Array: (value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Int16Array(ab);
    },
    Int32Array: (value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Int32Array(ab);
    },
    Map: (value) => new global2.Map(value),
    RegExp: (value) => new global2.RegExp(value.source, value.flags),
    Set: (value) => new global2.Set(value),
    StepFunction: (value) => {
      const stepId = value.stepId;
      const closureVars = value.closureVars;
      const stepFn = getStepFunction(stepId);
      if (!stepFn) {
        throw new Error(`Step function "${stepId}" not found. Make sure the step function is registered.`);
      }
      if (closureVars) {
        const wrappedStepFn = ((...args) => {
          const currentContext = contextStorage.getStore();
          if (!currentContext) {
            throw new Error("Cannot call step function with closure variables outside step context");
          }
          const newContext = {
            ...currentContext,
            closureVars
          };
          return contextStorage.run(newContext, () => stepFn(...args));
        });
        Object.defineProperty(wrappedStepFn, "name", {
          value: stepFn.name
        });
        Object.defineProperty(wrappedStepFn, "stepId", {
          value: stepId,
          writable: false,
          enumerable: false,
          configurable: false
        });
        if (stepFn.maxRetries !== void 0) {
          wrappedStepFn.maxRetries = stepFn.maxRetries;
        }
        return wrappedStepFn;
      }
      return stepFn;
    },
    URL: (value) => new global2.URL(value),
    URLSearchParams: (value) => new global2.URLSearchParams(value === "." ? "" : value),
    Uint8Array: (value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Uint8Array(ab);
    },
    Uint8ClampedArray: (value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Uint8ClampedArray(ab);
    },
    Uint16Array: (value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Uint16Array(ab);
    },
    Uint32Array: (value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Uint32Array(ab);
    }
  };
}
function getExternalRevivers(global2 = globalThis, ops, runId) {
  return {
    ...getCommonRevivers(global2),
    Request: (value) => {
      return new global2.Request(value.url, {
        method: value.method,
        headers: new global2.Headers(value.headers),
        body: value.body,
        duplex: value.duplex
      });
    },
    Response: (value) => {
      return new global2.Response(value.body, {
        status: value.status,
        statusText: value.statusText,
        headers: new global2.Headers(value.headers)
      });
    },
    ReadableStream: (value) => {
      if ("bodyInit" in value) {
        const bodyInit = value.bodyInit;
        const response2 = new global2.Response(bodyInit);
        return response2.body;
      }
      const readable2 = new WorkflowServerReadableStream(value.name, value.startIndex);
      if (value.type === "bytes") {
        return readable2;
      } else {
        const transform = getDeserializeStream(getExternalRevivers(global2, ops, runId));
        ops.push(readable2.pipeTo(transform.writable));
        return transform.readable;
      }
    },
    WritableStream: (value) => {
      const serialize = getSerializeStream(getExternalReducers(global2, ops, runId));
      ops.push(serialize.readable.pipeTo(new WorkflowServerWritableStream(value.name, runId)));
      return serialize.writable;
    }
  };
}
function getWorkflowRevivers(global2 = globalThis) {
  return {
    ...getCommonRevivers(global2),
    Request: (value) => {
      Object.setPrototypeOf(value, global2.Request.prototype);
      const responseWritable = value.responseWritable;
      if (responseWritable) {
        value[WEBHOOK_RESPONSE_WRITABLE] = responseWritable;
        delete value.responseWritable;
        value.respondWith = () => {
          throw new Error("`respondWith()` must be called from within a step function");
        };
      }
      return value;
    },
    Response: (value) => {
      Object.setPrototypeOf(value, global2.Response.prototype);
      return value;
    },
    ReadableStream: (value) => {
      if ("bodyInit" in value) {
        return Object.create(global2.ReadableStream.prototype, {
          [BODY_INIT_SYMBOL]: {
            value: value.bodyInit,
            writable: false
          }
        });
      }
      return Object.create(global2.ReadableStream.prototype, {
        [STREAM_NAME_SYMBOL]: {
          value: value.name,
          writable: false
        },
        [STREAM_TYPE_SYMBOL]: {
          value: value.type,
          writable: false
        }
      });
    },
    WritableStream: (value) => {
      return Object.create(global2.WritableStream.prototype, {
        [STREAM_NAME_SYMBOL]: {
          value: value.name,
          writable: false
        }
      });
    }
  };
}
function getStepRevivers(global2 = globalThis, ops, runId) {
  return {
    ...getCommonRevivers(global2),
    Request: (value) => {
      const responseWritable = value.responseWritable;
      const request2 = new global2.Request(value.url, {
        method: value.method,
        headers: new global2.Headers(value.headers),
        body: value.body,
        duplex: value.duplex
      });
      if (responseWritable) {
        request2.respondWith = async (response2) => {
          const writer = responseWritable.getWriter();
          await writer.write(response2);
          await writer.close();
        };
      }
      return request2;
    },
    Response: (value) => {
      return new global2.Response(value.body, {
        status: value.status,
        statusText: value.statusText,
        headers: new global2.Headers(value.headers)
      });
    },
    ReadableStream: (value) => {
      if ("bodyInit" in value) {
        const bodyInit = value.bodyInit;
        const response2 = new global2.Response(bodyInit);
        return response2.body;
      }
      const readable2 = new WorkflowServerReadableStream(value.name);
      if (value.type === "bytes") {
        return readable2;
      } else {
        const transform = getDeserializeStream(getStepRevivers(global2, ops, runId));
        ops.push(readable2.pipeTo(transform.writable));
        return transform.readable;
      }
    },
    WritableStream: (value) => {
      if (!runId) {
        throw new Error("WritableStream cannot be revived without a valid runId");
      }
      const serialize = getSerializeStream(getStepReducers(global2, ops, runId));
      ops.push(serialize.readable.pipeTo(new WorkflowServerWritableStream(value.name, runId)));
      return serialize.writable;
    }
  };
}
function dehydrateWorkflowArguments(value, ops, runId, global2 = globalThis) {
  try {
    const str = stringify(value, getExternalReducers(global2, ops, runId));
    return revive(str);
  } catch (error) {
    throw new WorkflowRuntimeError(`Failed to serialize workflow arguments. Ensure you're passing serializable types (plain objects, arrays, primitives, Date, RegExp, Map, Set).`, { slug: "serialization-failed", cause: error });
  }
}
function hydrateWorkflowArguments(value, global2 = globalThis, extraRevivers = {}) {
  const obj = unflatten(value, {
    ...getWorkflowRevivers(global2),
    ...extraRevivers
  });
  return obj;
}
function dehydrateWorkflowReturnValue(value, global2 = globalThis) {
  try {
    const str = stringify(value, getWorkflowReducers(global2));
    return revive(str);
  } catch (error) {
    throw new WorkflowRuntimeError(`Failed to serialize workflow return value. Ensure you're returning serializable types (plain objects, arrays, primitives, Date, RegExp, Map, Set).`, { slug: "serialization-failed", cause: error });
  }
}
function hydrateWorkflowReturnValue(value, ops, runId, global2 = globalThis, extraRevivers = {}) {
  const obj = unflatten(value, {
    ...getExternalRevivers(global2, ops, runId),
    ...extraRevivers
  });
  return obj;
}
function dehydrateStepArguments(value, global2) {
  try {
    const str = stringify(value, getWorkflowReducers(global2));
    return revive(str);
  } catch (error) {
    throw new WorkflowRuntimeError(`Failed to serialize step arguments. Ensure you're passing serializable types (plain objects, arrays, primitives, Date, RegExp, Map, Set).`, { slug: "serialization-failed", cause: error });
  }
}
function hydrateStepArguments(value, ops, runId, global2 = globalThis, extraRevivers = {}) {
  const obj = unflatten(value, {
    ...getStepRevivers(global2, ops, runId),
    ...extraRevivers
  });
  return obj;
}
function dehydrateStepReturnValue(value, ops, runId, global2 = globalThis) {
  try {
    const str = stringify(value, getStepReducers(global2, ops, runId));
    return revive(str);
  } catch (error) {
    throw new WorkflowRuntimeError(`Failed to serialize step return value. Ensure you're returning serializable types (plain objects, arrays, primitives, Date, RegExp, Map, Set).`, { slug: "serialization-failed", cause: error });
  }
}
function hydrateStepReturnValue(value, global2 = globalThis, extraRevivers = {}) {
  const obj = unflatten(value, {
    ...getWorkflowRevivers(global2),
    ...extraRevivers
  });
  return obj;
}
var comma = ",".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
function decodeInteger(reader, relative) {
  let value = 0;
  let shift = 0;
  let integer = 0;
  do {
    const c = reader.next();
    integer = charToInt[c];
    value |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  const shouldNegate = value & 1;
  value >>>= 1;
  if (shouldNegate) {
    value = -2147483648 | -value;
  }
  return relative + value;
}
function hasMoreVlq(reader, max) {
  if (reader.pos >= max) return false;
  return reader.peek() !== comma;
}
var StringReader = class {
  constructor(buffer) {
    this.pos = 0;
    this.buffer = buffer;
  }
  next() {
    return this.buffer.charCodeAt(this.pos++);
  }
  peek() {
    return this.buffer.charCodeAt(this.pos);
  }
  indexOf(char) {
    const { buffer, pos } = this;
    const idx = buffer.indexOf(char, pos);
    return idx === -1 ? buffer.length : idx;
  }
};
function decode(mappings) {
  const { length } = mappings;
  const reader = new StringReader(mappings);
  const decoded = [];
  let genColumn = 0;
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  do {
    const semi = reader.indexOf(";");
    const line = [];
    let sorted = true;
    let lastCol = 0;
    genColumn = 0;
    while (reader.pos < semi) {
      let seg;
      genColumn = decodeInteger(reader, genColumn);
      if (genColumn < lastCol) sorted = false;
      lastCol = genColumn;
      if (hasMoreVlq(reader, semi)) {
        sourcesIndex = decodeInteger(reader, sourcesIndex);
        sourceLine = decodeInteger(reader, sourceLine);
        sourceColumn = decodeInteger(reader, sourceColumn);
        if (hasMoreVlq(reader, semi)) {
          namesIndex = decodeInteger(reader, namesIndex);
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
        } else {
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
        }
      } else {
        seg = [genColumn];
      }
      line.push(seg);
      reader.pos++;
    }
    if (!sorted) sort(line);
    decoded.push(line);
    reader.pos = semi + 1;
  } while (reader.pos <= length);
  return decoded;
}
function sort(line) {
  line.sort(sortComparator$1);
}
function sortComparator$1(a, b) {
  return a[0] - b[0];
}
const schemeRegex = /^[\w+.-]+:\/\//;
const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
function isAbsoluteUrl(input) {
  return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
  return input.startsWith("//");
}
function isAbsolutePath(input) {
  return input.startsWith("/");
}
function isFileUrl(input) {
  return input.startsWith("file:");
}
function isRelative(input) {
  return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
  const match = urlRegex.exec(input);
  return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
}
function parseFileUrl(input) {
  const match = fileRegex.exec(input);
  const path2 = match[2];
  return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path2) ? path2 : "/" + path2, match[3] || "", match[4] || "");
}
function makeUrl(scheme, user, host, port, path2, query, hash) {
  return {
    scheme,
    user,
    host,
    port,
    path: path2,
    query,
    hash,
    type: 7
  };
}
function parseUrl(input) {
  if (isSchemeRelativeUrl(input)) {
    const url2 = parseAbsoluteUrl("http:" + input);
    url2.scheme = "";
    url2.type = 6;
    return url2;
  }
  if (isAbsolutePath(input)) {
    const url2 = parseAbsoluteUrl("http://foo.com" + input);
    url2.scheme = "";
    url2.host = "";
    url2.type = 5;
    return url2;
  }
  if (isFileUrl(input))
    return parseFileUrl(input);
  if (isAbsoluteUrl(input))
    return parseAbsoluteUrl(input);
  const url = parseAbsoluteUrl("http://foo.com/" + input);
  url.scheme = "";
  url.host = "";
  url.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
  return url;
}
function stripPathFilename(path2) {
  if (path2.endsWith("/.."))
    return path2;
  const index = path2.lastIndexOf("/");
  return path2.slice(0, index + 1);
}
function mergePaths(url, base) {
  normalizePath(base, base.type);
  if (url.path === "/") {
    url.path = base.path;
  } else {
    url.path = stripPathFilename(base.path) + url.path;
  }
}
function normalizePath(url, type) {
  const rel = type <= 4;
  const pieces = url.path.split("/");
  let pointer = 1;
  let positive = 0;
  let addTrailingSlash = false;
  for (let i = 1; i < pieces.length; i++) {
    const piece = pieces[i];
    if (!piece) {
      addTrailingSlash = true;
      continue;
    }
    addTrailingSlash = false;
    if (piece === ".")
      continue;
    if (piece === "..") {
      if (positive) {
        addTrailingSlash = true;
        positive--;
        pointer--;
      } else if (rel) {
        pieces[pointer++] = piece;
      }
      continue;
    }
    pieces[pointer++] = piece;
    positive++;
  }
  let path2 = "";
  for (let i = 1; i < pointer; i++) {
    path2 += "/" + pieces[i];
  }
  if (!path2 || addTrailingSlash && !path2.endsWith("/..")) {
    path2 += "/";
  }
  url.path = path2;
}
function resolve(input, base) {
  if (!input && !base)
    return "";
  const url = parseUrl(input);
  let inputType = url.type;
  if (base && inputType !== 7) {
    const baseUrl = parseUrl(base);
    const baseType = baseUrl.type;
    switch (inputType) {
      case 1:
        url.hash = baseUrl.hash;
      // fall through
      case 2:
        url.query = baseUrl.query;
      // fall through
      case 3:
      case 4:
        mergePaths(url, baseUrl);
      // fall through
      case 5:
        url.user = baseUrl.user;
        url.host = baseUrl.host;
        url.port = baseUrl.port;
      // fall through
      case 6:
        url.scheme = baseUrl.scheme;
    }
    if (baseType > inputType)
      inputType = baseType;
  }
  normalizePath(url, inputType);
  const queryHash = url.query + url.hash;
  switch (inputType) {
    // This is impossible, because of the empty checks at the start of the function.
    // case UrlType.Empty:
    case 2:
    case 3:
      return queryHash;
    case 4: {
      const path2 = url.path.slice(1);
      if (!path2)
        return queryHash || ".";
      if (isRelative(base || input) && !isRelative(path2)) {
        return "./" + path2 + queryHash;
      }
      return path2 + queryHash;
    }
    case 5:
      return url.path + queryHash;
    default:
      return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
  }
}
function stripFilename(path2) {
  if (!path2) return "";
  const index = path2.lastIndexOf("/");
  return path2.slice(0, index + 1);
}
function resolver(mapUrl, sourceRoot) {
  const from = stripFilename(mapUrl);
  const prefix = sourceRoot ? sourceRoot + "/" : "";
  return (source) => resolve(prefix + (source || ""), from);
}
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
function maybeSort(mappings, owned) {
  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
  if (unsortedIndex === mappings.length) return mappings;
  if (!owned) mappings = mappings.slice();
  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
    mappings[i] = sortSegments(mappings[i], owned);
  }
  return mappings;
}
function nextUnsortedSegmentLine(mappings, start2) {
  for (let i = start2; i < mappings.length; i++) {
    if (!isSorted(mappings[i])) return i;
  }
  return mappings.length;
}
function isSorted(line) {
  for (let j = 1; j < line.length; j++) {
    if (line[j][COLUMN] < line[j - 1][COLUMN]) {
      return false;
    }
  }
  return true;
}
function sortSegments(line, owned) {
  if (!owned) line = line.slice();
  return line.sort(sortComparator);
}
function sortComparator(a, b) {
  return a[COLUMN] - b[COLUMN];
}
var found = false;
function binarySearch(haystack, needle, low, high) {
  while (low <= high) {
    const mid = low + (high - low >> 1);
    const cmp = haystack[mid][COLUMN] - needle;
    if (cmp === 0) {
      found = true;
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  found = false;
  return low - 1;
}
function upperBound(haystack, needle, index) {
  for (let i = index + 1; i < haystack.length; index = i++) {
    if (haystack[i][COLUMN] !== needle) break;
  }
  return index;
}
function lowerBound(haystack, needle, index) {
  for (let i = index - 1; i >= 0; index = i--) {
    if (haystack[i][COLUMN] !== needle) break;
  }
  return index;
}
function memoizedState() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function memoizedBinarySearch(haystack, needle, state, key) {
  const { lastKey, lastNeedle, lastIndex } = state;
  let low = 0;
  let high = haystack.length - 1;
  if (key === lastKey) {
    if (needle === lastNeedle) {
      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
      return lastIndex;
    }
    if (needle >= lastNeedle) {
      low = lastIndex === -1 ? 0 : lastIndex;
    } else {
      high = lastIndex;
    }
  }
  state.lastKey = key;
  state.lastNeedle = needle;
  return state.lastIndex = binarySearch(haystack, needle, low, high);
}
function parse(map) {
  return typeof map === "string" ? JSON.parse(map) : map;
}
var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
var TraceMap = class {
  constructor(map, mapUrl) {
    const isString = typeof map === "string";
    if (!isString && map._decodedMemo) return map;
    const parsed = parse(map);
    const { version: version2, file: file2, names, sourceRoot, sources, sourcesContent } = parsed;
    this.version = version2;
    this.file = file2;
    this.names = names || [];
    this.sourceRoot = sourceRoot;
    this.sources = sources;
    this.sourcesContent = sourcesContent;
    this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
    const resolve2 = resolver(mapUrl, sourceRoot);
    this.resolvedSources = sources.map(resolve2);
    const { mappings } = parsed;
    if (typeof mappings === "string") {
      this._encoded = mappings;
      this._decoded = void 0;
    } else if (Array.isArray(mappings)) {
      this._encoded = void 0;
      this._decoded = maybeSort(mappings, isString);
    } else if (parsed.sections) {
      throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
    } else {
      throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
    }
    this._decodedMemo = memoizedState();
    this._bySources = void 0;
    this._bySourceMemos = void 0;
  }
};
function cast(map) {
  return map;
}
function decodedMappings(map) {
  var _a;
  return (_a = cast(map))._decoded || (_a._decoded = decode(cast(map)._encoded));
}
function originalPositionFor(map, needle) {
  let { line, column, bias } = needle;
  line--;
  if (line < 0) throw new Error(LINE_GTR_ZERO);
  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
  const decoded = decodedMappings(map);
  if (line >= decoded.length) return OMapping(null, null, null, null);
  const segments = decoded[line];
  const index = traceSegmentInternal(
    segments,
    cast(map)._decodedMemo,
    line,
    column,
    bias || GREATEST_LOWER_BOUND
  );
  if (index === -1) return OMapping(null, null, null, null);
  const segment = segments[index];
  if (segment.length === 1) return OMapping(null, null, null, null);
  const { names, resolvedSources } = map;
  return OMapping(
    resolvedSources[segment[SOURCES_INDEX]],
    segment[SOURCE_LINE] + 1,
    segment[SOURCE_COLUMN],
    segment.length === 5 ? names[segment[NAMES_INDEX]] : null
  );
}
function OMapping(source, line, column, name) {
  return { source, line, column, name };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
  let index = memoizedBinarySearch(segments, column, memo, line);
  if (found) {
    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
  } else if (bias === LEAST_UPPER_BOUND) index++;
  if (index === -1 || index === segments.length) return -1;
  return index;
}
function remapErrorStack(stack, filename, workflowCode) {
  const sourceMapMatch = workflowCode.match(/\/\/# sourceMappingURL=data:application\/json;base64,(.+)/);
  if (!sourceMapMatch) {
    return stack;
  }
  try {
    const base64 = sourceMapMatch[1];
    const sourceMapJson = Buffer.from(base64, "base64").toString("utf-8");
    const sourceMapData = JSON.parse(sourceMapJson);
    const tracer = new TraceMap(sourceMapData);
    const lines = stack.split("\n");
    const remappedLines = lines.map((line) => {
      const frameMatch = line.match(/^\s*at\s+(?:(.+?)\s+\()?(.+?):(\d+):(\d+)\)?$/);
      if (!frameMatch) {
        return line;
      }
      const [, functionName, file2, lineStr, colStr] = frameMatch;
      if (!file2.includes(filename)) {
        return line;
      }
      const lineNumber = parseInt(lineStr, 10);
      const columnNumber = parseInt(colStr, 10);
      const original = originalPositionFor(tracer, {
        line: lineNumber,
        column: columnNumber
      });
      if (original.source && original.line !== null) {
        const func = functionName || original.name || "anonymous";
        const col = original.column !== null ? original.column : columnNumber;
        return `    at ${func} (${original.source}:${original.line}:${col})`;
      }
      return line;
    });
    return remappedLines.join("\n");
  } catch (e) {
    return stack;
  }
}
function SemanticConvention(...names) {
  return (value) => Object.fromEntries(names.map((name) => [name, value]));
}
const WorkflowName = SemanticConvention("workflow.name");
const WorkflowOperation = SemanticConvention("workflow.operation");
const WorkflowRunId = SemanticConvention("workflow.run.id");
const WorkflowRunStatus = SemanticConvention("workflow.run.status");
const WorkflowStartedAt = SemanticConvention("workflow.started_at");
const WorkflowEventsCount = SemanticConvention("workflow.events.count");
const WorkflowArgumentsCount = SemanticConvention("workflow.arguments.count");
const WorkflowResultType = SemanticConvention("workflow.result.type");
const WorkflowTracePropagated = SemanticConvention("workflow.trace.propagated");
const WorkflowErrorName = SemanticConvention("workflow.error.name");
const WorkflowErrorMessage = SemanticConvention("workflow.error.message");
const WorkflowStepsCreated = SemanticConvention("workflow.steps.created");
const StepName = SemanticConvention("step.name");
const StepId = SemanticConvention("step.id");
const StepAttempt = SemanticConvention("step.attempt");
const StepStatus = SemanticConvention("step.status");
const StepMaxRetries = SemanticConvention("step.max_retries");
const StepTracePropagated = SemanticConvention("step.trace.propagated");
const StepSkipped = SemanticConvention("step.skipped");
const StepSkipReason = SemanticConvention("step.skip_reason");
const StepArgumentsCount = SemanticConvention("step.arguments.count");
const StepResultType = SemanticConvention("step.result.type");
const StepErrorName = SemanticConvention("step.error.name");
const StepErrorMessage = SemanticConvention("step.error.message");
const StepFatalError = SemanticConvention("step.fatal_error");
const StepRetryExhausted = SemanticConvention("step.retry.exhausted");
const StepRetryTimeoutSeconds = SemanticConvention("step.retry.timeout_seconds");
const StepRetryWillRetry = SemanticConvention("step.retry.will_retry");
const QueueName = SemanticConvention("queue.name");
const QueueMessageId = SemanticConvention("messaging.message.id", "queue.message.id");
const QueueOverheadMs = SemanticConvention("queue.overhead_ms");
const DeploymentId = SemanticConvention("deployment.id");
const HookToken = SemanticConvention("workflow.hook.token");
const HookId = SemanticConvention("workflow.hook.id");
const HookFound = SemanticConvention("workflow.hook.found");
function getErrorName(v) {
  if (types$1.isNativeError(v)) {
    return v.name;
  }
  return "Error";
}
function getErrorStack(v) {
  if (types$1.isNativeError(v)) {
    return v.stack ?? "";
  }
  return "";
}
function buildWorkflowSuspensionMessage(runId, stepCount, hookCount, waitCount) {
  if (stepCount === 0 && hookCount === 0 && waitCount === 0) {
    return null;
  }
  const parts = [];
  if (stepCount > 0) {
    parts.push(`${stepCount} ${stepCount === 1 ? "step" : "steps"}`);
  }
  if (hookCount > 0) {
    parts.push(`${hookCount} ${hookCount === 1 ? "hook" : "hooks"}`);
  }
  if (waitCount > 0) {
    parts.push(`${waitCount} ${waitCount === 1 ? "timer" : "timers"}`);
  }
  const resumeMsgParts = [];
  if (stepCount > 0) {
    resumeMsgParts.push("steps are completed");
  }
  if (hookCount > 0) {
    resumeMsgParts.push("hooks are received");
  }
  if (waitCount > 0) {
    resumeMsgParts.push("timers have elapsed");
  }
  const resumeMsg = resumeMsgParts.join(" and ");
  return `[Workflows] "${runId}" - ${parts.join(" and ")} to be enqueued
  Workflow will suspend and resume when ${resumeMsg}`;
}
function getWorkflowRunStreamId(runId, namespace) {
  const streamId = `${runId.replace("wrun_", "strm_")}_user`;
  if (!namespace) {
    return streamId;
  }
  const encodedNamespace = Buffer.from(namespace, "utf-8").toString("base64url");
  return `${streamId}_${encodedNamespace}`;
}
async function waitedUntil(fn) {
  const result = fn();
  functionsExports.waitUntil(result.catch(() => {
  }));
  return result;
}
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
function customRandom(alphabet, defaultSize, getRandom) {
  let mask = (2 << 31 - Math.clz32(alphabet.length - 1 | 1)) - 1;
  let step = Math.ceil(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    if (!size) return "";
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let i = step;
      while (i--) {
        id += alphabet[bytes[i] & mask] || "";
        if (id.length >= size) return id;
      }
    }
  };
}
var EventConsumerResult;
(function(EventConsumerResult2) {
  EventConsumerResult2[EventConsumerResult2["Consumed"] = 0] = "Consumed";
  EventConsumerResult2[EventConsumerResult2["NotConsumed"] = 1] = "NotConsumed";
  EventConsumerResult2[EventConsumerResult2["Finished"] = 2] = "Finished";
})(EventConsumerResult || (EventConsumerResult = {}));
class EventsConsumer {
  eventIndex;
  events = [];
  callbacks = [];
  constructor(events2) {
    this.events = events2;
    this.eventIndex = 0;
    eventsLogger.debug("EventsConsumer initialized", { events: events2 });
  }
  /**
   * Registers a callback function to be called after an event has been consumed
   * by a different callback. The callback can return:
   *  - `EventConsumerResult.Consumed` the event is considered consumed and will not be passed to any other callback, but the callback will remain in the callbacks list
   *  - `EventConsumerResult.NotConsumed` the event is passed to the next callback
   *  - `EventConsumerResult.Finished` the event is considered consumed and the callback is removed from the callbacks list
   *
   * @param fn - The callback function to register.
   */
  subscribe(fn) {
    this.callbacks.push(fn);
    process.nextTick(this.consume);
  }
  consume = () => {
    const currentEvent = this.events[this.eventIndex] ?? null;
    for (let i = 0; i < this.callbacks.length; i++) {
      const callback = this.callbacks[i];
      let handled = EventConsumerResult.NotConsumed;
      try {
        handled = callback(currentEvent);
      } catch (error) {
        eventsLogger.error("EventConsumer callback threw an error", { error });
        console.error("EventConsumer callback threw an error", error);
      }
      eventsLogger.debug("EventConsumer callback result", {
        handled: EventConsumerResult[handled],
        eventIndex: this.eventIndex,
        eventId: currentEvent?.eventId
      });
      if (handled === EventConsumerResult.Consumed || handled === EventConsumerResult.Finished) {
        this.eventIndex++;
        if (handled === EventConsumerResult.Finished) {
          this.callbacks.splice(i, 1);
        }
        process.nextTick(this.consume);
        return;
      }
    }
  };
}
function createUseStep(ctx) {
  return function useStep(stepName, closureVarsFn) {
    const stepFunction = (...args) => {
      const { promise, resolve: resolve2, reject } = withResolvers();
      const correlationId = `step_${ctx.generateUlid()}`;
      const queueItem = {
        type: "step",
        correlationId,
        stepName,
        args
      };
      const closureVars = closureVarsFn?.();
      if (closureVars) {
        queueItem.closureVars = closureVars;
      }
      ctx.invocationsQueue.push(queueItem);
      let hasSeenStepStarted = false;
      stepLogger.debug("Step consumer setup", {
        correlationId,
        stepName,
        args
      });
      ctx.eventsConsumer.subscribe((event) => {
        if (!event) {
          setTimeout(() => {
            ctx.onWorkflowError(new WorkflowSuspension(ctx.invocationsQueue, ctx.globalThis));
          }, 0);
          return EventConsumerResult.NotConsumed;
        }
        stepLogger.debug("Step consumer event processing", {
          correlationId,
          stepName,
          args: args.join(", "),
          incomingCorrelationId: event.correlationId,
          isMatch: correlationId === event.correlationId,
          eventType: event.eventType
        });
        if (event.correlationId !== correlationId) {
          return EventConsumerResult.NotConsumed;
        }
        if (event.eventType === "step_started") {
          if (!hasSeenStepStarted) {
            const invocationsQueueIndex = ctx.invocationsQueue.findIndex((invocation) => invocation.type === "step" && invocation.correlationId === correlationId);
            if (invocationsQueueIndex !== -1) {
              ctx.invocationsQueue.splice(invocationsQueueIndex, 1);
            } else {
              setTimeout(() => {
                reject(new WorkflowRuntimeError(`Corrupted event log: step ${correlationId} (${stepName}) started but not found in invocation queue`));
              }, 0);
              return EventConsumerResult.Finished;
            }
            hasSeenStepStarted = true;
          }
          return EventConsumerResult.Consumed;
        }
        if (event.eventType === "step_failed") {
          if (event.eventData.fatal) {
            setTimeout(() => {
              reject(new FatalError(event.eventData.error));
            }, 0);
            return EventConsumerResult.Finished;
          } else {
            return EventConsumerResult.Consumed;
          }
        } else if (event.eventType === "step_completed") {
          const hydratedResult = hydrateStepReturnValue(event.eventData.result, ctx.globalThis);
          setTimeout(() => {
            resolve2(hydratedResult);
          }, 0);
          return EventConsumerResult.Finished;
        } else {
          setTimeout(() => {
            reject(new WorkflowRuntimeError(`Unexpected event type: "${event.eventType}"`));
          }, 0);
          return EventConsumerResult.Finished;
        }
      });
      return promise;
    };
    const functionName = stepName.split("//").pop();
    Object.defineProperty(stepFunction, "name", {
      value: functionName
    });
    Object.defineProperty(stepFunction, "stepId", {
      value: stepName,
      writable: false,
      enumerable: false,
      configurable: false
    });
    if (closureVarsFn) {
      Object.defineProperty(stepFunction, "__closureVarsFn", {
        value: closureVarsFn,
        writable: false,
        enumerable: false,
        configurable: false
      });
    }
    return stepFunction;
  };
}
var alea$1 = { exports: {} };
var alea = alea$1.exports;
var hasRequiredAlea;
function requireAlea() {
  if (hasRequiredAlea) return alea$1.exports;
  hasRequiredAlea = 1;
  (function(module) {
    (function(global2, module2, define) {
      function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
          var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
          me.s0 = me.s1;
          me.s1 = me.s2;
          return me.s2 = t - (me.c = t | 0);
        };
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
          me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
          me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
          me.s2 += 1;
        }
        mash = null;
      }
      function copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4294967296;
          }
          return (n >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else {
        this.alea = impl;
      }
    })(
      alea,
      module
    );
  })(alea$1);
  return alea$1.exports;
}
var xor128$1 = { exports: {} };
var xor128 = xor128$1.exports;
var hasRequiredXor128;
function requireXor128() {
  if (hasRequiredXor128) return xor128$1.exports;
  hasRequiredXor128 = 1;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.next = function() {
          var t = me.x ^ me.x << 11;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else {
        this.xor128 = impl;
      }
    })(
      xor128,
      module
    );
  })(xor128$1);
  return xor128$1.exports;
}
var xorwow$1 = { exports: {} };
var xorwow = xorwow$1.exports;
var hasRequiredXorwow;
function requireXorwow() {
  if (hasRequiredXorwow) return xorwow$1.exports;
  hasRequiredXorwow = 1;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var t = me.x ^ me.x >>> 2;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          me.w = me.v;
          return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          if (k == strseed.length) {
            me.d = me.x << 10 ^ me.x >>> 4;
          }
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else {
        this.xorwow = impl;
      }
    })(
      xorwow,
      module
    );
  })(xorwow$1);
  return xorwow$1.exports;
}
var xorshift7$1 = { exports: {} };
var xorshift7 = xorshift7$1.exports;
var hasRequiredXorshift7;
function requireXorshift7() {
  if (hasRequiredXorshift7) return xorshift7$1.exports;
  hasRequiredXorshift7 = 1;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var X = me.x, i = me.i, t, v;
          t = X[i];
          t ^= t >>> 7;
          v = t ^ t << 24;
          t = X[i + 1 & 7];
          v ^= t ^ t >>> 10;
          t = X[i + 3 & 7];
          v ^= t ^ t >>> 3;
          t = X[i + 4 & 7];
          v ^= t ^ t << 7;
          t = X[i + 7 & 7];
          t = t ^ t << 13;
          v ^= t ^ t << 9;
          X[i] = v;
          me.i = i + 1 & 7;
          return v;
        };
        function init(me2, seed2) {
          var j, X = [];
          if (seed2 === (seed2 | 0)) {
            X[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j = 0; j < seed2.length; ++j) {
              X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
            }
          }
          while (X.length < 8) X.push(0);
          for (j = 0; j < 8 && X[j] === 0; ++j) ;
          if (j == 8) X[7] = -1;
          else X[j];
          me2.x = X;
          me2.i = 0;
          for (j = 256; j > 0; --j) {
            me2.next();
          }
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
      }
      function impl(seed, opts) {
        if (seed == null) seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x) copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else {
        this.xorshift7 = impl;
      }
    })(
      xorshift7,
      module
    );
  })(xorshift7$1);
  return xorshift7$1.exports;
}
var xor4096$1 = { exports: {} };
var xor4096 = xor4096$1.exports;
var hasRequiredXor4096;
function requireXor4096() {
  if (hasRequiredXor4096) return xor4096$1.exports;
  hasRequiredXor4096 = 1;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var w = me.w, X = me.X, i = me.i, t, v;
          me.w = w = w + 1640531527 | 0;
          v = X[i + 34 & 127];
          t = X[i = i + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          v = X[i] = v ^ t;
          me.i = i;
          return v + (w ^ w >>> 16) | 0;
        };
        function init(me2, seed2) {
          var t, v, i, j, w, X = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i = 0, j = -32; j < limit; ++j) {
            if (seed2) v ^= seed2.charCodeAt((j + 32) % seed2.length);
            if (j === 0) w = v;
            v ^= v << 10;
            v ^= v >>> 15;
            v ^= v << 4;
            v ^= v >>> 13;
            if (j >= 0) {
              w = w + 1640531527 | 0;
              t = X[j & 127] ^= v + w;
              i = 0 == t ? i + 1 : 0;
            }
          }
          if (i >= 128) {
            X[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i = 127;
          for (j = 4 * 128; j > 0; --j) {
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            X[i] = v ^ t;
          }
          me2.w = w;
          me2.X = X;
          me2.i = i;
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
      }
      function impl(seed, opts) {
        if (seed == null) seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X) copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else {
        this.xor4096 = impl;
      }
    })(
      xor4096,
      // window object or global
      module
    );
  })(xor4096$1);
  return xor4096$1.exports;
}
var tychei$1 = { exports: {} };
var tychei = tychei$1.exports;
var hasRequiredTychei;
function requireTychei() {
  if (hasRequiredTychei) return tychei$1.exports;
  hasRequiredTychei = 1;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var b = me.b, c = me.c, d = me.d, a = me.a;
          b = b << 25 ^ b >>> 7 ^ c;
          c = c - d | 0;
          d = d << 24 ^ d >>> 8 ^ a;
          a = a - b | 0;
          me.b = b = b << 20 ^ b >>> 12 ^ c;
          me.c = c = c - d | 0;
          me.d = d << 16 ^ c >>> 16 ^ a;
          return me.a = a - b | 0;
        };
        me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me.a = seed / 4294967296 | 0;
          me.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 20; k++) {
          me.b ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else {
        this.tychei = impl;
      }
    })(
      tychei,
      module
    );
  })(tychei$1);
  return tychei$1.exports;
}
var seedrandom$3 = { exports: {} };
var seedrandom$2 = seedrandom$3.exports;
var hasRequiredSeedrandom$1;
function requireSeedrandom$1() {
  if (hasRequiredSeedrandom$1) return seedrandom$3.exports;
  hasRequiredSeedrandom$1 = 1;
  (function(module) {
    (function(global2, pool2, math) {
      var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom2(seed, options, callback) {
        var key = [];
        options = options == true ? { entropy: true } : options || {};
        var shortseed = mixkey(flatten(
          options.entropy ? [seed, tostring(pool2)] : seed == null ? autoseed() : seed,
          3
        ), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n = arc4.g(chunks), d = startdenom, x = 0;
          while (n < significance) {
            n = (n + x) * width;
            d *= width;
            x = arc4.g(1);
          }
          while (n >= overflow) {
            n /= 2;
            d /= 2;
            x >>>= 1;
          }
          return (n + x) / d;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool2);
        return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy(state, arc4);
            }
            prng2.state = function() {
              return copy(arc4, {});
            };
          }
          if (is_math_call) {
            math[rngname] = prng2;
            return seed2;
          } else return prng2;
        })(
          prng,
          shortseed,
          "global" in options ? options.global : this == math,
          options.state
        );
      }
      function ARC4(key) {
        var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i < width) {
          s[i] = i++;
        }
        for (i = 0; i < width; i++) {
          s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
          s[j] = t;
        }
        (me.g = function(count) {
          var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
          while (count--) {
            t2 = s2[i2 = mask & i2 + 1];
            r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
          }
          me.i = i2;
          me.j = j2;
          return r;
        })(width);
      }
      function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
      }
      function flatten(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten(obj[prop], depth - 1));
            } catch (e) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j = 0;
        while (j < stringseed.length) {
          key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e) {
          var browser2 = global2.navigator, plugins = browser2 && browser2.plugins;
          return [+/* @__PURE__ */ new Date(), global2, plugins, global2.screen, tostring(pool2)];
        }
      }
      function tostring(a) {
        return String.fromCharCode.apply(0, a);
      }
      mixkey(math.random(), pool2);
      if (module.exports) {
        module.exports = seedrandom2;
        try {
          nodecrypto = require("crypto");
        } catch (ex) {
        }
      } else {
        math["seed" + rngname] = seedrandom2;
      }
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      typeof self !== "undefined" ? self : seedrandom$2,
      [],
      // pool: entropy pool starts empty
      Math
      // math: package containing random, pow, and seedrandom
    );
  })(seedrandom$3);
  return seedrandom$3.exports;
}
var seedrandom$1;
var hasRequiredSeedrandom;
function requireSeedrandom() {
  if (hasRequiredSeedrandom) return seedrandom$1;
  hasRequiredSeedrandom = 1;
  var alea2 = requireAlea();
  var xor1282 = requireXor128();
  var xorwow2 = requireXorwow();
  var xorshift72 = requireXorshift7();
  var xor40962 = requireXor4096();
  var tychei2 = requireTychei();
  var sr = requireSeedrandom$1();
  sr.alea = alea2;
  sr.xor128 = xor1282;
  sr.xorwow = xorwow2;
  sr.xorshift7 = xorshift72;
  sr.xor4096 = xor40962;
  sr.tychei = tychei2;
  seedrandom$1 = sr;
  return seedrandom$1;
}
var seedrandomExports = requireSeedrandom();
const seedrandom = /* @__PURE__ */ getDefaultExportFromCjs(seedrandomExports);
function createRandomUUID(rng) {
  return function randomUUID() {
    const chars2 = "0123456789abcdef";
    let uuid = "";
    for (let i = 0; i < 36; i++) {
      if (i === 8 || i === 13 || i === 18 || i === 23) {
        uuid += "-";
      } else if (i === 14) {
        uuid += "4";
      } else if (i === 19) {
        uuid += chars2[Math.floor(rng() * 4) + 8];
      } else {
        uuid += chars2[Math.floor(rng() * 16)];
      }
    }
    return uuid;
  };
}
function createContext(options) {
  let { fixedTimestamp } = options;
  const { seed } = options;
  const rng = seedrandom(seed);
  const context = createContext$1();
  const g = runInContext("globalThis", context);
  g.Math.random = rng;
  const Date_ = g.Date;
  g.Date = function Date2(...args) {
    if (args.length === 0) {
      return new Date_(fixedTimestamp);
    }
    return new Date_(...args);
  };
  g.Date.prototype = Date_.prototype;
  Object.setPrototypeOf(g.Date, Date_);
  g.Date.now = () => fixedTimestamp;
  const originalCrypto = globalThis.crypto;
  const originalSubtle = originalCrypto.subtle;
  function getRandomValues(array) {
    for (let i = 0; i < array.length; i++) {
      array[i] = Math.floor(rng() * 256);
    }
    return array;
  }
  const randomUUID = createRandomUUID(rng);
  const boundDigest = originalSubtle.digest.bind(originalSubtle);
  g.crypto = new Proxy(originalCrypto, {
    get(target, prop) {
      if (prop === "getRandomValues") {
        return getRandomValues;
      }
      if (prop === "randomUUID") {
        return randomUUID;
      }
      if (prop === "subtle") {
        return new Proxy(originalSubtle, {
          get(target2, prop2) {
            if (prop2 === "generateKey") {
              return () => {
                throw new Error("Not implemented");
              };
            } else if (prop2 === "digest") {
              return boundDigest;
            }
            return target2[prop2];
          }
        });
      }
      return target[prop];
    }
  });
  g.process = {
    env: Object.freeze({ ...process.env })
  };
  g.Headers = globalThis.Headers;
  g.TextEncoder = globalThis.TextEncoder;
  g.TextDecoder = globalThis.TextDecoder;
  g.console = globalThis.console;
  g.URL = globalThis.URL;
  g.URLSearchParams = globalThis.URLSearchParams;
  g.structuredClone = globalThis.structuredClone;
  g.exports = {};
  g.module = { exports: g.exports };
  return {
    context,
    globalThis: g,
    updateTimestamp: (timestamp) => {
      fixedTimestamp = timestamp;
    }
  };
}
const WORKFLOW_CONTEXT_SYMBOL = /* @__PURE__ */ Symbol.for("WORKFLOW_CONTEXT");
function createCreateHook(ctx) {
  return function createHookImpl(options = {}) {
    const correlationId = `hook_${ctx.generateUlid()}`;
    const token = options.token ?? ctx.generateNanoid();
    ctx.invocationsQueue.push({
      type: "hook",
      correlationId,
      token,
      metadata: options.metadata
    });
    const payloadsQueue = [];
    const promises2 = [];
    let eventLogEmpty = false;
    webhookLogger.debug("Hook consumer setup", { correlationId, token });
    ctx.eventsConsumer.subscribe((event) => {
      if (!event) {
        eventLogEmpty = true;
        if (promises2.length > 0) {
          setTimeout(() => {
            ctx.onWorkflowError(new WorkflowSuspension(ctx.invocationsQueue, ctx.globalThis));
          }, 0);
          return EventConsumerResult.Finished;
        }
      }
      if (event?.eventType === "hook_created" && event.correlationId === correlationId) {
        const index = ctx.invocationsQueue.findIndex((item) => item.type === "hook" && item.correlationId === correlationId);
        if (index !== -1) {
          ctx.invocationsQueue.splice(index, 1);
        }
        return EventConsumerResult.Consumed;
      }
      if (event?.eventType === "hook_received" && event.correlationId === correlationId) {
        if (promises2.length > 0) {
          const next = promises2.shift();
          if (next) {
            const payload = hydrateStepReturnValue(event.eventData.payload, ctx.globalThis);
            next.resolve(payload);
          }
        } else {
          payloadsQueue.push(event);
        }
        return EventConsumerResult.Consumed;
      }
      return EventConsumerResult.NotConsumed;
    });
    function createHookPromise() {
      const resolvers = withResolvers();
      if (payloadsQueue.length > 0) {
        const nextPayload = payloadsQueue.shift();
        if (nextPayload) {
          const payload = hydrateStepReturnValue(nextPayload.eventData.payload, ctx.globalThis);
          resolvers.resolve(payload);
          return resolvers.promise;
        }
      }
      if (eventLogEmpty) {
        setTimeout(() => {
          ctx.onWorkflowError(new WorkflowSuspension(ctx.invocationsQueue, ctx.globalThis));
        }, 0);
      }
      promises2.push(resolvers);
      return resolvers.promise;
    }
    const hook = {
      token,
      // biome-ignore lint/suspicious/noThenProperty: Intentionally thenable
      then(onfulfilled, onrejected) {
        return createHookPromise().then(onfulfilled, onrejected);
      },
      // Support `for await (const payload of hook) { â¦ }` syntax
      async *[Symbol.asyncIterator]() {
        while (true) {
          yield await this;
        }
      }
    };
    return hook;
  };
}
function createSleep(ctx) {
  return async function sleepImpl(param) {
    const { promise, resolve: resolve2 } = withResolvers();
    const correlationId = `wait_${ctx.generateUlid()}`;
    const resumeAt = parseDurationToDate(param);
    ctx.invocationsQueue.push({
      type: "wait",
      correlationId,
      resumeAt
    });
    ctx.eventsConsumer.subscribe((event) => {
      if (!event) {
        setTimeout(() => {
          ctx.onWorkflowError(new WorkflowSuspension(ctx.invocationsQueue, ctx.globalThis));
        }, 0);
        return EventConsumerResult.NotConsumed;
      }
      if (event?.eventType === "wait_created" && event.correlationId === correlationId) {
        const waitItem = ctx.invocationsQueue.find((item) => item.type === "wait" && item.correlationId === correlationId);
        if (waitItem) {
          waitItem.hasCreatedEvent = true;
          waitItem.resumeAt = event.eventData.resumeAt;
        }
        return EventConsumerResult.Consumed;
      }
      if (event?.eventType === "wait_completed" && event.correlationId === correlationId) {
        const index = ctx.invocationsQueue.findIndex((item) => item.type === "wait" && item.correlationId === correlationId);
        if (index !== -1) {
          ctx.invocationsQueue.splice(index, 1);
        }
        setTimeout(() => {
          resolve2();
        }, 0);
        return EventConsumerResult.Finished;
      }
      return EventConsumerResult.NotConsumed;
    });
    return promise;
  };
}
async function runWorkflow(workflowCode, workflowRun, events2) {
  return trace(`WORKFLOW.run ${workflowRun.workflowName}`, async (span) => {
    span?.setAttributes({
      ...WorkflowName(workflowRun.workflowName),
      ...WorkflowRunId(workflowRun.runId),
      ...WorkflowRunStatus(workflowRun.status),
      ...WorkflowEventsCount(events2.length)
    });
    const startedAt = workflowRun.startedAt;
    if (!startedAt) {
      throw new Error(`Workflow run "${workflowRun.runId}" has no "startedAt" timestamp (should not happen)`);
    }
    const port = await getPort();
    const { context, globalThis: vmGlobalThis, updateTimestamp } = createContext({
      seed: workflowRun.runId,
      fixedTimestamp: +startedAt
    });
    const workflowDiscontinuation = withResolvers();
    const ulid2 = monotonicFactory(() => vmGlobalThis.Math.random());
    const generateNanoid = customRandom(urlAlphabet, 21, (size) => new Uint8Array(size).map(() => 256 * vmGlobalThis.Math.random()));
    const workflowContext = {
      globalThis: vmGlobalThis,
      onWorkflowError: workflowDiscontinuation.reject,
      eventsConsumer: new EventsConsumer(events2),
      generateUlid: () => ulid2(+startedAt),
      generateNanoid,
      invocationsQueue: []
    };
    workflowContext.eventsConsumer.subscribe((event) => {
      const createdAt = event?.createdAt;
      if (createdAt) {
        updateTimestamp(+createdAt);
      }
      return EventConsumerResult.NotConsumed;
    });
    const useStep = createUseStep(workflowContext);
    const createHook2 = createCreateHook(workflowContext);
    const sleep = createSleep(workflowContext);
    vmGlobalThis[WORKFLOW_USE_STEP] = useStep;
    vmGlobalThis[WORKFLOW_CREATE_HOOK] = createHook2;
    vmGlobalThis[WORKFLOW_SLEEP] = sleep;
    vmGlobalThis[WORKFLOW_GET_STREAM_ID] = (namespace) => getWorkflowRunStreamId(workflowRun.runId, namespace);
    const url = process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : `http://localhost:${port ?? 3e3}`;
    const ctx = {
      workflowRunId: workflowRun.runId,
      workflowStartedAt: new vmGlobalThis.Date(+startedAt),
      url
    };
    vmGlobalThis[WORKFLOW_CONTEXT_SYMBOL] = ctx;
    vmGlobalThis.fetch = () => {
      throw new vmGlobalThis.Error(`Global "fetch" is unavailable in workflow functions. Use the "fetch" step function from "workflow" to make HTTP requests.

Learn more: https://useworkflow.dev/err/${ERROR_SLUGS.FETCH_IN_WORKFLOW_FUNCTION}`);
    };
    class Request2 {
      cache;
      credentials;
      destination;
      headers;
      integrity;
      method;
      mode;
      redirect;
      referrer;
      referrerPolicy;
      url;
      keepalive;
      signal;
      duplex;
      body;
      constructor(input, init) {
        if (typeof input === "string" || input instanceof vmGlobalThis.URL) {
          const urlString = String(input);
          try {
            new vmGlobalThis.URL(urlString);
            this.url = urlString;
          } catch (cause) {
            throw new TypeError(`Failed to parse URL from ${urlString}`, {
              cause
            });
          }
        } else {
          this.url = input.url;
          if (!init) {
            this.method = input.method;
            this.headers = new vmGlobalThis.Headers(input.headers);
            this.body = input.body;
            this.mode = input.mode;
            this.credentials = input.credentials;
            this.cache = input.cache;
            this.redirect = input.redirect;
            this.referrer = input.referrer;
            this.referrerPolicy = input.referrerPolicy;
            this.integrity = input.integrity;
            this.keepalive = input.keepalive;
            this.signal = input.signal;
            this.duplex = input.duplex;
            this.destination = input.destination;
            return;
          }
          this.method = input.method;
          this.headers = new vmGlobalThis.Headers(input.headers);
          this.body = input.body;
          this.mode = input.mode;
          this.credentials = input.credentials;
          this.cache = input.cache;
          this.redirect = input.redirect;
          this.referrer = input.referrer;
          this.referrerPolicy = input.referrerPolicy;
          this.integrity = input.integrity;
          this.keepalive = input.keepalive;
          this.signal = input.signal;
          this.duplex = input.duplex;
          this.destination = input.destination;
        }
        if (init?.method) {
          this.method = init.method.toUpperCase();
        } else if (typeof this.method !== "string") {
          this.method = "GET";
        }
        if (init?.headers) {
          this.headers = new vmGlobalThis.Headers(init.headers);
        } else if (typeof input === "string" || input instanceof vmGlobalThis.URL) {
          this.headers = new vmGlobalThis.Headers();
        }
        if (init?.mode !== void 0) {
          this.mode = init.mode;
        } else if (typeof this.mode !== "string") {
          this.mode = "cors";
        }
        if (init?.credentials !== void 0) {
          this.credentials = init.credentials;
        } else if (typeof this.credentials !== "string") {
          this.credentials = "same-origin";
        }
        if (init?.cache !== void 0) {
          this.cache = init.cache;
        } else if (typeof this.cache !== "string") {
          this.cache = "default";
        }
        if (init?.redirect !== void 0) {
          this.redirect = init.redirect;
        } else if (typeof this.redirect !== "string") {
          this.redirect = "follow";
        }
        if (init?.referrer !== void 0) {
          this.referrer = init.referrer;
        } else if (typeof this.referrer !== "string") {
          this.referrer = "about:client";
        }
        if (init?.referrerPolicy !== void 0) {
          this.referrerPolicy = init.referrerPolicy;
        } else if (typeof this.referrerPolicy !== "string") {
          this.referrerPolicy = "";
        }
        if (init?.integrity !== void 0) {
          this.integrity = init.integrity;
        } else if (typeof this.integrity !== "string") {
          this.integrity = "";
        }
        if (init?.keepalive !== void 0) {
          this.keepalive = init.keepalive;
        } else if (typeof this.keepalive !== "boolean") {
          this.keepalive = false;
        }
        if (init?.signal !== void 0) {
          this.signal = init.signal;
        } else if (!this.signal) {
          this.signal = { aborted: false };
        }
        if (!this.duplex) {
          this.duplex = "half";
        }
        if (!this.destination) {
          this.destination = "document";
        }
        const body2 = init?.body;
        if (body2 !== null && body2 !== void 0 && (this.method === "GET" || this.method === "HEAD")) {
          throw new TypeError(`Request with GET/HEAD method cannot have body.`);
        }
        if (body2 !== null && body2 !== void 0) {
          this.body = Object.create(vmGlobalThis.ReadableStream.prototype, {
            [BODY_INIT_SYMBOL]: {
              value: body2,
              writable: false
            }
          });
        } else {
          this.body = null;
        }
      }
      clone() {
        ENOTSUP();
      }
      get bodyUsed() {
        return false;
      }
      // TODO: implement these
      blob;
      formData;
      async arrayBuffer() {
        return resArrayBuffer(this);
      }
      async bytes() {
        return new Uint8Array(await resArrayBuffer(this));
      }
      async json() {
        return resJson(this);
      }
      async text() {
        return resText(this);
      }
    }
    vmGlobalThis.Request = Request2;
    const resJson = useStep("__builtin_response_json");
    const resText = useStep("__builtin_response_text");
    const resArrayBuffer = useStep("__builtin_response_array_buffer");
    class Response2 {
      type;
      url;
      status;
      statusText;
      body;
      headers;
      redirected;
      constructor(body2, init) {
        this.status = init?.status ?? 200;
        this.statusText = init?.statusText ?? "";
        this.headers = new vmGlobalThis.Headers(init?.headers);
        this.type = "default";
        this.url = "";
        this.redirected = false;
        if (body2 !== null && body2 !== void 0 && (this.status === 204 || this.status === 205 || this.status === 304)) {
          throw new TypeError(`Response constructor: Invalid response status code ${this.status}`);
        }
        if (body2 !== null && body2 !== void 0) {
          this.body = Object.create(vmGlobalThis.ReadableStream.prototype, {
            [BODY_INIT_SYMBOL]: {
              value: body2,
              writable: false
            }
          });
        } else {
          this.body = null;
        }
      }
      // TODO: implement these
      clone;
      blob;
      formData;
      get ok() {
        return this.status >= 200 && this.status < 300;
      }
      get bodyUsed() {
        return false;
      }
      async arrayBuffer() {
        return resArrayBuffer(this);
      }
      async bytes() {
        return new Uint8Array(await resArrayBuffer(this));
      }
      async json() {
        return resJson(this);
      }
      static json(data, init) {
        const body2 = JSON.stringify(data);
        const headers2 = new vmGlobalThis.Headers(init?.headers);
        if (!headers2.has("content-type")) {
          headers2.set("content-type", "application/json");
        }
        return new Response2(body2, { ...init, headers: headers2 });
      }
      async text() {
        return resText(this);
      }
      static error() {
        ENOTSUP();
      }
      static redirect(url2, status = 302) {
        if (![301, 302, 303, 307, 308].includes(status)) {
          throw new RangeError(`Invalid redirect status code: ${status}. Must be one of: 301, 302, 303, 307, 308`);
        }
        const headers2 = new vmGlobalThis.Headers();
        headers2.set("Location", String(url2));
        const response2 = Object.create(Response2.prototype);
        response2.status = status;
        response2.statusText = "";
        response2.headers = headers2;
        response2.body = null;
        response2.type = "default";
        response2.url = "";
        response2.redirected = false;
        return response2;
      }
    }
    vmGlobalThis.Response = Response2;
    class ReadableStream2 {
      constructor() {
        ENOTSUP();
      }
      get locked() {
        return false;
      }
      cancel() {
        ENOTSUP();
      }
      getReader() {
        ENOTSUP();
      }
      pipeThrough() {
        ENOTSUP();
      }
      pipeTo() {
        ENOTSUP();
      }
      tee() {
        ENOTSUP();
      }
      values() {
        ENOTSUP();
      }
      static from() {
        ENOTSUP();
      }
      [Symbol.asyncIterator]() {
        ENOTSUP();
      }
    }
    vmGlobalThis.ReadableStream = ReadableStream2;
    class WritableStream2 {
      constructor() {
        ENOTSUP();
      }
      get locked() {
        return false;
      }
      abort() {
        ENOTSUP();
      }
      close() {
        ENOTSUP();
      }
      getWriter() {
        ENOTSUP();
      }
    }
    vmGlobalThis.WritableStream = WritableStream2;
    class TransformStream2 {
      readable;
      writable;
      constructor() {
        ENOTSUP();
      }
    }
    vmGlobalThis.TransformStream = TransformStream2;
    vmGlobalThis.console = globalThis.console;
    const SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
    vmGlobalThis[SYMBOL_FOR_REQ_CONTEXT] = globalThis[SYMBOL_FOR_REQ_CONTEXT];
    const parsedName = parseWorkflowName(workflowRun.workflowName);
    const filename = parsedName?.path || workflowRun.workflowName;
    const workflowFn = runInContext(`${workflowCode}; globalThis.__private_workflows?.get(${JSON.stringify(workflowRun.workflowName)})`, context, { filename });
    if (typeof workflowFn !== "function") {
      throw new ReferenceError(`Workflow ${JSON.stringify(workflowRun.workflowName)} must be a function, but got "${typeof workflowFn}" instead`);
    }
    const args = hydrateWorkflowArguments(workflowRun.input, vmGlobalThis);
    span?.setAttributes({
      ...WorkflowArgumentsCount(args.length)
    });
    const result = await Promise.race([
      workflowFn(...args),
      workflowDiscontinuation.promise
    ]);
    const dehydrated = dehydrateWorkflowReturnValue(result, vmGlobalThis);
    span?.setAttributes({
      ...WorkflowResultType(typeof result)
    });
    return dehydrated;
  });
}
async function getHookByToken(token) {
  const world = getWorld();
  const hook = await world.hooks.getByToken(token);
  if (typeof hook.metadata !== "undefined") {
    hook.metadata = hydrateStepArguments(hook.metadata, [], hook.runId);
  }
  return hook;
}
async function resumeHook(token, payload) {
  return await waitedUntil(() => {
    return trace("HOOK.resume", async (span) => {
      const world = getWorld();
      try {
        const hook = await getHookByToken(token);
        span?.setAttributes({
          ...HookToken(token),
          ...HookId(hook.hookId),
          ...WorkflowRunId(hook.runId)
        });
        const ops = [];
        const dehydratedPayload = dehydrateStepReturnValue(payload, ops, hook.runId);
        functionsExports.waitUntil(Promise.all(ops).catch((err) => {
          if (err !== void 0)
            throw err;
        }));
        await world.events.create(hook.runId, {
          eventType: "hook_received",
          correlationId: hook.hookId,
          eventData: {
            payload: dehydratedPayload
          }
        });
        const workflowRun = await world.runs.get(hook.runId);
        span?.setAttributes({
          ...WorkflowName(workflowRun.workflowName)
        });
        const traceCarrier = workflowRun.executionContext?.traceCarrier;
        if (traceCarrier) {
          const context = await getSpanContextForTraceCarrier(traceCarrier);
          if (context) {
            span?.addLink?.({ context });
          }
        }
        await world.queue(`__wkf_workflow_${workflowRun.workflowName}`, {
          runId: hook.runId,
          // attach the trace carrier from the workflow run
          traceCarrier: workflowRun.executionContext?.traceCarrier ?? void 0
        }, {
          deploymentId: workflowRun.deploymentId
        });
        return hook;
      } catch (err) {
        span?.setAttributes({
          ...HookToken(token),
          ...HookFound(false)
        });
        throw err;
      }
    });
  });
}
async function resumeWebhook(token, request2) {
  const hook = await getHookByToken(token);
  let response2;
  let responseReadable;
  if (hook.metadata && typeof hook.metadata === "object" && "respondWith" in hook.metadata) {
    if (hook.metadata.respondWith === "manual") {
      const { readable: readable2, writable } = new TransformStream();
      responseReadable = readable2;
      request2[WEBHOOK_RESPONSE_WRITABLE] = writable;
    } else if (hook.metadata.respondWith instanceof Response) {
      response2 = hook.metadata.respondWith;
    } else {
      throw new WorkflowRuntimeError(`Invalid \`respondWith\` value: ${hook.metadata.respondWith}`, { slug: ERROR_SLUGS.WEBHOOK_INVALID_RESPOND_WITH_VALUE });
    }
  } else {
    response2 = new Response(null, { status: 202 });
  }
  await resumeHook(hook.token, request2);
  if (responseReadable) {
    const reader = responseReadable.getReader();
    const chunk = await reader.read();
    if (chunk.value) {
      response2 = chunk.value;
    }
    reader.cancel();
  }
  if (!response2) {
    throw new WorkflowRuntimeError("Workflow run did not send a response", {
      slug: ERROR_SLUGS.WEBHOOK_RESPONSE_NOT_SENT
    });
  }
  return response2;
}
async function start(workflow, argsOrOptions, options) {
  return await waitedUntil(() => {
    const workflowName = workflow?.workflowId;
    if (!workflowName) {
      throw new WorkflowRuntimeError(`'start' received an invalid workflow function. Ensure the Workflow Development Kit is configured correctly and the function includes a 'use workflow' directive.`, {
        slug: "start-invalid-workflow-function"
      });
    }
    return trace(`WORKFLOW.start ${workflowName}`, async (span) => {
      span?.setAttributes({
        ...WorkflowName(workflowName),
        ...WorkflowOperation("start")
      });
      let args = [];
      let opts = {};
      if (Array.isArray(argsOrOptions)) {
        args = argsOrOptions;
      } else if (typeof argsOrOptions === "object") {
        opts = argsOrOptions;
      }
      span?.setAttributes({
        ...WorkflowArgumentsCount(args.length)
      });
      const world = getWorld();
      const deploymentId = opts.deploymentId ?? await world.getDeploymentId();
      const ops = [];
      const { promise: runIdPromise, resolve: resolveRunId } = withResolvers();
      const workflowArguments = dehydrateWorkflowArguments(args, ops, runIdPromise);
      const traceCarrier = await serializeTraceCarrier();
      const runResponse = await world.runs.create({
        deploymentId,
        workflowName,
        input: workflowArguments,
        executionContext: {
          traceCarrier
        }
      });
      resolveRunId(runResponse.runId);
      functionsExports.waitUntil(Promise.all(ops).catch((err) => {
        const isAbortError = err?.name === "AbortError" || err?.name === "ResponseAborted";
        if (!isAbortError) throw err;
      }));
      span?.setAttributes({
        ...WorkflowRunId(runResponse.runId),
        ...WorkflowRunStatus(runResponse.status),
        ...DeploymentId(deploymentId)
      });
      await world.queue(`__wkf_workflow_${workflowName}`, {
        runId: runResponse.runId,
        traceCarrier
      }, {
        deploymentId
      });
      return new Run(runResponse.runId);
    });
  });
}
class Run {
  /**
   * The ID of the workflow run.
   */
  runId;
  /**
   * The world object.
   * @internal
   */
  world;
  constructor(runId) {
    this.runId = runId;
    this.world = getWorld();
  }
  /**
   * Cancels the workflow run.
   */
  async cancel() {
    await this.world.runs.cancel(this.runId);
  }
  /**
   * The status of the workflow run.
   */
  get status() {
    return this.world.runs.get(this.runId).then((run) => run.status);
  }
  /**
   * The return value of the workflow run.
   * Polls the workflow return value until it is completed.
   */
  get returnValue() {
    return this.pollReturnValue();
  }
  /**
   * The name of the workflow.
   */
  get workflowName() {
    return this.world.runs.get(this.runId).then((run) => run.workflowName);
  }
  /**
   * The timestamp when the workflow run was created.
   */
  get createdAt() {
    return this.world.runs.get(this.runId).then((run) => run.createdAt);
  }
  /**
   * The timestamp when the workflow run started execution.
   * Returns undefined if the workflow has not started yet.
   */
  get startedAt() {
    return this.world.runs.get(this.runId).then((run) => run.startedAt);
  }
  /**
   * The timestamp when the workflow run completed.
   * Returns undefined if the workflow has not completed yet.
   */
  get completedAt() {
    return this.world.runs.get(this.runId).then((run) => run.completedAt);
  }
  /**
   * The readable stream of the workflow run.
   */
  get readable() {
    return this.getReadable();
  }
  /**
   * Retrieves the workflow run's default readable stream, which reads chunks
   * written to the corresponding writable stream {@link getWritable}.
   *
   * @param options - The options for the readable stream.
   * @returns The `ReadableStream` for the workflow run.
   */
  getReadable(options = {}) {
    const { ops = [], global: global2 = globalThis, startIndex, namespace } = options;
    const name = getWorkflowRunStreamId(this.runId, namespace);
    return getExternalRevivers(global2, ops, this.runId).ReadableStream({
      name,
      startIndex
    });
  }
  /**
   * Polls the workflow return value every 1 second until it is completed.
   * @internal
   * @returns The workflow return value.
   */
  async pollReturnValue() {
    while (true) {
      try {
        const run = await this.world.runs.get(this.runId);
        if (run.status === "completed") {
          return hydrateWorkflowReturnValue(run.output, [], this.runId);
        }
        if (run.status === "cancelled") {
          throw new WorkflowRunCancelledError(this.runId);
        }
        if (run.status === "failed") {
          throw new WorkflowRunFailedError(this.runId, run.error);
        }
        throw new WorkflowRunNotCompletedError(this.runId, run.status);
      } catch (error) {
        if (WorkflowRunNotCompletedError.is(error)) {
          await new Promise((resolve2) => setTimeout(resolve2, 1e3));
          continue;
        }
        throw error;
      }
    }
  }
}
function getRun(runId) {
  return new Run(runId);
}
async function getAllWorkflowRunEvents(runId) {
  const allEvents = [];
  let cursor = null;
  let hasMore = true;
  const world = getWorld();
  while (hasMore) {
    const response2 = await world.events.list({
      runId,
      pagination: {
        sortOrder: "asc",
        // Required: events must be in chronological order for replay
        cursor: cursor ?? void 0
      }
    });
    allEvents.push(...response2.data);
    hasMore = response2.hasMore;
    cursor = response2.cursor;
  }
  return allEvents;
}
function workflowEntrypoint(workflowCode) {
  return getWorldHandlers().createQueueHandler("__wkf_workflow_", async (message_, metadata) => {
    const { runId, traceCarrier: traceContext, requestedAt } = WorkflowInvokePayloadSchema.parse(message_);
    const workflowName = metadata.queueName.slice("__wkf_workflow_".length);
    const spanLinks = await linkToCurrentContext();
    return await withTraceContext(traceContext, async () => {
      const world = getWorld();
      return trace(`WORKFLOW ${workflowName}`, { links: spanLinks }, async (span) => {
        span?.setAttributes({
          ...WorkflowName(workflowName),
          ...WorkflowOperation("execute"),
          ...QueueName(metadata.queueName),
          ...QueueMessageId(metadata.messageId),
          ...getQueueOverhead({ requestedAt })
        });
        span?.setAttributes({
          ...WorkflowRunId(runId),
          ...WorkflowTracePropagated(!!traceContext)
        });
        let workflowStartedAt = -1;
        try {
          let workflowRun = await world.runs.get(runId);
          if (workflowRun.status === "pending") {
            workflowRun = await world.runs.update(runId, {
              // This sets the `startedAt` timestamp at the database level
              status: "running"
            });
          }
          if (!workflowRun.startedAt) {
            throw new Error(`Workflow run "${runId}" has no "startedAt" timestamp`);
          }
          workflowStartedAt = +workflowRun.startedAt;
          span?.setAttributes({
            ...WorkflowRunStatus(workflowRun.status),
            ...WorkflowStartedAt(workflowStartedAt)
          });
          if (workflowRun.status !== "running") {
            console.warn(`Workflow "${runId}" has status "${workflowRun.status}", skipping`);
            return;
          }
          const events2 = await getAllWorkflowRunEvents(workflowRun.runId);
          const now = Date.now();
          for (const event of events2) {
            if (event.eventType === "wait_created") {
              const resumeAt = event.eventData.resumeAt;
              const hasCompleted = events2.some((e) => e.eventType === "wait_completed" && e.correlationId === event.correlationId);
              if (!hasCompleted && now >= resumeAt.getTime()) {
                const completedEvent = await world.events.create(runId, {
                  eventType: "wait_completed",
                  correlationId: event.correlationId
                });
                events2.push(completedEvent);
              }
            }
          }
          const result = await runWorkflow(workflowCode, workflowRun, events2);
          await world.runs.update(runId, {
            status: "completed",
            output: result
          });
          span?.setAttributes({
            ...WorkflowRunStatus("completed"),
            ...WorkflowEventsCount(events2.length)
          });
        } catch (err) {
          if (WorkflowSuspension.is(err)) {
            buildWorkflowSuspensionMessage(runId, err.stepCount, err.hookCount, err.waitCount);
            let minTimeoutSeconds = null;
            for (const queueItem of err.steps) {
              if (queueItem.type === "step") {
                const ops = [];
                const dehydratedInput = dehydrateStepArguments({
                  args: queueItem.args,
                  closureVars: queueItem.closureVars
                }, err.globalThis);
                try {
                  const step = await world.steps.create(runId, {
                    stepId: queueItem.correlationId,
                    stepName: queueItem.stepName,
                    input: dehydratedInput
                  });
                  functionsExports.waitUntil(Promise.all(ops).catch((err2) => {
                    const isAbortError = err2?.name === "AbortError" || err2?.name === "ResponseAborted";
                    if (!isAbortError)
                      throw err2;
                  }));
                  await queueMessage(world, `__wkf_step_${queueItem.stepName}`, {
                    workflowName,
                    workflowRunId: runId,
                    workflowStartedAt,
                    stepId: step.stepId,
                    traceCarrier: await serializeTraceCarrier(),
                    requestedAt: /* @__PURE__ */ new Date()
                  }, {
                    idempotencyKey: queueItem.correlationId
                  });
                } catch (err2) {
                  if (WorkflowAPIError.is(err2) && err2.status === 409) {
                    console.warn(`Step "${queueItem.stepName}" with correlation ID "${queueItem.correlationId}" already exists, skipping: ${err2.message}`);
                    continue;
                  }
                  throw err2;
                }
              } else if (queueItem.type === "hook") {
                try {
                  const hookMetadata = typeof queueItem.metadata === "undefined" ? void 0 : dehydrateStepArguments(queueItem.metadata, err.globalThis);
                  await world.hooks.create(runId, {
                    hookId: queueItem.correlationId,
                    token: queueItem.token,
                    metadata: hookMetadata
                  });
                  await world.events.create(runId, {
                    eventType: "hook_created",
                    correlationId: queueItem.correlationId
                  });
                } catch (err2) {
                  if (WorkflowAPIError.is(err2)) {
                    if (err2.status === 409) {
                      console.warn(`Hook with correlation ID "${queueItem.correlationId}" already exists, skipping: ${err2.message}`);
                      continue;
                    } else if (err2.status === 410) {
                      console.warn(`Workflow run "${runId}" has already completed, skipping hook "${queueItem.correlationId}": ${err2.message}`);
                      continue;
                    }
                  }
                  throw err2;
                }
              } else if (queueItem.type === "wait") {
                try {
                  if (!queueItem.hasCreatedEvent) {
                    await world.events.create(runId, {
                      eventType: "wait_created",
                      correlationId: queueItem.correlationId,
                      eventData: {
                        resumeAt: queueItem.resumeAt
                      }
                    });
                  }
                  const now = Date.now();
                  const resumeAtMs = queueItem.resumeAt.getTime();
                  const delayMs = Math.max(1e3, resumeAtMs - now);
                  const timeoutSeconds = Math.ceil(delayMs / 1e3);
                  if (minTimeoutSeconds === null || timeoutSeconds < minTimeoutSeconds) {
                    minTimeoutSeconds = timeoutSeconds;
                  }
                } catch (err2) {
                  if (WorkflowAPIError.is(err2) && err2.status === 409) {
                    console.warn(`Wait with correlation ID "${queueItem.correlationId}" already exists, skipping: ${err2.message}`);
                    continue;
                  }
                  throw err2;
                }
              }
            }
            span?.setAttributes({
              ...WorkflowRunStatus("pending_steps"),
              ...WorkflowStepsCreated(err.steps.length)
            });
            if (minTimeoutSeconds !== null) {
              return { timeoutSeconds: minTimeoutSeconds };
            }
          } else {
            const errorName = getErrorName(err);
            const errorMessage = err instanceof Error ? err.message : String(err);
            let errorStack = getErrorStack(err);
            if (errorStack) {
              const parsedName = parseWorkflowName(workflowName);
              const filename = parsedName?.path || workflowName;
              errorStack = remapErrorStack(errorStack, filename, workflowCode);
            }
            console.error(`${errorName} while running "${runId}" workflow:

${errorStack}`);
            await world.runs.update(runId, {
              status: "failed",
              error: {
                message: errorMessage,
                stack: errorStack
                // TODO: include error codes when we define them
              }
            });
            span?.setAttributes({
              ...WorkflowRunStatus("failed"),
              ...WorkflowErrorName(errorName),
              ...WorkflowErrorMessage(String(err))
            });
          }
        }
      });
    });
  });
}
const stepEntrypoint = /* @__PURE__ */ getWorldHandlers().createQueueHandler("__wkf_step_", async (message_, metadata) => {
  const { workflowName, workflowRunId, workflowStartedAt, stepId, traceCarrier: traceContext, requestedAt } = StepInvokePayloadSchema.parse(message_);
  const spanLinks = await linkToCurrentContext();
  return await withTraceContext(traceContext, async () => {
    const stepName = metadata.queueName.slice("__wkf_step_".length);
    const world = getWorld();
    const port = await getPort();
    return trace(`STEP ${stepName}`, { kind: await getSpanKind("CONSUMER"), links: spanLinks }, async (span) => {
      span?.setAttributes({
        ...StepName(stepName),
        ...StepAttempt(metadata.attempt),
        ...QueueName(metadata.queueName),
        ...QueueMessageId(metadata.messageId),
        ...getQueueOverhead({ requestedAt })
      });
      const stepFn = getStepFunction(stepName);
      if (!stepFn) {
        throw new Error(`Step "${stepName}" not found`);
      }
      if (typeof stepFn !== "function") {
        throw new Error(`Step "${stepName}" is not a function (got ${typeof stepFn})`);
      }
      span?.setAttributes({
        ...WorkflowName(workflowName),
        ...WorkflowRunId(workflowRunId),
        ...StepId(stepId),
        ...StepMaxRetries(stepFn.maxRetries ?? 3),
        ...StepTracePropagated(!!traceContext)
      });
      let step = await world.steps.get(workflowRunId, stepId);
      runtimeLogger.debug("Step execution details", {
        stepName,
        stepId: step.stepId,
        status: step.status,
        attempt: step.attempt
      });
      span?.setAttributes({
        ...StepStatus(step.status)
      });
      const now = Date.now();
      if (step.retryAfter && step.retryAfter.getTime() > now) {
        const timeoutSeconds = Math.ceil((step.retryAfter.getTime() - now) / 1e3);
        span?.setAttributes({
          ...StepRetryTimeoutSeconds(timeoutSeconds)
        });
        runtimeLogger.debug("Step retryAfter timestamp not yet reached", {
          stepName,
          stepId: step.stepId,
          retryAfter: step.retryAfter,
          timeoutSeconds
        });
        return { timeoutSeconds };
      }
      let result;
      const attempt = step.attempt + 1;
      try {
        if (!["pending", "running"].includes(step.status)) {
          console.error(`[Workflows] "${workflowRunId}" - Step invoked erroneously, expected status "pending" or "running", got "${step.status}" instead, skipping execution`);
          span?.setAttributes({
            ...StepSkipped(true),
            ...StepSkipReason(step.status)
          });
          return;
        }
        await world.events.create(workflowRunId, {
          eventType: "step_started",
          // TODO: Replace with 'step_retrying'
          correlationId: stepId
        });
        step = await world.steps.update(workflowRunId, stepId, {
          attempt,
          status: "running"
        });
        if (!step.startedAt) {
          throw new WorkflowRuntimeError(`Step "${stepId}" has no "startedAt" timestamp`);
        }
        const ops = [];
        const hydratedInput = hydrateStepArguments(step.input, ops, workflowRunId);
        const args = hydratedInput.args;
        span?.setAttributes({
          ...StepArgumentsCount(args.length)
        });
        result = await contextStorage.run({
          stepMetadata: {
            stepId,
            stepStartedAt: /* @__PURE__ */ new Date(+step.startedAt),
            attempt
          },
          workflowMetadata: {
            workflowRunId,
            workflowStartedAt: /* @__PURE__ */ new Date(+workflowStartedAt),
            // TODO: there should be a getUrl method on the world interface itself. This
            // solution only works for vercel + local worlds.
            url: process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : `http://localhost:${port ?? 3e3}`
          },
          ops,
          closureVars: hydratedInput.closureVars
        }, () => stepFn.apply(null, args));
        result = dehydrateStepReturnValue(result, ops, workflowRunId);
        functionsExports.waitUntil(Promise.all(ops).catch((err) => {
          const isAbortError = err?.name === "AbortError" || err?.name === "ResponseAborted";
          if (!isAbortError)
            throw err;
        }));
        await world.steps.update(workflowRunId, stepId, {
          status: "completed",
          output: result
        });
        await world.events.create(workflowRunId, {
          eventType: "step_completed",
          correlationId: stepId,
          eventData: {
            result
          }
        });
        span?.setAttributes({
          ...StepStatus("completed"),
          ...StepResultType(typeof result)
        });
      } catch (err) {
        span?.setAttributes({
          ...StepErrorName(getErrorName(err)),
          ...StepErrorMessage(String(err))
        });
        if (WorkflowAPIError.is(err)) {
          if (err.status === 410) {
            console.warn(`Workflow run "${workflowRunId}" has already completed, skipping step "${stepId}": ${err.message}`);
            return;
          }
        }
        if (FatalError.is(err)) {
          const errorStack = getErrorStack(err);
          const stackLines = errorStack.split("\n").slice(0, 4);
          console.error(`[Workflows] "${workflowRunId}" - Encountered \`FatalError\` while executing step "${stepName}":
  > ${stackLines.join("\n    > ")}

Bubbling up error to parent workflow`);
          await world.events.create(workflowRunId, {
            eventType: "step_failed",
            correlationId: stepId,
            eventData: {
              error: String(err),
              stack: errorStack,
              fatal: true
            }
          });
          await world.steps.update(workflowRunId, stepId, {
            status: "failed",
            error: {
              message: err.message || String(err),
              stack: errorStack
              // TODO: include error codes when we define them
            }
          });
          span?.setAttributes({
            ...StepStatus("failed"),
            ...StepFatalError(true)
          });
        } else {
          const maxRetries = stepFn.maxRetries ?? 3;
          span?.setAttributes({
            ...StepAttempt(attempt),
            ...StepMaxRetries(maxRetries)
          });
          if (attempt >= maxRetries) {
            const errorStack = getErrorStack(err);
            const stackLines = errorStack.split("\n").slice(0, 4);
            console.error(`[Workflows] "${workflowRunId}" - Encountered \`Error\` while executing step "${stepName}" (attempt ${attempt}):
  > ${stackLines.join("\n    > ")}

  Max retries reached
  Bubbling error to parent workflow`);
            const errorMessage = `Step "${stepName}" failed after max retries: ${String(err)}`;
            await world.events.create(workflowRunId, {
              eventType: "step_failed",
              correlationId: stepId,
              eventData: {
                error: errorMessage,
                stack: errorStack,
                fatal: true
              }
            });
            await world.steps.update(workflowRunId, stepId, {
              status: "failed",
              error: {
                message: errorMessage,
                stack: errorStack
              }
            });
            span?.setAttributes({
              ...StepStatus("failed"),
              ...StepRetryExhausted(true)
            });
          } else {
            if (RetryableError.is(err)) {
              console.warn(`[Workflows] "${workflowRunId}" - Encountered \`RetryableError\` while executing step "${stepName}" (attempt ${attempt}):
  > ${String(err.message)}

  This step has failed but will be retried`);
            } else {
              const stackLines = getErrorStack(err).split("\n").slice(0, 4);
              console.error(`[Workflows] "${workflowRunId}" - Encountered \`Error\` while executing step "${stepName}" (attempt ${attempt}):
  > ${stackLines.join("\n    > ")}

  This step has failed but will be retried`);
            }
            await world.events.create(workflowRunId, {
              eventType: "step_failed",
              correlationId: stepId,
              eventData: {
                error: String(err),
                stack: getErrorStack(err)
              }
            });
            await world.steps.update(workflowRunId, stepId, {
              status: "pending",
              // TODO: Should be "retrying" once we have that status
              ...RetryableError.is(err) && {
                retryAfter: err.retryAfter
              }
            });
            const timeoutSeconds = Math.max(1, RetryableError.is(err) ? Math.ceil((+err.retryAfter.getTime() - Date.now()) / 1e3) : 1);
            span?.setAttributes({
              ...StepRetryTimeoutSeconds(timeoutSeconds),
              ...StepRetryWillRetry(true)
            });
            return { timeoutSeconds };
          }
        }
      }
      await queueMessage(world, `__wkf_workflow_${workflowName}`, {
        runId: workflowRunId,
        traceCarrier: await serializeTraceCarrier(),
        requestedAt: /* @__PURE__ */ new Date()
      });
    });
  });
});
async function queueMessage(world, ...args) {
  const queueName = args[0];
  await trace("queueMessage", {
    attributes: QueueName(queueName),
    kind: await getSpanKind("PRODUCER")
  }, async (span) => {
    const { messageId } = await world.queue(...args);
    span?.setAttributes(QueueMessageId(messageId));
  });
}
function getQueueOverhead(message) {
  if (!message.requestedAt)
    return;
  try {
    return QueueOverheadMs(Date.now() - message.requestedAt.getTime());
  } catch {
    return;
  }
}
async function handler(request2, token) {
  if (!token) {
    return new Response("Missing token", {
      status: 400
    });
  }
  try {
    const response2 = await resumeWebhook(token, request2);
    return response2;
  } catch (error) {
    console.error("Error during resumeWebhook", error);
    return new Response(null, {
      status: 404
    });
  }
}
async function normalizeRequestConverter(request2) {
  const options = {
    method: request2.method,
    headers: new Headers(request2.headers)
  };
  if (!["GET", "HEAD", "OPTIONS", "TRACE", "CONNECT"].includes(request2.method)) {
    options.body = await request2.arrayBuffer();
  }
  return new Request(request2.url, options);
}
async function loader$1({
  request: request2,
  params
}) {
  const normalRequest = await normalizeRequestConverter(request2);
  return handler(normalRequest, params.token);
}
async function action$4({
  request: request2,
  params
}) {
  const normalRequest = await normalizeRequestConverter(request2);
  return handler(normalRequest, params.token);
}
const route3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  action: action$4,
  loader: loader$1
}, Symbol.toStringTag, { value: "Module" }));
async function add$1(a, b) {
  return a + b;
}
async function addTenWorkflow$1(input) {
  throw new Error("You attempted to execute workflow addTenWorkflow function directly. To start a workflow, use start(addTenWorkflow) from workflow/api");
}
addTenWorkflow$1.workflowId = "workflow//example/workflows/99_e2e.ts//addTenWorkflow";
async function nestedErrorWorkflow() {
  throw new Error("You attempted to execute workflow nestedErrorWorkflow function directly. To start a workflow, use start(nestedErrorWorkflow) from workflow/api");
}
nestedErrorWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//nestedErrorWorkflow";
async function promiseAllWorkflow() {
  throw new Error("You attempted to execute workflow promiseAllWorkflow function directly. To start a workflow, use start(promiseAllWorkflow) from workflow/api");
}
promiseAllWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//promiseAllWorkflow";
async function promiseRaceWorkflow() {
  throw new Error("You attempted to execute workflow promiseRaceWorkflow function directly. To start a workflow, use start(promiseRaceWorkflow) from workflow/api");
}
promiseRaceWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//promiseRaceWorkflow";
async function promiseAnyWorkflow() {
  throw new Error("You attempted to execute workflow promiseAnyWorkflow function directly. To start a workflow, use start(promiseAnyWorkflow) from workflow/api");
}
promiseAnyWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//promiseAnyWorkflow";
async function readableStreamWorkflow() {
  throw new Error("You attempted to execute workflow readableStreamWorkflow function directly. To start a workflow, use start(readableStreamWorkflow) from workflow/api");
}
readableStreamWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//readableStreamWorkflow";
async function hookWorkflow(token, customData) {
  throw new Error("You attempted to execute workflow hookWorkflow function directly. To start a workflow, use start(hookWorkflow) from workflow/api");
}
hookWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//hookWorkflow";
async function webhookWorkflow(token, token2, token3) {
  throw new Error("You attempted to execute workflow webhookWorkflow function directly. To start a workflow, use start(webhookWorkflow) from workflow/api");
}
webhookWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//webhookWorkflow";
async function sleepingWorkflow() {
  throw new Error("You attempted to execute workflow sleepingWorkflow function directly. To start a workflow, use start(sleepingWorkflow) from workflow/api");
}
sleepingWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//sleepingWorkflow";
async function nullByteWorkflow() {
  throw new Error("You attempted to execute workflow nullByteWorkflow function directly. To start a workflow, use start(nullByteWorkflow) from workflow/api");
}
nullByteWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//nullByteWorkflow";
async function workflowAndStepMetadataWorkflow() {
  throw new Error("You attempted to execute workflow workflowAndStepMetadataWorkflow function directly. To start a workflow, use start(workflowAndStepMetadataWorkflow) from workflow/api");
}
workflowAndStepMetadataWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//workflowAndStepMetadataWorkflow";
async function outputStreamWorkflow() {
  throw new Error("You attempted to execute workflow outputStreamWorkflow function directly. To start a workflow, use start(outputStreamWorkflow) from workflow/api");
}
outputStreamWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//outputStreamWorkflow";
async function outputStreamInsideStepWorkflow() {
  throw new Error("You attempted to execute workflow outputStreamInsideStepWorkflow function directly. To start a workflow, use start(outputStreamInsideStepWorkflow) from workflow/api");
}
outputStreamInsideStepWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//outputStreamInsideStepWorkflow";
async function fetchWorkflow() {
  throw new Error("You attempted to execute workflow fetchWorkflow function directly. To start a workflow, use start(fetchWorkflow) from workflow/api");
}
fetchWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//fetchWorkflow";
async function promiseRaceStressTestDelayStep(dur, resp) {
  console.log(`sleep`, resp, `/`, dur);
  await new Promise((resolve2) => setTimeout(resolve2, dur));
  console.log(resp, `done`);
  return resp;
}
async function promiseRaceStressTestWorkflow() {
  throw new Error("You attempted to execute workflow promiseRaceStressTestWorkflow function directly. To start a workflow, use start(promiseRaceStressTestWorkflow) from workflow/api");
}
promiseRaceStressTestWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//promiseRaceStressTestWorkflow";
async function retryAttemptCounterWorkflow() {
  throw new Error("You attempted to execute workflow retryAttemptCounterWorkflow function directly. To start a workflow, use start(retryAttemptCounterWorkflow) from workflow/api");
}
retryAttemptCounterWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//retryAttemptCounterWorkflow";
async function crossFileErrorWorkflow() {
  throw new Error("You attempted to execute workflow crossFileErrorWorkflow function directly. To start a workflow, use start(crossFileErrorWorkflow) from workflow/api");
}
crossFileErrorWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//crossFileErrorWorkflow";
async function retryableAndFatalErrorWorkflow() {
  throw new Error("You attempted to execute workflow retryableAndFatalErrorWorkflow function directly. To start a workflow, use start(retryableAndFatalErrorWorkflow) from workflow/api");
}
retryableAndFatalErrorWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//retryableAndFatalErrorWorkflow";
async function hookCleanupTestWorkflow(token, customData) {
  throw new Error("You attempted to execute workflow hookCleanupTestWorkflow function directly. To start a workflow, use start(hookCleanupTestWorkflow) from workflow/api");
}
hookCleanupTestWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//hookCleanupTestWorkflow";
async function stepFunctionPassingWorkflow() {
  throw new Error("You attempted to execute workflow stepFunctionPassingWorkflow function directly. To start a workflow, use start(stepFunctionPassingWorkflow) from workflow/api");
}
stepFunctionPassingWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//stepFunctionPassingWorkflow";
async function stepFunctionWithClosureWorkflow() {
  throw new Error("You attempted to execute workflow stepFunctionWithClosureWorkflow function directly. To start a workflow, use start(stepFunctionWithClosureWorkflow) from workflow/api");
}
stepFunctionWithClosureWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//stepFunctionWithClosureWorkflow";
async function closureVariableWorkflow(baseValue) {
  throw new Error("You attempted to execute workflow closureVariableWorkflow function directly. To start a workflow, use start(closureVariableWorkflow) from workflow/api");
}
closureVariableWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//closureVariableWorkflow";
async function childWorkflow(value) {
  throw new Error("You attempted to execute workflow childWorkflow function directly. To start a workflow, use start(childWorkflow) from workflow/api");
}
childWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//childWorkflow";
async function spawnWorkflowFromStepWorkflow(inputValue) {
  throw new Error("You attempted to execute workflow spawnWorkflowFromStepWorkflow function directly. To start a workflow, use start(spawnWorkflowFromStepWorkflow) from workflow/api");
}
spawnWorkflowFromStepWorkflow.workflowId = "workflow//example/workflows/99_e2e.ts//spawnWorkflowFromStepWorkflow";
const workflow_99_e2e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: add$1,
  addTenWorkflow: addTenWorkflow$1,
  childWorkflow,
  closureVariableWorkflow,
  crossFileErrorWorkflow,
  fetchWorkflow,
  hookCleanupTestWorkflow,
  hookWorkflow,
  nestedErrorWorkflow,
  nullByteWorkflow,
  outputStreamInsideStepWorkflow,
  outputStreamWorkflow,
  promiseAllWorkflow,
  promiseAnyWorkflow,
  promiseRaceStressTestDelayStep,
  promiseRaceStressTestWorkflow,
  promiseRaceWorkflow,
  readableStreamWorkflow,
  retryAttemptCounterWorkflow,
  retryableAndFatalErrorWorkflow,
  sleepingWorkflow,
  spawnWorkflowFromStepWorkflow,
  stepFunctionPassingWorkflow,
  stepFunctionWithClosureWorkflow,
  webhookWorkflow,
  workflowAndStepMetadataWorkflow
}, Symbol.toStringTag, { value: "Module" }));
async function action$3({
  request: request2
}) {
  const body2 = await request2.json();
  const {
    x,
    y
  } = body2;
  console.log(`Calling step function directly with x=${x}, y=${y}`);
  const result = await add$1(x, y);
  console.log(`add(${x}, ${y}) = ${result}`);
  return Response.json({
    result
  });
}
const route4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  action: action$3
}, Symbol.toStringTag, { value: "Module" }));
async function simple(i) {
  throw new Error("You attempted to execute workflow simple function directly. To start a workflow, use start(simple) from workflow/api");
}
simple.workflowId = "workflow//example/workflows/1_simple.ts//simple";
const workflow_1_simple = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  simple
}, Symbol.toStringTag, { value: "Module" }));
async function control_flow() {
  throw new Error("You attempted to execute workflow control_flow function directly. To start a workflow, use start(control_flow) from workflow/api");
}
control_flow.workflowId = "workflow//example/workflows/2_control_flow.ts//control_flow";
const workflow_2_control_flow = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  control_flow
}, Symbol.toStringTag, { value: "Module" }));
async function genStream() {
  const stream = new ReadableStream({
    async start(controller) {
      const encoder = new TextEncoder();
      for (let i = 0; i < 30; i++) {
        const chunk = encoder.encode(`${i}
`);
        controller.enqueue(chunk);
        console.log(`Enqueued number: ${i}`);
        await new Promise((resolve2) => setTimeout(resolve2, 2500));
      }
      controller.close();
    }
  });
  return stream;
}
async function consumeStreams(...streams2) {
  const parts = [];
  console.log("Consuming streams", streams2);
  await Promise.all(streams2.map(async (s, i) => {
    const reader = s.getReader();
    while (true) {
      const result = await reader.read();
      if (result.done) break;
      console.log(`Received ${result.value.length} bytes from stream ${i}: ${JSON.stringify(new TextDecoder().decode(result.value))}`);
      parts.push(result.value);
    }
  }));
  return Buffer.concat(parts).toString("utf8");
}
async function streams() {
  throw new Error("You attempted to execute workflow streams function directly. To start a workflow, use start(streams) from workflow/api");
}
streams.workflowId = "workflow//example/workflows/3_streams.ts//streams";
const workflows = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  consumeStreams,
  genStream,
  streams
}, Symbol.toStringTag, { value: "Module" }));
async function ai(prompt) {
  throw new Error("You attempted to execute workflow ai function directly. To start a workflow, use start(ai) from workflow/api");
}
ai.workflowId = "workflow//example/workflows/4_ai.ts//ai";
async function agent(prompt) {
  throw new Error("You attempted to execute workflow agent function directly. To start a workflow, use start(agent) from workflow/api");
}
agent.workflowId = "workflow//example/workflows/4_ai.ts//agent";
const workflow_4_ai = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  agent,
  ai
}, Symbol.toStringTag, { value: "Module" }));
async function withWorkflowMetadata() {
  throw new Error("You attempted to execute workflow withWorkflowMetadata function directly. To start a workflow, use start(withWorkflowMetadata) from workflow/api");
}
withWorkflowMetadata.workflowId = "workflow//example/workflows/5_hooks.ts//withWorkflowMetadata";
async function withCreateHook() {
  throw new Error("You attempted to execute workflow withCreateHook function directly. To start a workflow, use start(withCreateHook) from workflow/api");
}
withCreateHook.workflowId = "workflow//example/workflows/5_hooks.ts//withCreateHook";
const workflow_5_hooks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  withCreateHook,
  withWorkflowMetadata
}, Symbol.toStringTag, { value: "Module" }));
async function batchOverSteps() {
  throw new Error("You attempted to execute workflow batchOverSteps function directly. To start a workflow, use start(batchOverSteps) from workflow/api");
}
batchOverSteps.workflowId = "workflow//example/workflows/6_batching.ts//batchOverSteps";
async function batchInStep() {
  throw new Error("You attempted to execute workflow batchInStep function directly. To start a workflow, use start(batchInStep) from workflow/api");
}
batchInStep.workflowId = "workflow//example/workflows/6_batching.ts//batchInStep";
const workflow_6_batching = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  batchInStep,
  batchOverSteps
}, Symbol.toStringTag, { value: "Module" }));
async function handleUserSignup(email) {
  throw new Error("You attempted to execute workflow handleUserSignup function directly. To start a workflow, use start(handleUserSignup) from workflow/api");
}
handleUserSignup.workflowId = "workflow//example/workflows/7_full.ts//handleUserSignup";
const workflow_7_full = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  handleUserSignup
}, Symbol.toStringTag, { value: "Module" }));
async function noStepsWorkflow(input) {
  throw new Error("You attempted to execute workflow noStepsWorkflow function directly. To start a workflow, use start(noStepsWorkflow) from workflow/api");
}
noStepsWorkflow.workflowId = "workflow//example/workflows/97_bench.ts//noStepsWorkflow";
async function oneStepWorkflow(input) {
  throw new Error("You attempted to execute workflow oneStepWorkflow function directly. To start a workflow, use start(oneStepWorkflow) from workflow/api");
}
oneStepWorkflow.workflowId = "workflow//example/workflows/97_bench.ts//oneStepWorkflow";
async function tenSequentialStepsWorkflow() {
  throw new Error("You attempted to execute workflow tenSequentialStepsWorkflow function directly. To start a workflow, use start(tenSequentialStepsWorkflow) from workflow/api");
}
tenSequentialStepsWorkflow.workflowId = "workflow//example/workflows/97_bench.ts//tenSequentialStepsWorkflow";
async function tenParallelStepsWorkflow() {
  throw new Error("You attempted to execute workflow tenParallelStepsWorkflow function directly. To start a workflow, use start(tenParallelStepsWorkflow) from workflow/api");
}
tenParallelStepsWorkflow.workflowId = "workflow//example/workflows/97_bench.ts//tenParallelStepsWorkflow";
async function streamWorkflow() {
  throw new Error("You attempted to execute workflow streamWorkflow function directly. To start a workflow, use start(streamWorkflow) from workflow/api");
}
streamWorkflow.workflowId = "workflow//example/workflows/97_bench.ts//streamWorkflow";
const workflow_97_bench = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  noStepsWorkflow,
  oneStepWorkflow,
  streamWorkflow,
  tenParallelStepsWorkflow,
  tenSequentialStepsWorkflow
}, Symbol.toStringTag, { value: "Module" }));
async function addTenWorkflow(input) {
  throw new Error("You attempted to execute workflow addTenWorkflow function directly. To start a workflow, use start(addTenWorkflow) from workflow/api");
}
addTenWorkflow.workflowId = "workflow//example/workflows/98_duplicate_case.ts//addTenWorkflow";
async function add(a, b) {
  return a + b;
}
const workflow_98_duplicate_case = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add,
  addTenWorkflow
}, Symbol.toStringTag, { value: "Module" }));
const allWorkflows = {
  "workflows/1_simple.ts": workflow_1_simple,
  "workflows/2_control_flow.ts": workflow_2_control_flow,
  "workflows/3_streams.ts": workflows,
  "workflows/4_ai.ts": workflow_4_ai,
  "workflows/5_hooks.ts": workflow_5_hooks,
  "workflows/6_batching.ts": workflow_6_batching,
  "workflows/7_full.ts": workflow_7_full,
  "workflows/97_bench.ts": workflow_97_bench,
  "workflows/98_duplicate_case.ts": workflow_98_duplicate_case,
  "workflows/99_e2e.ts": workflow_99_e2e
};
async function loader({
  request: request2
}) {
  const url = new URL(request2.url);
  const runId = url.searchParams.get("runId");
  if (!runId) {
    return new Response("No runId provided", {
      status: 400
    });
  }
  const outputStreamParam = url.searchParams.get("output-stream");
  if (outputStreamParam) {
    const namespace = outputStreamParam === "1" ? void 0 : outputStreamParam;
    const run = getRun(runId);
    const stream = run.getReadable({
      namespace
    });
    const streamWithFraming = new TransformStream({
      transform(chunk, controller) {
        const data = chunk instanceof Uint8Array ? {
          data: Buffer.from(chunk).toString("base64")
        } : chunk;
        controller.enqueue(`${JSON.stringify(data)}
`);
      }
    });
    return new Response(stream.pipeThrough(streamWithFraming), {
      headers: {
        "Content-Type": "application/octet-stream"
      }
    });
  }
  try {
    const run = getRun(runId);
    const returnValue = await run.returnValue;
    console.log("Return value:", returnValue);
    const [createdAt, startedAt, completedAt] = await Promise.all([run.createdAt, run.startedAt, run.completedAt]);
    const headers2 = returnValue instanceof ReadableStream ? {
      "Content-Type": "application/octet-stream"
    } : {};
    headers2["X-Workflow-Run-Created-At"] = createdAt?.toISOString() || "";
    headers2["X-Workflow-Run-Started-At"] = startedAt?.toISOString() || "";
    headers2["X-Workflow-Run-Completed-At"] = completedAt?.toISOString() || "";
    return returnValue instanceof ReadableStream ? new Response(returnValue, {
      headers: headers2
    }) : Response.json(returnValue, {
      headers: headers2
    });
  } catch (error) {
    if (error instanceof Error) {
      if (WorkflowRunNotCompletedError.is(error)) {
        return Response.json({
          ...error,
          name: error.name,
          message: error.message
        }, {
          status: 202
        });
      }
      if (WorkflowRunFailedError.is(error)) {
        const cause = error.cause;
        return Response.json({
          ...error,
          name: error.name,
          message: error.message,
          cause: {
            message: cause.message,
            stack: cause.stack,
            code: cause.code
          }
        }, {
          status: 400
        });
      }
    }
    console.error("Unexpected error while getting workflow return value:", error);
    return Response.json({
      error: "Internal server error"
    }, {
      status: 500
    });
  }
}
async function action$2({
  request: request2
}) {
  const url = new URL(request2.url);
  const workflowFile = url.searchParams.get("workflowFile") || "workflows/99_e2e.ts";
  const workflows2 = allWorkflows[workflowFile];
  if (!workflows2) {
    return new Response(`Workflow file "${workflowFile}" not found`, {
      status: 400
    });
  }
  const workflowFn = url.searchParams.get("workflowFn") || "simple";
  const workflow = workflows2[workflowFn];
  if (!workflow) {
    return new Response(`Workflow "${workflowFn}" not found`, {
      status: 400
    });
  }
  let args = [];
  const argsParam = url.searchParams.get("args");
  if (argsParam) {
    args = argsParam.split(",").map((arg) => {
      const num = parseFloat(arg);
      return Number.isNaN(num) ? arg.trim() : num;
    });
  } else {
    const body2 = await request2.text();
    if (body2) {
      args = hydrateWorkflowArguments(JSON.parse(body2), globalThis);
    } else {
      args = [42];
    }
  }
  console.log(`Starting "${workflowFn}" workflow with args: ${args}`);
  try {
    const run = await start(workflow, args);
    console.log("Run:", run.runId);
    return Response.json(run);
  } catch (err) {
    console.error(`Failed to start!!`, err);
    throw err;
  }
}
const route5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  action: action$2,
  loader
}, Symbol.toStringTag, { value: "Module" }));
async function action$1() {
  console.log(workflows);
  return Response.json("hello world");
}
const route6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  action: action$1
}, Symbol.toStringTag, { value: "Module" }));
async function action({
  request: request2
}) {
  const {
    token,
    data
  } = await request2.json();
  let hook;
  try {
    hook = await getHookByToken(token);
    console.log("hook", hook);
  } catch (error) {
    console.log("error during getHookByToken", error);
    return Response.json(null, {
      status: 404
    });
  }
  await resumeHook(hook.token, {
    ...data,
    // @ts-expect-error metadata is not typed
    customData: hook.metadata?.customData
  });
  return Response.json(hook);
}
const route7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  action
}, Symbol.toStringTag, { value: "Module" }));
function meta(_) {
  return [{
    title: "Workflow DevKit + React Router Example"
  }, {
    name: "description",
    content: "Workflow DevKit running with React Router"
  }];
}
const _index = UNSAFE_withComponentProps(function Home() {
  const outputRef = useRef(null);
  useEffect(() => {
    const outputEl = outputRef.current;
    if (!outputEl) return;
    function log(...args) {
      if (!outputEl) return;
      outputEl.textContent += args.map((arg) => typeof arg === "string" ? arg : JSON.stringify(arg)).join(" ") + "\n";
    }
    function tryFormatJSON(text) {
      try {
        return JSON.stringify(JSON.parse(text), null, 2);
      } catch {
        return text;
      }
    }
    async function fetchAndLog(input, init) {
      try {
        const req = new Request(input, init);
        log(`[${req.method}] ${input}`);
        const res = await fetch(req);
        const text = await res.text();
        if (res.ok) {
          log("Response:", tryFormatJSON(text));
          return JSON.parse(text);
        } else {
          log("Error", res.status, res.statusText, tryFormatJSON(text));
        }
      } catch (error) {
        log("Fetch error:", error instanceof Error ? error.toString() : String(error));
      }
      return {};
    }
    async function main() {
      const {
        runId
      } = await fetchAndLog("/api/trigger?workflowFile=workflows/0_calc.ts&workflowFn=calc&args=2", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: ""
      });
      if (runId) {
        log("Getting workflow status with runId:", runId);
        await fetchAndLog(`/api/trigger?runId=${runId}`);
      }
    }
    main().catch((error) => log("Main error:", error instanceof Error ? error.toString() : String(error)));
  }, []);
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx("style", {
      children: `
          * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
          }

          body {
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family:
              -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,
              Cantarell, sans-serif;
            padding: 20px;
          }

          h1 {
            font-size: 24px;
            margin-bottom: 10px;
          }

          hr {
            border: none;
            border-top: 1px solid #3e3e3e;
            margin-bottom: 20px;
          }

          textarea {
            width: 100%;
            height: calc(100vh - 140px);
            max-height: calc(100vh - 140px);
            box-sizing: border-box;
            padding: 12px;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", "Consolas", monospace;
            font-size: 14px;
            resize: none;
            overflow: auto;
            background-color: #252526;
            color: #d4d4d4;
            border: 1px solid #3e3e3e;
            border-radius: 4px;
          }

          textarea:focus {
            outline: none;
            border-color: #007acc;
          }

          textarea::placeholder {
            color: #6a6a6a;
          }
        `
    }), /* @__PURE__ */ jsx("h1", {
      children: "Workflow DevKit + React Router Example"
    }), /* @__PURE__ */ jsx("hr", {}), /* @__PURE__ */ jsx("textarea", {
      ref: outputRef,
      readOnly: true,
      placeholder: "output"
    })]
  });
});
const route8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _index,
  meta
}, Symbol.toStringTag, { value: "Module" }));
const serverManifest = { "entry": { "module": "/assets/entry.client-D5ATaC0x.js", "imports": ["/assets/chunk-WWGJGFF6-DfkQwNBd.js"], "css": [] }, "routes": { "root": { "id": "root", "parentId": void 0, "path": "", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": true, "module": "/assets/root-tro-0BVK.js", "imports": ["/assets/chunk-WWGJGFF6-DfkQwNBd.js"], "css": ["/assets/root-DDauIycs.css"], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/.workflow/flow": { "id": "routes/.workflow/flow", "parentId": "root", "path": ".well-known/workflow/v1/flow", "index": void 0, "caseSensitive": void 0, "hasAction": true, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/flow-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/.workflow/step": { "id": "routes/.workflow/step", "parentId": "root", "path": ".well-known/workflow/v1/step", "index": void 0, "caseSensitive": void 0, "hasAction": true, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/step-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/.workflow/webhook/[token]": { "id": "routes/.workflow/webhook/[token]", "parentId": "root", "path": ".well-known/workflow/v1/webhook/:token", "index": void 0, "caseSensitive": void 0, "hasAction": true, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/_token_-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/api.test-direct-step-call": { "id": "routes/api.test-direct-step-call", "parentId": "root", "path": "api/test-direct-step-call", "index": void 0, "caseSensitive": void 0, "hasAction": true, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/api.test-direct-step-call-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/api.trigger": { "id": "routes/api.trigger", "parentId": "root", "path": "api/trigger", "index": void 0, "caseSensitive": void 0, "hasAction": true, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/api.trigger-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/api.chat": { "id": "routes/api.chat", "parentId": "root", "path": "api/chat", "index": void 0, "caseSensitive": void 0, "hasAction": true, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/api.chat-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/api.hook": { "id": "routes/api.hook", "parentId": "root", "path": "api/hook", "index": void 0, "caseSensitive": void 0, "hasAction": true, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/api.hook-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/_index": { "id": "routes/_index", "parentId": "root", "path": void 0, "index": true, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/_index-CzIpZ65p.js", "imports": ["/assets/chunk-WWGJGFF6-DfkQwNBd.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 } }, "url": "/assets/manifest-b79efd95.js", "version": "b79efd95", "sri": void 0 };
const assetsBuildDirectory = "build/client";
const basename = "/";
const future = { "unstable_optimizeDeps": false, "unstable_subResourceIntegrity": false, "v8_middleware": false, "v8_splitRouteModules": false, "v8_viteEnvironmentApi": false };
const ssr = true;
const isSpaMode = false;
const prerender = [];
const routeDiscovery = { "mode": "lazy", "manifestPath": "/__manifest" };
const publicPath = "/";
const entry = { module: entryServer };
const routes = {
  "root": {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: route0
  },
  "routes/.workflow/flow": {
    id: "routes/.workflow/flow",
    parentId: "root",
    path: ".well-known/workflow/v1/flow",
    index: void 0,
    caseSensitive: void 0,
    module: route1
  },
  "routes/.workflow/step": {
    id: "routes/.workflow/step",
    parentId: "root",
    path: ".well-known/workflow/v1/step",
    index: void 0,
    caseSensitive: void 0,
    module: route2
  },
  "routes/.workflow/webhook/[token]": {
    id: "routes/.workflow/webhook/[token]",
    parentId: "root",
    path: ".well-known/workflow/v1/webhook/:token",
    index: void 0,
    caseSensitive: void 0,
    module: route3
  },
  "routes/api.test-direct-step-call": {
    id: "routes/api.test-direct-step-call",
    parentId: "root",
    path: "api/test-direct-step-call",
    index: void 0,
    caseSensitive: void 0,
    module: route4
  },
  "routes/api.trigger": {
    id: "routes/api.trigger",
    parentId: "root",
    path: "api/trigger",
    index: void 0,
    caseSensitive: void 0,
    module: route5
  },
  "routes/api.chat": {
    id: "routes/api.chat",
    parentId: "root",
    path: "api/chat",
    index: void 0,
    caseSensitive: void 0,
    module: route6
  },
  "routes/api.hook": {
    id: "routes/api.hook",
    parentId: "root",
    path: "api/hook",
    index: void 0,
    caseSensitive: void 0,
    module: route7
  },
  "routes/_index": {
    id: "routes/_index",
    parentId: "root",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: route8
  }
};
export {
  WorkflowServerWritableStream as W,
  getSerializeStream as a,
  getExternalReducers as b,
  contextStorage as c,
  start as d,
  getRun as e,
  getDefaultExportFromCjs as f,
  getWorkflowRunStreamId as g,
  requireTokenError as h,
  assetsBuildDirectory as i,
  basename as j,
  future as k,
  ssr as l,
  isSpaMode as m,
  routeDiscovery as n,
  publicPath as o,
  prerender as p,
  entry as q,
  registerStepFunction as r,
  stepEntrypoint as s,
  routes as t,
  serverManifest as u,
  workflowEntrypoint as w
};
